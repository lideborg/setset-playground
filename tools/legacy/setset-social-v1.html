<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Setset Social</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ“±</text></svg>">
    <link rel="stylesheet" href="/shared/css/tokens.css">
    <link rel="stylesheet" href="/shared/css/base.css">
    <link rel="stylesheet" href="/shared/css/components.css">
    <style>
        .container {
            max-width: 1200px;
        }

        /* Mode Tabs */
        .mode-tabs {
            display: flex;
            gap: var(--space-xs);
            margin-bottom: var(--space-lg);
            background: var(--white);
            padding: var(--space-sm);
            border-radius: var(--radius-md);
            border: 1px solid var(--gainsboro);
        }

        .mode-tab {
            flex: 1;
            padding: 16px 24px;
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-sm);
            background: var(--off-white);
            cursor: pointer;
            text-align: center;
            transition: all var(--transition-fast);
        }

        .mode-tab:hover {
            border-color: var(--ash-grey);
        }

        .mode-tab.active {
            background: var(--jet);
            color: var(--white);
            border-color: var(--jet);
        }

        .mode-tab-title {
            font-size: var(--text-md);
            font-weight: 600;
            margin-bottom: 4px;
        }

        .mode-tab-desc {
            font-size: var(--text-xs);
            opacity: 0.7;
        }

        /* Section styling */
        .section {
            background: var(--white);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-md);
            padding: var(--space-md);
            margin-bottom: var(--space-md);
        }

        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--space-sm);
        }

        .section-title {
            font-size: var(--text-sm);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--carbon);
        }

        .section-badge {
            font-size: var(--text-2xs);
            padding: 2px 8px;
            border-radius: var(--radius-sm);
            background: var(--off-white);
            color: var(--slate);
        }

        .section-hint {
            font-size: var(--text-xs);
            color: var(--ash-grey);
            margin-top: var(--space-xs);
        }

        /* Talent Grid - 12 columns x 2 rows */
        .talent-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: var(--space-xs);
        }

        @media (min-width: 800px) {
            .talent-grid {
                grid-template-columns: repeat(12, 1fr);
            }
        }

        .talent-card {
            position: relative;
            aspect-ratio: 3/4;
            border-radius: var(--radius-sm);
            overflow: hidden;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all var(--transition-fast);
        }

        .talent-card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .talent-card:hover {
            border-color: var(--ash-grey);
        }

        .talent-card.selected {
            border-color: var(--jet);
        }

        .talent-card.selected::after {
            content: 'âœ“';
            position: absolute;
            top: 4px;
            right: 4px;
            width: 20px;
            height: 20px;
            background: var(--jet);
            color: var(--white);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .talent-card.primary {
            border-color: #2563eb;
        }

        .talent-card.primary::after {
            content: 'â˜…';
            background: #2563eb;
        }

        .talent-card.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .talent-name {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 4px;
            background: linear-gradient(transparent, rgba(0,0,0,0.7));
            color: white;
            font-size: var(--text-2xs);
            text-align: center;
        }

        /* Mood Board Grid */
        .moodboard-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: var(--space-xs);
        }

        @media (min-width: 800px) {
            .moodboard-grid {
                grid-template-columns: repeat(12, 1fr);
            }
        }

        .upload-slot {
            aspect-ratio: 3/4;
            border: 1px dashed var(--gainsboro);
            border-radius: var(--radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            background: var(--off-white);
            transition: all var(--transition-fast);
        }

        .upload-slot:hover {
            border-color: var(--ash-grey);
        }

        .upload-slot.filled {
            border-style: solid;
            border-color: transparent;
        }

        .upload-slot.filled img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .upload-slot .plus {
            font-size: 18px;
            font-weight: 300;
            color: var(--ash-grey);
        }

        .upload-slot .remove-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 20px;
            height: 20px;
            background: rgba(0,0,0,0.7);
            color: var(--white);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 12px;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .upload-slot.filled:hover .remove-btn {
            display: flex;
        }

        /* Output Grid - 12 slots (6 columns x 2 rows) */
        .output-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: var(--space-sm);
        }

        @media (min-width: 600px) {
            .output-grid {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        @media (min-width: 900px) {
            .output-grid {
                grid-template-columns: repeat(6, 1fr);
            }
        }

        .output-slot-wrapper {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .output-slot {
            aspect-ratio: 3/4;
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-sm);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: var(--off-white);
            position: relative;
            padding: var(--space-xs);
            cursor: pointer;
            transition: all var(--transition-fast);
            opacity: 0.4;
        }

        .output-slot:hover {
            border-color: var(--ash-grey);
        }

        .output-slot.active {
            border-color: var(--jet);
            background: var(--white);
            opacity: 1;
        }

        .output-slot .slot-number {
            font-size: var(--text-lg);
            font-weight: 600;
            color: var(--carbon);
            margin-bottom: 4px;
        }

        .output-slot .slot-type {
            font-size: var(--text-2xs);
            color: var(--ash-grey);
            text-align: center;
            margin-bottom: 8px;
        }

        .output-slot .people-count {
            font-size: var(--text-xs);
            color: var(--slate);
            font-weight: 500;
        }

        .output-slider {
            width: 100%;
            margin-top: 8px;
            height: 24px;
            -webkit-appearance: none;
            background: transparent;
            cursor: pointer;
        }

        .output-slider::-webkit-slider-runnable-track {
            width: 100%;
            height: 6px;
            background: var(--gainsboro);
            border-radius: 3px;
        }

        .output-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--jet);
            cursor: pointer;
            margin-top: -7px;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .output-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        /* Caption preview */
        .caption-preview {
            background: var(--off-white);
            border-radius: var(--radius-sm);
            padding: var(--space-sm);
            margin-top: var(--space-md);
        }

        .caption-preview-label {
            font-size: var(--text-xs);
            color: var(--ash-grey);
            margin-bottom: 4px;
        }

        .caption-preview-text {
            font-size: var(--text-sm);
            color: var(--carbon);
            font-style: italic;
        }

        /* Results Grid */
        .results-section {
            display: none;
        }

        .results-section.visible {
            display: block;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: var(--space-sm);
        }

        @media (min-width: 600px) {
            .results-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (min-width: 800px) {
            .results-grid {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        @media (min-width: 1000px) {
            .results-grid {
                grid-template-columns: repeat(6, 1fr);
            }
        }

        .result-card {
            position: relative;
            aspect-ratio: 3/4;
            border-radius: var(--radius-sm);
            overflow: hidden;
            background: var(--off-white);
            border: 1px solid var(--gainsboro);
        }

        .result-card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            cursor: pointer;
        }

        .result-card img:hover {
            opacity: 0.95;
        }

        .result-card.generating {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .result-card .spinner {
            width: 24px;
            height: 24px;
            border: 2px solid var(--gainsboro);
            border-top-color: var(--jet);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .result-card .download-btn {
            position: absolute;
            bottom: 8px;
            right: 8px;
            padding: 4px 8px;
            background: rgba(0,0,0,0.7);
            color: white;
            border: none;
            border-radius: var(--radius-xs);
            font-size: var(--text-xs);
            cursor: pointer;
            opacity: 0;
            transition: opacity var(--transition-fast);
        }

        .result-card:hover .download-btn {
            opacity: 1;
        }

        /* Influence slider */
        .influence-control {
            padding: var(--space-sm) 0;
        }

        .influence-slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: var(--gainsboro);
            outline: none;
            -webkit-appearance: none;
        }

        .influence-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--jet);
            cursor: pointer;
        }

        .influence-labels {
            display: flex;
            justify-content: space-between;
            font-size: var(--text-xs);
            color: var(--ash-grey);
            margin-top: 4px;
        }

        /* Generate section */
        .generate-section {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: var(--space-md);
            padding: var(--space-md);
            background: var(--white);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-md);
            margin-bottom: var(--space-md);
        }

        .generate-info {
            font-size: var(--text-sm);
            color: var(--slate);
        }

        .generate-btn {
            padding: 14px 32px;
            font-size: 15px;
            min-width: 200px;
        }

        input[type="file"] {
            display: none;
        }

        /* Lightbox */
        .lightbox {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .lightbox.active {
            display: flex;
        }

        .lightbox-content {
            position: relative;
            max-width: 90vw;
            max-height: 90vh;
        }

        .lightbox-content img {
            max-width: 100%;
            max-height: 90vh;
            object-fit: contain;
            border-radius: var(--radius-sm);
        }

        .lightbox-close {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1001;
        }

        .lightbox-close:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .lightbox-nav {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .lightbox-nav:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .lightbox-prev {
            left: 20px;
        }

        .lightbox-next {
            right: 20px;
        }

        .lightbox-info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: var(--space-sm);
            align-items: center;
        }

        .lightbox-counter {
            color: rgba(255, 255, 255, 0.7);
            font-size: var(--text-sm);
        }

        .lightbox-download {
            padding: 8px 16px;
            background: white;
            color: var(--jet);
            border: none;
            border-radius: var(--radius-sm);
            font-size: var(--text-sm);
            cursor: pointer;
        }

        .lightbox-download:hover {
            background: var(--off-white);
        }

        /* Inline loader with studio messages */
        .inline-loader {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: var(--space-lg);
            background: var(--off-white);
            border-radius: var(--radius-md);
            margin-bottom: var(--space-md);
        }

        .inline-loader.visible {
            display: flex;
        }

        .loader-message {
            font-size: var(--text-lg);
            font-weight: 600;
            background: linear-gradient(90deg,
                rgba(0, 47, 167, 0.4) 0%,
                rgba(0, 47, 167, 1) 50%,
                rgba(0, 47, 167, 0.4) 100%);
            background-size: 200% 100%;
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: sweep 2s ease-in-out infinite;
        }

        .loader-message.fade-out {
            animation: fade-out 0.25s ease-out forwards;
        }

        .loader-message.fade-in {
            animation: fade-in 0.25s ease-out forwards, sweep 2s ease-in-out infinite;
        }

        @keyframes sweep {
            0% { background-position: 100% 0; }
            100% { background-position: -100% 0; }
        }

        @keyframes fade-out {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        @keyframes fade-in {
            0% { opacity: 0; }
            100% { opacity: 1; }
        }

        .loader-progress {
            font-size: var(--text-sm);
            color: var(--slate);
            margin-top: var(--space-xs);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="hero">
            <h1>Setset Social</h1>
            <p class="hero-subtitle">Generate Instagram-ready carousels for E-commerce, Campaign, or Casting</p>
        </div>

        <!-- Mode Selection -->
        <div class="mode-tabs">
            <div class="mode-tab active" data-mode="ecommerce">
                <div class="mode-tab-title">E-commerce</div>
                <div class="mode-tab-desc">White BG + minimal settings</div>
            </div>
            <div class="mode-tab" data-mode="campaign">
                <div class="mode-tab-title">Campaign</div>
                <div class="mode-tab-desc">Editorial world-building</div>
            </div>
            <div class="mode-tab" data-mode="casting">
                <div class="mode-tab-title">Casting</div>
                <div class="mode-tab-desc">Talent showcase</div>
            </div>
        </div>

        <!-- Talent Selection -->
        <div class="section" id="talent-section">
            <div class="section-header">
                <span class="section-title">Select Talent</span>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <button class="btn btn--sm" id="random-talent-btn">Random 5</button>
                    <span class="section-badge" id="talent-badge">0/8 selected</span>
                </div>
            </div>
            <div class="talent-grid" id="talent-grid"></div>
            <p class="section-hint" id="talent-hint">Select up to 8 models. They will be randomly assigned to images.</p>
        </div>

        <!-- Moodboard -->
        <div class="section" id="moodboard-section">
            <div class="section-header">
                <span class="section-title">Moodboard</span>
                <span class="section-badge" id="moodboard-badge">0 images</span>
            </div>
            <div class="moodboard-grid" id="moodboard-grid"></div>
            <p class="section-hint">Upload reference images for style direction</p>
        </div>

        <!-- Output Configuration -->
        <div class="section" id="output-section">
            <div class="section-header">
                <span class="section-title">Output Configuration</span>
                <span class="section-badge" id="output-badge">6 images</span>
            </div>
            <div class="output-grid" id="output-grid"></div>
            <p class="section-hint" id="output-hint">Adjust people count per image using sliders</p>

            <!-- Caption Preview -->
            <div class="caption-preview">
                <div class="caption-preview-label">Caption for this post:</div>
                <div class="caption-preview-text" id="caption-preview">E-commerce. Created with Setset.</div>
            </div>
        </div>

        <!-- Moodboard Influence -->
        <div class="section" id="influence-section">
            <div class="section-header">
                <span class="section-title">Moodboard Influence</span>
                <span class="section-badge" id="influence-badge">50%</span>
            </div>
            <div class="influence-control">
                <input type="range" class="influence-slider" id="influence-slider" min="0" max="100" value="50">
                <div class="influence-labels">
                    <span>Loose inspiration</span>
                    <span>Follow exactly</span>
                </div>
            </div>
            <p class="section-hint" id="influence-hint">How closely should generated images follow the moodboard style, poses, and environments?</p>
        </div>

        <!-- Inline Loader -->
        <div class="inline-loader" id="inline-loader">
            <div class="loader-message" id="loader-message">Setting up the Studio...</div>
            <div class="loader-progress" id="loader-progress">Preparing...</div>
        </div>

        <!-- Generate -->
        <div class="generate-section">
            <div class="generate-info" id="generate-info">Select talent and upload moodboard to generate</div>
            <button class="btn btn--primary generate-btn" id="generate-btn" disabled>Generate Carousel</button>
        </div>

        <!-- Results -->
        <div class="results-section" id="results-section">
            <div class="section">
                <div class="section-header">
                    <span class="section-title">Generated Carousel</span>
                    <button class="btn btn--sm" id="download-all-btn">Download All</button>
                </div>
                <div class="results-grid" id="results-grid"></div>
            </div>
        </div>
    </div>

    <input type="file" id="moodboard-input" accept="image/*" multiple>

    <!-- Lightbox -->
    <div class="lightbox" id="lightbox">
        <button class="lightbox-close" id="lightbox-close">&times;</button>
        <button class="lightbox-nav lightbox-prev" id="lightbox-prev">&#8249;</button>
        <div class="lightbox-content">
            <img id="lightbox-img" src="" alt="Preview">
        </div>
        <button class="lightbox-nav lightbox-next" id="lightbox-next">&#8250;</button>
        <div class="lightbox-info">
            <span class="lightbox-counter" id="lightbox-counter">1 / 12</span>
            <button class="lightbox-download" id="lightbox-download">Download</button>
        </div>
    </div>

    <script src="/shared/js/utils.js"></script>
    <script src="/shared/js/api.js"></script>
    <script>
        // Talent roster - same as campaign-gen-v2
        const TALENT_ROSTER = [
            { id: 'james', name: 'James Wilson', image: '/shared/images/talent/talent-01_JamesWilson.png' },
            { id: 'maya', name: 'Maya Johnson', image: '/shared/images/talent/talent-02_MayaJohnson.png' },
            { id: 'river', name: 'River Blake', image: '/shared/images/talent/talent-03_RiverBlake.png' },
            { id: 'emma', name: 'Emma Sullivan', image: '/shared/images/talent/talent-04_EmmaSullivan.png' },
            { id: 'marcus', name: 'Marcus Brown', image: '/shared/images/talent/talent-05_MarcusBrown.png' },
            { id: 'zara', name: 'Zara Mitchell', image: '/shared/images/talent/talent-06_ZaraMitchell.png' },
            { id: 'sophia', name: 'Sophia Anderson', image: '/shared/images/talent/talent-07_SophiaAnderson.png' },
            { id: 'liam', name: 'Liam Garcia', image: '/shared/images/talent/talent-08_LiamGarcia.png' },
            { id: 'nina', name: 'Nina Davis', image: '/shared/images/talent/talent-09_NinaDavis.png' },
            { id: 'ava', name: 'Ava Martinez', image: '/shared/images/talent/talent-10_AvaMartinez.png' },
            { id: 'luna', name: 'Luna Park', image: '/shared/images/talent/talent-11_LunaPark.png' },
            { id: 'noah', name: 'Noah Chen', image: '/shared/images/talent/talent-12_NoahChen.png' },
            { id: 'kai', name: 'Kai Thompson', image: '/shared/images/talent/talent-13_KaiThompson.png' },
            { id: 'riley', name: 'Riley Morgan', image: '/shared/images/talent/talent-14_RileyMorgan.png' },
            { id: 'jordan', name: 'Jordan Lee', image: '/shared/images/talent/talent-15_JordanLee.png' },
            { id: 'isabella', name: 'Isabella Rodriguez', image: '/shared/images/talent/talent-16_IsabellaRodriguez.png' },
            { id: 'quinn', name: 'Quinn Santos', image: '/shared/images/talent/talent-17_QuinnSantos.png' },
            { id: 'casey', name: 'Casey White', image: '/shared/images/talent/talent-18_CaseyWhite.png' },
            { id: 'sam', name: 'Sam Wilson', image: '/shared/images/talent/talent-19_SamWilson.png' },
            { id: 'drew', name: 'Drew Martinez', image: '/shared/images/talent/talent-20_DrewMartinez.png' },
            { id: 'avery', name: 'Avery Taylor', image: '/shared/images/talent/talent-21_AveryTaylor.png' },
            { id: 'parker', name: 'Parker Miller', image: '/shared/images/talent/talent-22_ParkerMiller.png' },
            { id: 'morgan', name: 'Morgan Kim', image: '/shared/images/talent/talent-23_MorganKim.png' },
            { id: 'andre', name: 'Andre Jackson', image: '/shared/images/talent/talent-24_AndreJackson.png' },
            { id: 'damon', name: 'Damon Carter', image: '/shared/images/talent/talent-25_DamonCarter.png' },
            { id: 'nikolai', name: 'Nikolai Volkov', image: '/shared/images/talent/talent-26_NikolaiVolkov.png' },
            { id: 'sofia', name: 'Sofia Rodriguez', image: '/shared/images/talent/talent-27_SofiaRodriguez.png' },
            { id: 'finn', name: 'Finn O\'Connor', image: '/shared/images/talent/talent-28_FinnOConnor.png' },
            { id: 'clara', name: 'Clara Devereaux', image: '/shared/images/talent/talent-29_ClaraDevereaux.png' },
            { id: 'zoe', name: 'Simone Park', image: '/shared/images/talent/talent-30_ZoeWashington.png' }
        ];

        // E-commerce shot types - 12 varieties with varied lighting and backgrounds
        const ECOM_SHOT_TYPES = [
            // Clean white backgrounds (6)
            { type: 'white-flat', desc: 'White BG, soft light', prompt: 'Clean white cyclorama studio. Model standing naturally facing camera. Soft, diffused lighting from large softbox. Bright, airy e-commerce feel.' },
            { type: 'white-dramatic', desc: 'White BG, side light', prompt: 'Clean white studio background. Model in three-quarter pose. Dramatic side lighting creating subtle shadows that define the garment shape. High-end e-commerce.' },
            { type: 'white-backlit', desc: 'White BG, rim light', prompt: 'White studio with strong backlight creating a glowing rim around the model. Front fill light. Ethereal, premium e-commerce aesthetic.' },
            { type: 'white-hard', desc: 'White BG, hard light', prompt: 'Clean white background. Crisp, hard light creating sharp shadows. Model in confident pose. Bold, graphic e-commerce style.' },
            { type: 'white-overhead', desc: 'White BG, overhead', prompt: 'White studio with overhead beauty lighting. Soft shadows under chin and garment folds. Model looking at camera. Classic fashion e-commerce.' },
            { type: 'white-natural', desc: 'White BG, window light', prompt: 'Bright white studio with natural window light from the side. Soft, organic shadows. Model in relaxed stance. Effortless e-commerce feel.' },
            // Textured backgrounds (6)
            { type: 'concrete-floor', desc: 'Concrete floor', prompt: 'Minimal studio with polished concrete floor. Soft grey tones. Model standing naturally. Warm studio lighting from above. Modern e-commerce lookbook.' },
            { type: 'wood-floor', desc: 'Wood floor', prompt: 'Bright studio with light oak herringbone floor visible. White walls. Golden hour style warm lighting. Model in editorial pose. Elevated e-commerce.' },
            { type: 'grey-paper', desc: 'Grey seamless', prompt: 'Soft grey seamless paper backdrop. Cool-toned lighting with subtle gradient. Model in fashion pose. Sophisticated e-commerce aesthetic.' },
            { type: 'beige-linen', desc: 'Linen backdrop', prompt: 'Natural linen textured backdrop in warm beige. Soft, diffused daylight quality. Model relaxed. Organic, tactile e-commerce feel.' },
            { type: 'plaster-wall', desc: 'Plaster wall', prompt: 'Minimal space with raw plaster wall showing subtle texture. Warm directional light. Model against wall. Architectural e-commerce lookbook.' },
            { type: 'terrazzo', desc: 'Terrazzo floor', prompt: 'Modern studio with terrazzo floor pattern visible. Bright, even lighting. Model standing confidently. Contemporary premium e-commerce.' }
        ];

        // Campaign shot types - 12 editorial varieties
        const CAMPAIGN_SHOT_TYPES = [
            { type: 'wide-env', desc: 'Wide environmental', prompt: 'Wide environmental shot showing model in full scene context. Cinematic framing, editorial atmosphere.' },
            { type: 'medium-story', desc: 'Medium narrative', prompt: 'Medium shot with storytelling element. Model engaged in scene, natural moment captured.' },
            { type: 'close-portrait', desc: 'Close-up portrait', prompt: 'Intimate close-up portrait capturing expression and mood. Shallow depth of field, cinematic lighting.' },
            { type: 'three-quarter', desc: '3/4 composition', prompt: 'Three-quarter body composition, balanced framing. Model positioned off-center, editorial feel.' },
            { type: 'dramatic-angle', desc: 'Dramatic angle', prompt: 'Shot from unusual angle - low, high, or tilted perspective. Creates visual impact and drama.' },
            { type: 'silhouette', desc: 'Silhouette/backlit', prompt: 'Backlit or silhouette shot with dramatic rim lighting. Artistic, moody atmosphere.' },
            { type: 'action-moment', desc: 'Action moment', prompt: 'Model in motion or action - walking, running, gesturing. Dynamic energy, captured moment.' },
            { type: 'reflection', desc: 'Reflection shot', prompt: 'Using mirrors, water, or glass for reflection element. Artistic double composition.' },
            { type: 'architectural', desc: 'Architectural frame', prompt: 'Model framed by architectural elements - doorways, windows, columns. Structured composition.' },
            { type: 'natural-light', desc: 'Natural light', prompt: 'Using beautiful natural light - golden hour, window light, soft diffused sun. Organic feel.' },
            { type: 'texture-focus', desc: 'Texture contrast', prompt: 'Emphasizing texture contrast between clothing and environment. Rich visual details.' },
            { type: 'editorial-crop', desc: 'Editorial crop', prompt: 'Unusual editorial cropping - cut at unexpected points. Fashion magazine style framing.' }
        ];

        // Casting shot types - 12 agency card varieties
        const CASTING_SHOT_TYPES = [
            { type: 'headshot-front', desc: 'Headshot front', prompt: 'Close-up headshot portrait, clean background. Natural expression, soft lighting. Agency digitals style.' },
            { type: 'headshot-34', desc: 'Headshot 3/4', prompt: 'Headshot from three-quarter angle. Natural expression, clean background. Agency casting style.' },
            { type: 'headshot-profile', desc: 'Headshot profile', prompt: 'Profile headshot showing bone structure. Clean studio background. Classic agency digitals.' },
            { type: 'body-front', desc: 'Full body front', prompt: 'Full body shot, model facing camera directly. Simple standing pose, clean studio background. Agency card style.' },
            { type: 'body-34', desc: 'Full body 3/4', prompt: 'Full body three-quarter view. Relaxed stance, natural posture. Clean studio background.' },
            { type: 'body-back', desc: 'Full body back', prompt: 'Full body shot from behind. Natural stance. Clean studio background for agency card.' },
            { type: 'body-side', desc: 'Full body profile', prompt: 'Full body profile view from the side. Clean studio background. Classic agency digitals.' },
            { type: 'waist-up', desc: 'Waist-up shot', prompt: 'Cropped at waist showing upper body proportions. Natural pose, clean background.' },
            { type: 'styled-casual', desc: 'Styled casual', prompt: 'Model in casual styling, relaxed pose. Shows personality and range. Clean background.' },
            { type: 'styled-elevated', desc: 'Styled editorial', prompt: 'Model in elevated styling with editorial pose. Shows versatility. Minimal studio setting.' },
            { type: 'natural-light', desc: 'Natural light test', prompt: 'Model in natural daylight. Outdoor or near window. Shows how model photographs in various light.' },
            { type: 'expressive', desc: 'Expressive moment', prompt: 'Capturing genuine expression - smile, laugh, or candid moment. Shows personality and range.' }
        ];

        // State
        const state = {
            mode: 'ecommerce', // ecommerce, campaign, casting
            selectedTalent: [], // array of talent IDs
            primaryTalent: null, // for casting mode - the main model
            moodboardImages: [], // array of { url, file }
            outputConfig: [], // array of { peopleCount }
            moodboardInfluence: 50, // 0-100, how closely to follow moodboard
            moodboardAnalysis: null, // { styleDNA, environments }
            results: []
        };

        // DOM Elements
        const elements = {
            modeTabs: document.querySelectorAll('.mode-tab'),
            talentGrid: document.getElementById('talent-grid'),
            talentBadge: document.getElementById('talent-badge'),
            talentHint: document.getElementById('talent-hint'),
            talentSection: document.getElementById('talent-section'),
            randomTalentBtn: document.getElementById('random-talent-btn'),
            moodboardGrid: document.getElementById('moodboard-grid'),
            moodboardBadge: document.getElementById('moodboard-badge'),
            moodboardInput: document.getElementById('moodboard-input'),
            moodboardSection: document.getElementById('moodboard-section'),
            outputGrid: document.getElementById('output-grid'),
            outputBadge: document.getElementById('output-badge'),
            outputHint: document.getElementById('output-hint'),
            captionPreview: document.getElementById('caption-preview'),
            generateInfo: document.getElementById('generate-info'),
            generateBtn: document.getElementById('generate-btn'),
            resultsSection: document.getElementById('results-section'),
            resultsGrid: document.getElementById('results-grid'),
            downloadAllBtn: document.getElementById('download-all-btn'),
            influenceSlider: document.getElementById('influence-slider'),
            influenceBadge: document.getElementById('influence-badge'),
            influenceHint: document.getElementById('influence-hint'),
            // Loader elements
            inlineLoader: document.getElementById('inline-loader'),
            loaderMessage: document.getElementById('loader-message'),
            loaderProgress: document.getElementById('loader-progress'),
            // Lightbox elements
            lightbox: document.getElementById('lightbox'),
            lightboxImg: document.getElementById('lightbox-img'),
            lightboxClose: document.getElementById('lightbox-close'),
            lightboxPrev: document.getElementById('lightbox-prev'),
            lightboxNext: document.getElementById('lightbox-next'),
            lightboxCounter: document.getElementById('lightbox-counter'),
            lightboxDownload: document.getElementById('lightbox-download')
        };

        // Lightbox state
        const lightboxState = {
            currentIndex: 0,
            images: [] // Will be populated from state.results
        };

        // Studio messages for the loader
        const STUDIO_MESSAGES = [
            "Setting up the Studio...",
            "Adjusting the Key Light...",
            "Loading the Film...",
            "Warming up the Strobes...",
            "Preparing the Backdrop...",
            "Adjusting the Fill Light...",
            "Checking the Framing...",
            "Setting the Aperture...",
            "Loading Color Profiles...",
            "Positioning the C-Stand...",
            "Focusing...",
            "Checking Tethering...",
            "Rolling...",
            "Adjusting the Umbrella...",
            "Metering...",
            "Standby...",
            "Loading the Presets...",
            "Quiet on Set...",
            "Final Touches...",
            "Almost There..."
        ];
        let loadingInterval = null;
        let lastMessageIndex = -1;

        // Lightbox functions
        function openLightbox(index) {
            // Build images array from results
            lightboxState.images = Object.entries(state.results)
                .filter(([_, url]) => url)
                .map(([idx, url]) => ({ index: parseInt(idx), url }));

            if (lightboxState.images.length === 0) return;

            // Find the position of this index in our filtered images
            const position = lightboxState.images.findIndex(img => img.index === index);
            if (position === -1) return;

            lightboxState.currentIndex = position;
            updateLightboxDisplay();
            elements.lightbox.classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        function closeLightbox() {
            elements.lightbox.classList.remove('active');
            document.body.style.overflow = '';
        }

        function navigateLightbox(direction) {
            const total = lightboxState.images.length;
            if (total === 0) return;

            lightboxState.currentIndex = (lightboxState.currentIndex + direction + total) % total;
            updateLightboxDisplay();
        }

        function updateLightboxDisplay() {
            const current = lightboxState.images[lightboxState.currentIndex];
            if (!current) return;

            elements.lightboxImg.src = current.url;
            elements.lightboxCounter.textContent = `${lightboxState.currentIndex + 1} / ${lightboxState.images.length}`;
        }

        function downloadCurrentLightboxImage() {
            const current = lightboxState.images[lightboxState.currentIndex];
            if (current) {
                downloadImage(current.url, current.index);
            }
        }

        // Loading animation functions
        function startLoadingAnimation(progressText = 'Preparing...') {
            elements.inlineLoader.classList.add('visible');
            elements.loaderProgress.textContent = progressText;

            // Set initial message
            const initialIdx = Math.floor(Math.random() * STUDIO_MESSAGES.length);
            elements.loaderMessage.textContent = STUDIO_MESSAGES[initialIdx];
            lastMessageIndex = initialIdx;

            // Rotate messages every 2 seconds with fade effect
            loadingInterval = setInterval(() => {
                let idx;
                do {
                    idx = Math.floor(Math.random() * STUDIO_MESSAGES.length);
                } while (idx === lastMessageIndex && STUDIO_MESSAGES.length > 1);
                lastMessageIndex = idx;

                elements.loaderMessage.classList.add('fade-out');
                elements.loaderMessage.classList.remove('fade-in');

                setTimeout(() => {
                    elements.loaderMessage.textContent = STUDIO_MESSAGES[idx];
                    elements.loaderMessage.classList.remove('fade-out');
                    elements.loaderMessage.classList.add('fade-in');
                }, 250);
            }, 2000);
        }

        function updateLoadingProgress(text) {
            elements.loaderProgress.textContent = text;
        }

        function stopLoadingAnimation() {
            if (loadingInterval) {
                clearInterval(loadingInterval);
                loadingInterval = null;
            }
            elements.inlineLoader.classList.remove('visible');
        }

        function setupLightboxListeners() {
            // Close button
            elements.lightboxClose.addEventListener('click', closeLightbox);

            // Navigation buttons
            elements.lightboxPrev.addEventListener('click', () => navigateLightbox(-1));
            elements.lightboxNext.addEventListener('click', () => navigateLightbox(1));

            // Download button
            elements.lightboxDownload.addEventListener('click', downloadCurrentLightboxImage);

            // Click on backdrop to close
            elements.lightbox.addEventListener('click', (e) => {
                if (e.target === elements.lightbox) {
                    closeLightbox();
                }
            });

            // Keyboard navigation
            document.addEventListener('keydown', (e) => {
                if (!elements.lightbox.classList.contains('active')) return;

                switch (e.key) {
                    case 'Escape':
                        closeLightbox();
                        break;
                    case 'ArrowLeft':
                        navigateLightbox(-1);
                        break;
                    case 'ArrowRight':
                        navigateLightbox(1);
                        break;
                }
            });
        }

        // Initialize
        function init() {
            initOutputConfig();
            renderTalentGrid();
            renderMoodboardGrid();
            renderOutputGrid();
            setupEventListeners();
            setupLightboxListeners();
            updateUI();
        }

        function initOutputConfig() {
            // All slots disabled by default - user clicks to enable
            state.outputConfig = Array(12).fill(null).map(() => ({ peopleCount: 1, enabled: false }));
        }

        function setupEventListeners() {
            // Mode tabs
            elements.modeTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    elements.modeTabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    state.mode = tab.dataset.mode;
                    state.selectedTalent = [];
                    state.primaryTalent = null;
                    renderTalentGrid();
                    renderOutputGrid();
                    updateUI();
                });
            });

            // Moodboard file input
            elements.moodboardInput.addEventListener('change', handleMoodboardUpload);

            // Moodboard drag and drop
            const moodboardSection = elements.moodboardSection;
            moodboardSection.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                moodboardSection.style.background = 'var(--off-white)';
            });
            moodboardSection.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                moodboardSection.style.background = '';
            });
            moodboardSection.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                moodboardSection.style.background = '';

                const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
                files.forEach(file => {
                    if (state.moodboardImages.length < 24) {
                        const reader = new FileReader();
                        reader.onload = (ev) => {
                            state.moodboardImages.push({ url: ev.target.result, file });
                            state.moodboardAnalysis = null;
                            renderMoodboardGrid();
                            updateUI();
                        };
                        reader.readAsDataURL(file);
                    }
                });
            });

            // Random talent button
            elements.randomTalentBtn.addEventListener('click', () => {
                // Shuffle and pick 5 random talent
                const shuffled = shuffleArray([...TALENT_ROSTER]);
                const randomPicks = shuffled.slice(0, 5).map(t => t.id);

                state.selectedTalent = randomPicks;
                state.primaryTalent = state.mode === 'casting' ? randomPicks[0] : null;

                renderTalentGrid();
                updateUI();
            });

            // Generate button
            elements.generateBtn.addEventListener('click', handleGenerate);

            // Download all
            elements.downloadAllBtn.addEventListener('click', downloadAllResults);

            // Influence slider
            elements.influenceSlider.addEventListener('input', (e) => {
                state.moodboardInfluence = parseInt(e.target.value);
                state.moodboardAnalysis = null; // Reset analysis when influence changes
                elements.influenceBadge.textContent = `${state.moodboardInfluence}%`;
                updateInfluenceHint();
            });
        }

        function updateInfluenceHint() {
            const inf = state.moodboardInfluence;
            if (inf <= 20) {
                elements.influenceHint.textContent = 'Very loose - AI will invent fresh ideas with minimal moodboard reference';
            } else if (inf <= 40) {
                elements.influenceHint.textContent = 'Loose - General vibes from moodboard, but varied execution';
            } else if (inf <= 60) {
                elements.influenceHint.textContent = 'Balanced - Follow moodboard aesthetic with some creative variety';
            } else if (inf <= 80) {
                elements.influenceHint.textContent = 'Close - Closely match moodboard style, poses, and environments';
            } else {
                elements.influenceHint.textContent = 'Exact - Recreate moodboard look as precisely as possible';
            }
        }

        function renderTalentGrid() {
            const maxSelection = 8; // Same for all modes now

            elements.talentGrid.innerHTML = TALENT_ROSTER.map(talent => {
                const isSelected = state.selectedTalent.includes(talent.id);
                const isPrimary = state.primaryTalent === talent.id;
                const isDisabled = !isSelected && state.selectedTalent.length >= maxSelection;

                return `
                    <div class="talent-card ${isSelected ? 'selected' : ''} ${isPrimary ? 'primary' : ''} ${isDisabled ? 'disabled' : ''}"
                         data-id="${talent.id}">
                        <img src="${talent.image}" alt="${talent.name}" onerror="this.src='https://placehold.co/300x400/f0f0f0/999?text=${talent.name.split(' ')[0]}'">
                        <div class="talent-name">${talent.name}</div>
                    </div>
                `;
            }).join('');

            // Click handlers
            elements.talentGrid.querySelectorAll('.talent-card').forEach(card => {
                card.addEventListener('click', () => {
                    if (card.classList.contains('disabled')) return;

                    const talentId = card.dataset.id;

                    if (state.mode === 'casting') {
                        // Casting mode: first selected becomes primary (star), others are supporting
                        if (state.primaryTalent === talentId) {
                            // Clicking the primary - deselect and promote next if available
                            state.selectedTalent = state.selectedTalent.filter(id => id !== talentId);
                            const others = state.selectedTalent;
                            if (others.length > 0) {
                                state.primaryTalent = others[0];
                            } else {
                                state.primaryTalent = null;
                            }
                        } else if (state.selectedTalent.includes(talentId)) {
                            // Already selected but not primary - remove from selection
                            state.selectedTalent = state.selectedTalent.filter(id => id !== talentId);
                        } else if (state.selectedTalent.length < maxSelection) {
                            // New selection - add to selected
                            state.selectedTalent.push(talentId);
                            // If no primary yet, this becomes primary (first selection)
                            if (!state.primaryTalent) {
                                state.primaryTalent = talentId;
                            }
                        }
                    } else {
                        // E-commerce / Campaign mode: simple multi-select
                        if (state.selectedTalent.includes(talentId)) {
                            state.selectedTalent = state.selectedTalent.filter(id => id !== talentId);
                        } else if (state.selectedTalent.length < maxSelection) {
                            state.selectedTalent.push(talentId);
                        }
                    }

                    renderTalentGrid();
                    updateUI();
                });
            });
        }

        function renderMoodboardGrid() {
            const slots = 24;
            elements.moodboardGrid.innerHTML = Array(slots).fill(null).map((_, i) => {
                const image = state.moodboardImages[i];
                if (image) {
                    return `
                        <div class="upload-slot filled" data-index="${i}">
                            <img src="${image.url}" alt="Moodboard ${i + 1}">
                            <button class="remove-btn">&times;</button>
                        </div>
                    `;
                }
                return `
                    <div class="upload-slot" data-index="${i}">
                        <span class="plus">+</span>
                    </div>
                `;
            }).join('');

            // Click handlers
            elements.moodboardGrid.querySelectorAll('.upload-slot').forEach(slot => {
                slot.addEventListener('click', (e) => {
                    if (e.target.classList.contains('remove-btn')) {
                        const index = parseInt(slot.dataset.index);
                        state.moodboardImages.splice(index, 1);
                        state.moodboardAnalysis = null;
                        renderMoodboardGrid();
                        updateUI();
                    } else if (!slot.classList.contains('filled')) {
                        elements.moodboardInput.click();
                    }
                });
            });
        }

        function handleMoodboardUpload(e) {
            const files = Array.from(e.target.files);
            files.forEach(file => {
                if (state.moodboardImages.length < 24) {
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        state.moodboardImages.push({ url: ev.target.result, file });
                        state.moodboardAnalysis = null;
                        renderMoodboardGrid();
                        updateUI();
                    };
                    reader.readAsDataURL(file);
                }
            });
            e.target.value = '';
        }

        function renderOutputGrid() {
            // Get shot types based on mode
            let shotTypes;
            if (state.mode === 'ecommerce') {
                shotTypes = ECOM_SHOT_TYPES;
            } else if (state.mode === 'campaign') {
                shotTypes = CAMPAIGN_SHOT_TYPES;
            } else {
                shotTypes = CASTING_SHOT_TYPES;
            }

            elements.outputGrid.innerHTML = state.outputConfig.map((config, i) => {
                const shotType = shotTypes[i % shotTypes.length];
                const isActive = config.enabled;

                return `
                    <div class="output-slot-wrapper">
                        <div class="output-slot ${isActive ? 'active' : ''}" data-index="${i}">
                            <div class="slot-number">${i + 1}</div>
                            <div class="slot-type">${shotType.desc}</div>
                            ${isActive ? `<div class="people-count">${config.peopleCount} ${config.peopleCount === 1 ? 'person' : 'people'}</div>` : ''}
                        </div>
                        ${isActive ? `<input type="range" class="output-slider" data-index="${i}" min="1" max="3" value="${config.peopleCount}">` : ''}
                    </div>
                `;
            }).join('');

            // Slot click to toggle enabled
            elements.outputGrid.querySelectorAll('.output-slot').forEach(slot => {
                slot.addEventListener('click', (e) => {
                    // Don't toggle if clicking on slider
                    if (e.target.classList.contains('output-slider')) return;
                    const index = parseInt(slot.dataset.index);
                    state.outputConfig[index].enabled = !state.outputConfig[index].enabled;
                    renderOutputGrid();
                    updateUI();
                });
            });

            // Slider handlers
            elements.outputGrid.querySelectorAll('.output-slider').forEach(slider => {
                slider.addEventListener('input', (e) => {
                    e.stopPropagation();
                    const index = parseInt(e.target.dataset.index);
                    state.outputConfig[index].peopleCount = parseInt(e.target.value);
                    renderOutputGrid();
                });
            });
        }

        function updateUI() {
            // Update talent badge - 8 max for all modes now
            elements.talentBadge.textContent = `${state.selectedTalent.length}/8 selected`;

            // Update talent hint
            if (state.mode === 'casting') {
                const primaryName = state.primaryTalent
                    ? TALENT_ROSTER.find(t => t.id === state.primaryTalent)?.name
                    : null;
                elements.talentHint.textContent = primaryName
                    ? `Primary: ${primaryName} (â˜… appears in all images). Add more talent for variety.`
                    : 'First selection becomes the primary talent (â˜…). Add more for multi-person shots.';
            } else {
                elements.talentHint.textContent = 'Select up to 8 models. They will be randomly assigned to images.';
            }

            // Update moodboard badge
            elements.moodboardBadge.textContent = `${state.moodboardImages.length} images`;

            // Update output badge to show enabled count
            const enabledCount = state.outputConfig.filter(c => c.enabled).length;
            elements.outputBadge.textContent = `${enabledCount} images`;

            // Update output hint
            if (state.mode === 'casting') {
                elements.outputHint.textContent = 'Agency digitals. Primary talent (â˜…) appears in every image, others randomly added based on people count.';
            } else if (state.mode === 'ecommerce') {
                elements.outputHint.textContent = 'Mix of white backgrounds and minimal editorial settings';
            } else {
                elements.outputHint.textContent = 'Editorial world-building based on moodboard direction';
            }

            // Update caption preview
            if (state.mode === 'ecommerce') {
                elements.captionPreview.textContent = 'E-commerce. Created with Setset.';
            } else if (state.mode === 'campaign') {
                elements.captionPreview.textContent = 'Imaginary campaign created with Setset.';
            } else {
                const talent = TALENT_ROSTER.find(t => t.id === state.primaryTalent);
                elements.captionPreview.textContent = talent
                    ? `${talent.name} for Setset.`
                    : 'Select a model to see caption';
            }

            // Update generate button
            const hasTalent = state.selectedTalent.length > 0;
            const hasMoodboard = state.moodboardImages.length > 0 || state.mode === 'casting';
            elements.generateBtn.disabled = !hasTalent || (!hasMoodboard && state.mode !== 'casting');

            // Update generate info
            if (!hasTalent) {
                elements.generateInfo.textContent = 'Select at least one model';
            } else if (!hasMoodboard && state.mode !== 'casting') {
                elements.generateInfo.textContent = 'Upload moodboard images for style direction';
            } else {
                const modeLabel = state.mode === 'ecommerce' ? 'E-commerce' :
                                  state.mode === 'campaign' ? 'Campaign' : 'Casting';
                elements.generateInfo.textContent = `Ready to generate ${modeLabel} carousel (12 images)`;
            }
        }

        async function handleGenerate() {
            elements.generateBtn.disabled = true;
            elements.resultsSection.classList.add('visible');
            state.results = [];

            // Show loading placeholders only for enabled outputs
            const enabledIndices = state.outputConfig
                .map((config, i) => config.enabled ? i : null)
                .filter(i => i !== null);

            elements.resultsGrid.innerHTML = enabledIndices.map(i => `
                <div class="result-card generating" id="result-${i}">
                    <div class="spinner"></div>
                </div>
            `).join('');

            // Start the studio loading animation
            startLoadingAnimation('Preparing your shoot...');
            let completedCount = 0;
            const totalImages = enabledIndices.length;

            try {
                // Analyze moodboard if we have images and haven't already
                if (state.moodboardImages.length > 0 && !state.moodboardAnalysis) {
                    updateLoadingProgress('Analyzing moodboard...');

                    // Upload moodboard images
                    const uploadedUrls = await Promise.all(
                        state.moodboardImages.slice(0, 10).map(img => api.uploadBase64(img.url).then(r => r.url))
                    );

                    // Build analysis prompt based on influence level
                    const influenceLevel = state.moodboardInfluence;
                    let analysisPrompt = '';

                    if (state.mode === 'ecommerce') {
                        analysisPrompt = `Analyze these fashion images to extract:

1. STYLE DNA (for consistent outfit vibes):
- Clothing aesthetic and style direction (e.g., minimalist, streetwear, bohemian)
- Color palette and tones
- Fabric textures and materials feel
- Overall mood and attitude

2. Do NOT describe specific backgrounds - e-commerce uses clean studio settings.

Respond in this JSON format:
{
  "styleDNA": "description of clothing style, colors, textures, mood - be evocative but never mention brand names",
  "clothingVibe": "2-3 word summary like 'relaxed minimalism' or 'elevated streetwear'"
}`;
                    } else if (state.mode === 'campaign') {
                        analysisPrompt = `Analyze these fashion campaign images to extract:

1. STYLE DNA (consistent across all images):
- Overall aesthetic and mood
- Color grading and tones
- Lighting style (natural, dramatic, soft, etc.)
- Clothing style and vibe
- Emotional tone and attitude

2. ENVIRONMENT PALETTE (8 DIFFERENT but cohesive location ideas):
Based on the vibe of these images, suggest 8 varied environments that would feel cohesive but NOT repetitive. Each should be distinctly different while maintaining the overall aesthetic.

Influence level: ${influenceLevel}%
${influenceLevel < 30 ? 'Be very creative - invent fresh environments loosely inspired by the mood' :
  influenceLevel < 60 ? 'Balance between moodboard references and creative variety' :
  'Stay close to the environments and settings shown in the moodboard'}

Respond in this JSON format:
{
  "styleDNA": "description of overall aesthetic, lighting, colors, clothing vibe - be evocative but never use brand names",
  "environments": [
    "environment 1 - specific location with atmosphere details",
    "environment 2 - different location type",
    "environment 3 - another varied setting",
    "environment 4 - distinct environment",
    "environment 5 - different atmosphere",
    "environment 6 - varied location",
    "environment 7 - another setting",
    "environment 8 - final varied environment"
  ]
}`;
                    } else {
                        // Casting mode
                        analysisPrompt = `Analyze these casting/agency card style images to extract:

1. PHOTO STYLE (for consistent casting card aesthetic):
- Lighting approach (natural, studio, mixed)
- Color grading and tones
- Overall mood (editorial, natural, polished, raw)
- Posing style and energy

2. VARIED SETTINGS (8 different but cohesive backdrop ideas):
Casting cards need variety but coherent feel. Suggest 8 different settings.

Respond in this JSON format:
{
  "styleDNA": "description of lighting, grading, mood, energy for casting photos",
  "environments": [
    "setting 1",
    "setting 2",
    "setting 3",
    "setting 4",
    "setting 5",
    "setting 6",
    "setting 7",
    "setting 8"
  ]
}`;
                    }

                    // Analyze
                    const analysisResult = await api.analyzeImages(uploadedUrls, analysisPrompt);

                    // Parse JSON response
                    try {
                        const jsonMatch = analysisResult.content.match(/\{[\s\S]*\}/);
                        if (jsonMatch) {
                            state.moodboardAnalysis = JSON.parse(jsonMatch[0]);
                        } else {
                            // Fallback if no JSON
                            state.moodboardAnalysis = {
                                styleDNA: analysisResult.content.substring(0, 500),
                                environments: []
                            };
                        }
                    } catch (e) {
                        console.error('Failed to parse analysis JSON:', e);
                        state.moodboardAnalysis = {
                            styleDNA: analysisResult.content.substring(0, 500),
                            environments: []
                        };
                    }

                    console.log('Moodboard analysis:', state.moodboardAnalysis);
                }

                // Get selected talent info
                const selectedTalentInfo = state.selectedTalent.map(id => TALENT_ROSTER.find(t => t.id === id));

                // Upload talent images to get hosted URLs
                updateLoadingProgress('Uploading talent images...');
                const talentWithUrls = await Promise.all(
                    selectedTalentInfo.map(async (talent) => {
                        try {
                            // Fetch the local talent image and upload it
                            const response = await fetch(talent.image);
                            const blob = await response.blob();
                            const file = new File([blob], `${talent.id}.png`, { type: blob.type });
                            const uploadResult = await api.uploadImage(file);
                            return { ...talent, uploadedUrl: uploadResult.url };
                        } catch (e) {
                            console.error(`Failed to upload talent image for ${talent.name}:`, e);
                            return { ...talent, uploadedUrl: null };
                        }
                    })
                );

                // Get only enabled outputs
                const enabledOutputs = state.outputConfig
                    .map((config, index) => ({ config, index }))
                    .filter(item => item.config.enabled);

                // Generate images in parallel for enabled outputs only
                updateLoadingProgress(`Generating ${enabledOutputs.length} images...`);

                const generatePromises = enabledOutputs.map(async ({ config, index }) => {
                    try {
                        // Pick talent for this image based on mode
                        let talentForImage;
                        if (state.mode === 'casting') {
                            // Casting: primary talent always included, random others added
                            const primaryTalentData = talentWithUrls.find(t => t.id === state.primaryTalent);
                            const otherTalent = talentWithUrls.filter(t => t.id !== state.primaryTalent);

                            // Start with primary
                            talentForImage = primaryTalentData ? [primaryTalentData] : [];

                            // Add random others up to peopleCount
                            if (config.peopleCount > 1 && otherTalent.length > 0) {
                                const additionalNeeded = Math.min(config.peopleCount - 1, otherTalent.length);
                                const randomOthers = shuffleArray([...otherTalent]).slice(0, additionalNeeded);
                                talentForImage = [...talentForImage, ...randomOthers];
                            }
                        } else {
                            // E-commerce / Campaign: random talent selection
                            talentForImage = shuffleArray([...talentWithUrls]).slice(0, config.peopleCount);
                        }

                        const prompt = buildPrompt(index, config, talentForImage);

                        // Get all talent image URLs for this shot
                        const talentImageUrls = talentForImage
                            .map(t => t.uploadedUrl)
                            .filter(Boolean);

                        // Use nano-banana-pro/edit with all talent images as references
                        const result = await api.remixImage('nano-pro', {
                            prompt: prompt,
                            image_urls: talentImageUrls,
                            num_images: 1,
                            aspect_ratio: '3:4',
                            resolution: '1K'
                        });

                        const imageUrl = result.images?.[0]?.url;
                        if (imageUrl) {
                            updateResultCard(index, imageUrl);
                            state.results[index] = imageUrl;
                            completedCount++;
                            updateLoadingProgress(`${completedCount} of ${totalImages} complete`);
                        }
                    } catch (error) {
                        console.error(`Failed to generate image ${index}:`, error);
                        markResultError(index, error.message);
                        completedCount++;
                        updateLoadingProgress(`${completedCount} of ${totalImages} complete`);
                    }
                });

                await Promise.all(generatePromises);
                stopLoadingAnimation();
                elements.generateInfo.textContent = 'Carousel complete!';

            } catch (error) {
                console.error('Generate error:', error);
                stopLoadingAnimation();
                elements.generateInfo.textContent = 'Error: ' + error.message;
            } finally {
                elements.generateBtn.disabled = false;
            }
        }

        // Variety options for more diverse outputs
        const LIGHTING_VARIETY = [
            'soft natural window light',
            'dramatic side lighting',
            'bright even studio light',
            'warm golden hour glow',
            'cool diffused overcast',
            'contrasty hard light',
            'backlit rim lighting',
            'soft overhead lighting',
            'moody low-key lighting',
            'bright high-key lighting',
            'mixed natural and artificial',
            'dappled light through leaves'
        ];

        const OUTFIT_MODIFIERS = [
            'effortlessly styled',
            'minimally accessorized',
            'layered casually',
            'sharply tailored',
            'relaxed oversized fit',
            'sleek fitted silhouette',
            'textured fabrics',
            'monochromatic tones',
            'subtle pattern mixing',
            'structured shapes',
            'flowing relaxed drape',
            'contemporary edge'
        ];

        function buildPrompt(index, config, talentForImage) {
            // Get shot types based on mode
            let shotTypes;
            if (state.mode === 'ecommerce') {
                shotTypes = ECOM_SHOT_TYPES;
            } else if (state.mode === 'campaign') {
                shotTypes = CAMPAIGN_SHOT_TYPES;
            } else {
                shotTypes = CASTING_SHOT_TYPES;
            }
            const shotType = shotTypes[index % shotTypes.length];

            let prompt = '';
            const peopleCount = talentForImage.length;
            const peopleText = peopleCount === 1 ? 'A model' : `${peopleCount} models`;
            const analysis = state.moodboardAnalysis || {};
            const influence = state.moodboardInfluence;

            // Helper to safely get styleDNA as string
            const getStyleDNA = () => {
                if (!analysis.styleDNA) return '';
                if (typeof analysis.styleDNA === 'string') return analysis.styleDNA;
                if (typeof analysis.styleDNA === 'object') return JSON.stringify(analysis.styleDNA);
                return String(analysis.styleDNA);
            };
            const styleDNA = getStyleDNA();

            // Add variety modifiers
            const lightingVariety = LIGHTING_VARIETY[index % LIGHTING_VARIETY.length];
            const outfitModifier = OUTFIT_MODIFIERS[index % OUTFIT_MODIFIERS.length];

            if (state.mode === 'ecommerce') {
                // E-commerce: consistent outfit vibes, clean backgrounds, but varied lighting
                prompt = `${peopleText} in fashion e-commerce photography. ${shotType.prompt}`;

                // Add outfit variety
                prompt += ` Clothing styled ${outfitModifier}.`;

                if (styleDNA) {
                    // Apply clothing style based on influence
                    if (influence >= 30) {
                        prompt += ` Aesthetic: ${styleDNA.substring(0, 150)}`;
                    }
                    if (analysis.clothingVibe) {
                        prompt += ` Vibe: ${analysis.clothingVibe}.`;
                    }
                }

                // Vary the studio lighting for e-commerce too
                const ecomLighting = ['bright even studio light', 'soft diffused light', 'clean white lighting'][index % 3];
                prompt += ` ${ecomLighting}. High-end fashion e-commerce, clean and professional.`;

            } else if (state.mode === 'campaign') {
                // Campaign: style DNA + varied environments + varied lighting
                prompt = `${peopleText} in an editorial fashion campaign. ${shotType.prompt} `;

                // Add variety
                prompt += `Lighting: ${lightingVariety}. Outfit: ${outfitModifier}. `;

                // Apply style DNA
                if (styleDNA && influence >= 20) {
                    prompt += `Style direction: ${styleDNA.substring(0, 200)} `;
                }

                // Apply varied environment from palette
                if (analysis.environments && analysis.environments.length > 0) {
                    const envIndex = index % analysis.environments.length;
                    const environment = analysis.environments[envIndex];
                    prompt += `Location: ${environment}. `;
                }

                // Add influence-based guidance
                if (influence < 30) {
                    prompt += 'Interpret creatively with fresh perspective. ';
                } else if (influence >= 70) {
                    prompt += 'Stay true to the reference aesthetic. ';
                }

                prompt += 'High-end editorial fashion photography, cinematic, premium aesthetic.';

            } else {
                // Casting: agency digitals with varied settings and lighting
                const primaryTalent = TALENT_ROSTER.find(t => t.id === state.primaryTalent);
                const primaryName = primaryTalent ? primaryTalent.name : 'Model';

                if (peopleCount === 1) {
                    prompt = `Fashion model portrait of ${primaryName}. ${shotType.prompt} `;
                } else {
                    prompt = `Fashion models with ${primaryName} as the focus. ${shotType.prompt} `;
                }

                // Add variety for casting
                prompt += `Lighting: ${lightingVariety}. `;

                // Apply casting style
                if (styleDNA && influence >= 20) {
                    prompt += `Photo style: ${styleDNA.substring(0, 120)} `;
                }

                // Apply varied setting
                if (analysis.environments && analysis.environments.length > 0) {
                    const envIndex = index % analysis.environments.length;
                    prompt += `Setting: ${analysis.environments[envIndex]}. `;
                }

                prompt += 'Professional agency digitals. Natural beauty, authentic expression.';
            }

            return prompt;
        }

        function updateResultCard(index, imageUrl) {
            const card = document.getElementById(`result-${index}`);
            if (card) {
                card.classList.remove('generating');
                card.innerHTML = `
                    <img src="${imageUrl}" alt="Generated ${index + 1}">
                    <button class="download-btn">Download</button>
                `;
                card.style.cursor = 'pointer';

                // Click on image opens lightbox
                const img = card.querySelector('img');
                img.addEventListener('click', () => openLightbox(index));

                // Download button
                const downloadBtn = card.querySelector('.download-btn');
                downloadBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    downloadImage(imageUrl, index);
                });
            }
        }

        function markResultError(index, message) {
            const card = document.getElementById(`result-${index}`);
            if (card) {
                card.classList.remove('generating');
                card.innerHTML = `<div style="padding: 10px; font-size: 10px; color: #dc2626; text-align: center;">Failed</div>`;
            }
        }

        function downloadImage(url, index) {
            const now = new Date();
            const timestamp = `${now.getFullYear()}${String(now.getMonth()+1).padStart(2,'0')}${String(now.getDate()).padStart(2,'0')}`;
            const modeLabel = state.mode.charAt(0).toUpperCase() + state.mode.slice(1);
            downloadFile(url, `Setset_${modeLabel}_${timestamp}_${index + 1}.jpg`);
        }

        function downloadAllResults() {
            state.results.forEach((url, index) => {
                if (url) {
                    setTimeout(() => downloadImage(url, index), index * 500);
                }
            });
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Initialize
        init();
    </script>
</body>
</html>
