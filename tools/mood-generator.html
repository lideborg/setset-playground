<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mood Generator</title>
    <link rel="stylesheet" href="/shared/css/tokens.css">
    <link rel="stylesheet" href="/shared/css/base.css">
    <link rel="stylesheet" href="/shared/css/components.css">
    <style>
        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: var(--space-lg);
        }

        header {
            margin-bottom: var(--space-lg);
        }

        header h1 {
            font-size: 1.5rem;
            font-weight: 500;
            margin-bottom: var(--space-xs);
        }

        header p {
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        /* Layout */
        .layout {
            display: flex;
            flex-direction: column;
            gap: var(--space-lg);
        }

        /* Top controls */
        .top-controls {
            background: var(--bg-secondary);
            border-radius: var(--radius-md);
            padding: var(--space-md);
        }

        .controls-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--space-sm);
        }

        .controls-header h3 {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-secondary);
            margin: 0;
        }

        .controls-row {
            display: flex;
            gap: var(--space-md);
            align-items: flex-start;
            flex-wrap: wrap;
        }

        /* Selection buttons */
        .selection-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: var(--space-xs);
            margin-bottom: var(--space-sm);
        }

        .selection-buttons .btn {
            font-size: 0.7rem;
            padding: 4px 8px;
            height: auto;
        }

        /* Mood grid (horizontal) */
        .mood-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            flex: 1;
        }

        .mood-chip {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.15s;
            font-size: 0.75rem;
        }

        .mood-chip:hover {
            border-color: var(--text-tertiary);
        }

        .mood-chip input[type="checkbox"] {
            display: none;
        }

        .mood-chip.selected {
            background: rgba(0, 100, 255, 0.15);
            border-color: rgba(0, 100, 255, 0.4);
        }

        .mood-chip .mood-code {
            font-family: monospace;
            font-size: 0.65rem;
            color: var(--text-tertiary);
        }

        .mood-chip .mood-label {
            color: var(--text-primary);
        }

        /* Settings section */
        .settings-section {
            display: flex;
            align-items: center;
            gap: var(--space-md);
            padding: var(--space-sm) var(--space-md);
            background: var(--bg-tertiary);
            border-radius: var(--radius-sm);
            min-width: fit-content;
        }

        .settings-section label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .settings-section input {
            width: 50px;
            padding: 4px 8px;
            font-size: 0.875rem;
            text-align: center;
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-sm);
            color: var(--text-primary);
        }

        .settings-section .hint {
            font-size: 0.65rem;
            color: var(--text-tertiary);
        }

        .stats-inline {
            display: flex;
            gap: var(--space-md);
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .stats-inline span {
            white-space: nowrap;
        }

        .stats-inline strong {
            color: var(--text-primary);
        }

        /* Action buttons */
        .action-buttons {
            display: flex;
            gap: var(--space-xs);
        }

        /* Progress */
        .progress-section {
            display: none;
            flex: 1;
            max-width: 300px;
        }

        .progress-section.visible {
            display: block;
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: var(--space-xs);
            font-size: 0.7rem;
            color: var(--text-secondary);
        }

        .progress-bar-bg {
            height: 4px;
            background: var(--border-primary);
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-bar-fill {
            height: 100%;
            background: var(--accent-primary);
            width: 0%;
            transition: width 0.3s ease;
        }

        /* Main content */
        .main-content {
            min-width: 0;
        }

        /* Results Grid */
        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: var(--space-sm);
        }

        .result-card {
            background: var(--bg-secondary);
            border-radius: var(--radius-md);
            overflow: hidden;
            border: 1px solid var(--border-primary);
        }

        .result-card.generating {
            opacity: 0.7;
        }

        .result-card.generating .result-placeholder {
            background: linear-gradient(90deg, var(--bg-tertiary) 25%, var(--bg-secondary) 50%, var(--bg-tertiary) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }

        @keyframes shimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        .result-image {
            width: 100%;
            aspect-ratio: 3/4;
            object-fit: cover;
            display: block;
        }

        .result-placeholder {
            width: 100%;
            aspect-ratio: 3/4;
            background: var(--bg-tertiary);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-tertiary);
            font-size: 0.875rem;
            font-weight: 500;
        }

        .result-info {
            padding: var(--space-sm);
        }

        .result-header {
            display: flex;
            align-items: center;
            gap: var(--space-xs);
            margin-bottom: 4px;
        }

        .result-code {
            font-family: monospace;
            font-size: 0.625rem;
            color: var(--text-tertiary);
            background: var(--bg-tertiary);
            padding: 2px 6px;
            border-radius: var(--radius-sm);
        }

        .result-framing {
            font-size: 0.625rem;
            color: var(--text-tertiary);
        }

        .result-name {
            font-size: 0.75rem;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .result-expression {
            font-size: 0.65rem;
            color: var(--text-tertiary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .result-actions {
            display: flex;
            gap: var(--space-xs);
            margin-top: var(--space-xs);
        }

        .result-actions .btn {
            flex: 1;
            font-size: 0.65rem;
            padding: 4px;
            height: auto;
        }

        /* Empty state */
        .empty-state {
            text-align: center;
            padding: var(--space-xl);
            color: var(--text-secondary);
        }

        .empty-state p {
            font-size: 0.875rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Mood Generator</h1>
            <p>Select moods â†’ generates both male & female with random framing per image</p>
        </header>

        <div class="layout">
            <!-- Top Controls -->
            <div class="top-controls">
                <div class="controls-header">
                    <h3>Select Moods</h3>
                    <div class="selection-buttons">
                        <button class="btn btn--secondary" id="select-all-btn">All 50</button>
                        <button class="btn btn--secondary" id="deselect-all-btn">None</button>
                        <button class="btn btn--secondary" id="select-random-10-btn">Random 10</button>
                    </div>
                </div>
                <div class="mood-grid" id="mood-checklist"></div>
            </div>

            <!-- Settings Bar -->
            <div class="top-controls">
                <div class="controls-row">
                    <div class="settings-section">
                        <label>Images per mood:</label>
                        <input type="number" id="images-per-mood" value="1" min="1" max="10">
                        <span class="hint">(Ã—2 genders)</span>
                    </div>

                    <div class="stats-inline">
                        <span>Selected: <strong id="selected-count">0</strong></span>
                        <span>Total images: <strong id="total-images-count">0</strong></span>
                        <span>Generated: <strong id="generated-count">0</strong></span>
                    </div>

                    <div class="progress-section" id="progress-section">
                        <div class="progress-header">
                            <span id="progress-status">Generating...</span>
                            <span id="progress-count">0 / 0</span>
                        </div>
                        <div class="progress-bar-bg">
                            <div class="progress-bar-fill" id="progress-bar"></div>
                        </div>
                    </div>

                    <div class="action-buttons">
                        <button class="btn btn--primary" id="generate-btn">Generate</button>
                        <button class="btn btn--secondary" id="download-all-btn" disabled>Download All</button>
                    </div>
                </div>
            </div>

            <!-- Results Grid -->
            <div class="main-content">
                <div class="results-grid" id="results-grid">
                    <div class="empty-state">
                        <p>Select moods above and click Generate</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="/shared/js/api.js"></script>
    <script src="/shared/data/editorial-moods.js"></script>
    <script>
        // Global state
        const state = {
            moods: [],           // 50 base moods (by name, used for selection)
            selected: new Set(), // selected mood IDs
            results: {},         // generated results keyed by unique filename
            generating: false
        };

        let api, elements;

        // Build mood list - 50 unique moods (we'll generate both genders for each)
        function buildMoodList() {
            // Use female moods as the base list (same names/IDs as male)
            return EDITORIAL_MOODS_FEMALE.map((mood, idx) => ({
                ...mood,
                index: idx + 1,
                code: String(idx + 1).padStart(2, '0')
            }));
        }

        // Get random framing for each prompt
        function getRandomFraming() {
            return FRAMING_OPTIONS[Math.floor(Math.random() * FRAMING_OPTIONS.length)];
        }

        // Build full prompt for a specific gender and mood (with AI variation)
        async function buildFullPrompt(mood, gender) {
            const subject = gender === 'female'
                ? 'Photorealistic portrait of a female model'
                : 'Photorealistic portrait of a male model';
            const baseMoodPrompt = gender === 'female'
                ? EDITORIAL_MOODS_FEMALE[mood.index - 1].prompt
                : EDITORIAL_MOODS_MALE[mood.index - 1].prompt;
            const framing = getRandomFraming();

            // Get appropriate expression pool for this mood and pick random expression
            const expressionPool = getExpressionPoolForMood(mood.id);
            const expression = getRandomExpression(expressionPool);

            // Get AI-varied prompt for uniqueness
            let moodPrompt = baseMoodPrompt;
            try {
                const varied = await api.varyPrompt(baseMoodPrompt, mood.name, gender);
                moodPrompt = varied.varied || baseMoodPrompt;
            } catch (err) {
                console.warn(`âš ï¸ Prompt variation failed for ${mood.name}, using base prompt:`, err.message);
            }

            return {
                prompt: `${subject}, ${framing.prompt}, ${expression.prompt}, ${moodPrompt}`,
                framing: framing,
                expression: expression,
                variedPrompt: moodPrompt
            };
        }

        // Get images per mood setting
        function getImagesPerMood() {
            return parseInt(elements.imagesPerMood.value) || 1;
        }

        // Render mood chips (unified - 50 moods)
        function renderChecklist() {
            elements.moodChecklist.innerHTML = state.moods.map(mood => `
                <label class="mood-chip ${state.selected.has(mood.id) ? 'selected' : ''}" data-id="${mood.id}">
                    <input type="checkbox" ${state.selected.has(mood.id) ? 'checked' : ''}>
                    <span class="mood-code">${mood.code}</span>
                    <span class="mood-label">${mood.name}</span>
                </label>
            `).join('');

            // Add event listeners
            document.querySelectorAll('.mood-chip').forEach(chip => {
                chip.addEventListener('click', function(e) {
                    e.preventDefault();
                    const id = this.dataset.id;
                    if (state.selected.has(id)) {
                        state.selected.delete(id);
                        this.classList.remove('selected');
                    } else {
                        state.selected.add(id);
                        this.classList.add('selected');
                    }
                    updateStats();
                });
            });

            updateStats();
        }

        // Update stats
        function updateStats() {
            const imagesPerMood = getImagesPerMood();
            const totalImages = state.selected.size * 2 * imagesPerMood; // Ã—2 for both genders
            elements.selectedCount.textContent = state.selected.size;
            elements.totalImagesCount.textContent = totalImages;
            elements.generatedCount.textContent = Object.keys(state.results).length;
            elements.generateBtn.disabled = state.selected.size === 0 || state.generating;
            elements.downloadAllBtn.disabled = Object.keys(state.results).length === 0;
        }

        // Render results grid
        function renderResults() {
            const results = Object.entries(state.results);

            if (results.length === 0) {
                elements.resultsGrid.innerHTML = `
                    <div class="empty-state">
                        <p>Select moods from the sidebar and click Generate</p>
                    </div>
                `;
                return;
            }

            elements.resultsGrid.innerHTML = results.map(([filename, result]) => `
                <div class="result-card" data-filename="${filename}">
                    <img class="result-image" src="${result.url}" alt="${result.name}">
                    <div class="result-info">
                        <div class="result-header">
                            <span class="result-code">${result.code}</span>
                            <span class="result-framing">${result.framing.name}</span>
                        </div>
                        <div class="result-name">${result.name}</div>
                        <div class="result-expression">${result.expression?.name || ''}</div>
                        <div class="result-actions">
                            <button class="btn btn--secondary" onclick="regenerateSingle('${filename}')">Redo</button>
                            <button class="btn btn--secondary" onclick="downloadSingle('${filename}')">Download</button>
                        </div>
                    </div>
                </div>
            `).join('');

            updateStats();
        }

        // Add generating placeholder
        function addGeneratingPlaceholder(genTask) {
            // Remove empty state if present
            const emptyState = elements.resultsGrid.querySelector('.empty-state');
            if (emptyState) emptyState.remove();

            // Check if card already exists
            let card = elements.resultsGrid.querySelector(`[data-filename="${genTask.filename}"]`);
            if (!card) {
                const html = `
                    <div class="result-card generating" data-filename="${genTask.filename}">
                        <div class="result-placeholder">${genTask.code}</div>
                        <div class="result-info">
                            <div class="result-header">
                                <span class="result-code">${genTask.code}</span>
                            </div>
                            <div class="result-name">${genTask.name}</div>
                        </div>
                    </div>
                `;
                elements.resultsGrid.insertAdjacentHTML('beforeend', html);
            }
        }

        // Update card with result
        function updateCardWithResult(filename, result) {
            const card = elements.resultsGrid.querySelector(`[data-filename="${filename}"]`);
            if (card) {
                card.classList.remove('generating');
                card.innerHTML = `
                    <img class="result-image" src="${result.url}" alt="${result.name}">
                    <div class="result-info">
                        <div class="result-header">
                            <span class="result-code">${result.code}</span>
                            <span class="result-framing">${result.framing.name}</span>
                        </div>
                        <div class="result-name">${result.name}</div>
                        <div class="result-expression">${result.expression?.name || ''}</div>
                        <div class="result-actions">
                            <button class="btn btn--secondary" onclick="regenerateSingle('${filename}')">Redo</button>
                            <button class="btn btn--secondary" onclick="downloadSingle('${filename}')">Download</button>
                        </div>
                    </div>
                `;
            }
        }

        // Generate single task (mood + gender + variation index)
        async function generateSingle(genTask) {
            addGeneratingPlaceholder(genTask);

            try {
                const { prompt, framing, expression } = await buildFullPrompt(genTask.mood, genTask.gender);
                console.log(`ðŸŽ¨ Generating: ${genTask.code} ${genTask.name} (${framing.name}, ${expression.name})`);

                const data = await api.generateImage('reve', {
                    prompt: prompt,
                    aspect_ratio: '3:4',
                    num_images: 1,
                    output_format: 'png'
                });

                if (data.images && data.images.length > 0) {
                    const result = {
                        url: data.images[0].url,
                        code: genTask.code,
                        name: genTask.name,
                        gender: genTask.gender,
                        mood: genTask.mood,
                        framing: framing,
                        expression: expression,
                        prompt: prompt
                    };
                    state.results[genTask.filename] = result;
                    updateCardWithResult(genTask.filename, result);
                    console.log(`   âœ… Done: ${genTask.code}`);
                    return result;
                }
            } catch (error) {
                console.error(`   âŒ Failed: ${genTask.code}`, error);
            }
            return null;
        }

        // Regenerate single - rebuild the task and regenerate
        async function regenerateSingle(filename) {
            const result = state.results[filename];
            if (!result) return;

            // Rebuild task from stored result
            const genTask = {
                mood: result.mood,
                gender: result.gender,
                code: result.code,
                name: result.name,
                filename: filename
            };

            delete state.results[filename];
            await generateSingle(genTask);
            updateStats();
        }

        // Build generation tasks from selected moods
        function buildGenerationTasks() {
            const tasks = [];
            const imagesPerMood = getImagesPerMood();
            const selectedMoods = state.moods.filter(m => state.selected.has(m.id));

            for (const mood of selectedMoods) {
                // Generate for both genders, multiple images each
                for (const gender of ['female', 'male']) {
                    for (let i = 1; i <= imagesPerMood; i++) {
                        const genderCode = gender === 'female' ? 'F' : 'M';
                        const code = `${mood.code}${genderCode}${i}`;
                        tasks.push({
                            mood: mood,
                            gender: gender,
                            variationIndex: i,
                            code: code,
                            name: `${mood.name} (${gender === 'female' ? 'â™€' : 'â™‚'} #${i})`,
                            filename: `mood_${code}_${mood.id}.png`
                        });
                    }
                }
            }
            return tasks;
        }

        // Generate all selected
        async function generateSelected() {
            if (state.generating || state.selected.size === 0) return;
            state.generating = true;

            elements.generateBtn.disabled = true;
            elements.progressSection.classList.add('visible');

            const tasks = buildGenerationTasks();
            const total = tasks.length;
            let completed = 0;

            console.log(`\nðŸŽ¬ Starting generation of ${total} images (${state.selected.size} moods Ã— 2 genders Ã— ${getImagesPerMood()} each)...`);

            elements.progressCount.textContent = `0 / ${total}`;
            elements.progressBar.style.width = '0%';

            const MAX_CONCURRENT = 5;
            const executing = new Set();

            for (const task of tasks) {
                const promise = (async () => {
                    await generateSingle(task);
                    completed++;
                    elements.progressCount.textContent = `${completed} / ${total}`;
                    elements.progressBar.style.width = `${(completed / total) * 100}%`;
                    updateStats();
                })();

                const wrapped = promise.then(() => executing.delete(wrapped));
                executing.add(wrapped);

                if (executing.size >= MAX_CONCURRENT) {
                    await Promise.race(executing);
                }
            }

            await Promise.all(executing);

            console.log(`\nâœ… Generation complete!`);
            elements.progressStatus.textContent = 'Complete!';
            state.generating = false;
            elements.generateBtn.disabled = false;
        }

        // Download single
        async function downloadSingle(filename) {
            const result = state.results[filename];
            if (!result) return;

            try {
                const response = await fetch(result.url);
                const blob = await response.blob();
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (error) {
                console.error('Download failed:', error);
            }
        }

        // Download all
        async function downloadAll() {
            const results = Object.entries(state.results);
            console.log(`ðŸ“¥ Downloading ${results.length} images...`);

            for (const [filename, result] of results) {
                await downloadSingle(filename);
                await new Promise(r => setTimeout(r, 300));
            }

            console.log('âœ… All downloads complete!');
        }

        // Selection helpers
        function selectAll() {
            state.moods.forEach(m => state.selected.add(m.id));
            renderChecklist();
        }

        function deselectAll() {
            state.selected.clear();
            renderChecklist();
        }

        function selectRandom10() {
            state.selected.clear();
            const shuffled = [...state.moods].sort(() => Math.random() - 0.5);
            shuffled.slice(0, 10).forEach(m => state.selected.add(m.id));
            renderChecklist();
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            api = new API();
            elements = {
                moodChecklist: document.getElementById('mood-checklist'),
                imagesPerMood: document.getElementById('images-per-mood'),
                selectedCount: document.getElementById('selected-count'),
                totalImagesCount: document.getElementById('total-images-count'),
                generatedCount: document.getElementById('generated-count'),
                generateBtn: document.getElementById('generate-btn'),
                downloadAllBtn: document.getElementById('download-all-btn'),
                resultsGrid: document.getElementById('results-grid'),
                progressSection: document.getElementById('progress-section'),
                progressStatus: document.getElementById('progress-status'),
                progressCount: document.getElementById('progress-count'),
                progressBar: document.getElementById('progress-bar')
            };

            // Build mood list (50 unique moods)
            state.moods = buildMoodList();
            renderChecklist();

            // Selection buttons
            document.getElementById('select-all-btn').addEventListener('click', selectAll);
            document.getElementById('deselect-all-btn').addEventListener('click', deselectAll);
            document.getElementById('select-random-10-btn').addEventListener('click', selectRandom10);

            // Images per mood change handler
            elements.imagesPerMood.addEventListener('change', updateStats);

            // Generate button
            elements.generateBtn.addEventListener('click', generateSelected);

            // Download all button
            elements.downloadAllBtn.addEventListener('click', downloadAll);

            console.log('ðŸŽ¨ Mood Generator initialized');
            console.log(`   ${state.moods.length} moods loaded (Ã—2 genders)`);
            console.log(`   Framings: ${FRAMING_OPTIONS.map(f => f.name).join(', ')}`);
        });
    </script>
</body>
</html>
