<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light">
    <title>Talent Creator</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ‘¤</text></svg>">
    <link rel="stylesheet" href="/shared/css/tokens.css">
    <link rel="stylesheet" href="/shared/css/base.css">
    <link rel="stylesheet" href="/shared/css/components.css">
    <style>
        :root {
            color-scheme: light only;
        }

        .container {
            max-width: 900px;
        }

        .generator-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-md);
            margin-bottom: var(--space-lg);
        }

        .generator-section {
            background: var(--off-white);
            padding: var(--space-md);
            border-radius: var(--radius-md);
        }

        .generator-section.full-width {
            grid-column: 1 / -1;
        }

        .section-title {
            font-size: var(--text-sm);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--carbon);
            margin-bottom: var(--space-sm);
        }

        /* Description textarea */
        .description-input {
            width: 100%;
            padding: 12px 14px;
            font-size: var(--text-md);
            font-family: var(--font-sans);
            color: var(--carbon);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-sm);
            background: var(--white);
            resize: none;
            min-height: 100px;
            line-height: 1.5;
        }

        .description-input:focus {
            outline: none;
            border-color: var(--jet);
        }

        .description-input::placeholder {
            color: var(--slate);
        }

        /* Button groups */
        .button-group {
            display: flex;
            gap: var(--space-xs);
        }

        .button-group .btn {
            flex: 1;
        }

        .button-group-wrap {
            display: flex;
            flex-wrap: wrap;
            gap: var(--space-xs);
        }

        .button-group-wrap .btn {
            padding: 10px 16px;
        }

        /* Slider */
        .slider-row {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }

        .slider-label {
            font-size: var(--text-sm);
            color: var(--slate);
            min-width: 45px;
        }

        .slider-label.right {
            text-align: right;
        }

        .edginess-slider {
            flex: 1;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--gainsboro);
            border-radius: 4px;
            cursor: pointer;
        }

        .edginess-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: var(--jet);
            border-radius: 50%;
            cursor: pointer;
        }

        .edginess-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: var(--jet);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .edginess-slider.randomize {
            opacity: 0.3;
            pointer-events: none;
        }

        .randomize-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: var(--space-sm);
            font-size: var(--text-sm);
            color: var(--slate);
            cursor: pointer;
        }

        .randomize-toggle input {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        /* Generate section */
        .generate-section {
            margin-top: var(--space-md);
        }

        .calc-display {
            font-size: var(--text-md);
            color: var(--carbon);
            margin-bottom: var(--space-sm);
            text-align: center;
        }

        /* Progress */
        .progress-section {
            display: none;
            margin-top: var(--space-lg);
            padding: var(--space-lg);
            background: var(--white);
            border-radius: var(--radius-lg);
            border: 1px solid var(--gainsboro);
        }

        .progress-section.visible {
            display: block;
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-sm);
        }

        .progress-title {
            font-size: var(--text-xs);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--slate);
        }

        .progress-count {
            font-size: var(--text-sm);
            font-weight: 600;
            color: var(--jet);
        }

        .progress-bar-container {
            height: 8px;
            background: var(--off-white);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: var(--jet);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }

        /* Results */
        .results-section {
            display: none;
            margin-top: var(--space-lg);
        }

        .results-section.visible {
            display: block;
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-md);
        }

        .results-header h3 {
            font-size: var(--text-sm);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--carbon);
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: var(--space-md);
        }

        @media (max-width: 900px) {
            .results-grid {
                grid-template-columns: repeat(3, 1fr);
            }
            .generator-grid {
                grid-template-columns: 1fr;
            }
        }

        .result-card {
            position: relative;
            border-radius: var(--radius-md);
            overflow: hidden;
            cursor: pointer;
            border: 2px solid var(--gainsboro);
            transition: all var(--transition-fast);
            background: var(--off-white);
        }

        .result-card:hover {
            border-color: var(--jet);
        }

        .result-card img {
            width: 100%;
            aspect-ratio: 3/4;
            object-fit: cover;
            display: block;
        }

        .result-placeholder {
            width: 100%;
            aspect-ratio: 3/4;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: var(--space-xs);
            background: var(--off-white);
        }

        .result-placeholder .spinner {
            width: 24px;
            height: 24px;
            border: 2px solid var(--gainsboro);
            border-top-color: var(--jet);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .result-placeholder p {
            font-size: var(--text-xs);
            color: var(--slate);
        }

        .result-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: var(--space-sm);
            background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
            opacity: 0;
            transition: opacity var(--transition-fast);
        }

        .result-card:hover .result-overlay {
            opacity: 1;
        }

        .result-actions {
            display: flex;
            gap: var(--space-xs);
        }

        .result-btn {
            flex: 1;
            padding: 6px 10px;
            background: var(--white);
            border: none;
            border-radius: var(--radius-sm);
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .result-btn:hover {
            background: var(--jet);
            color: var(--white);
        }

        /* Lightbox */
        .lightbox {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: var(--space-lg);
        }

        .lightbox.visible {
            display: flex;
        }

        .lightbox-content {
            display: flex;
            gap: var(--space-lg);
            max-width: 1200px;
            max-height: 90vh;
        }

        .lightbox-image {
            max-height: 85vh;
            max-width: 50vw;
            object-fit: contain;
            border-radius: var(--radius-md);
        }

        .lightbox-info {
            width: 320px;
            background: var(--white);
            border-radius: var(--radius-md);
            padding: var(--space-md);
            overflow-y: auto;
            max-height: 85vh;
        }

        .lightbox-info h3 {
            font-size: var(--text-xs);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--slate);
            margin-bottom: var(--space-xs);
        }

        .lightbox-info p {
            font-size: var(--text-sm);
            color: var(--carbon);
            margin-bottom: var(--space-md);
            line-height: 1.5;
        }

        .lightbox-close {
            position: absolute;
            top: var(--space-md);
            right: var(--space-md);
            width: 44px;
            height: 44px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: var(--radius-sm);
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
        }

        .lightbox-close:hover {
            background: rgba(255,255,255,0.2);
        }

        .lightbox-nav {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 50px;
            height: 50px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: var(--radius-sm);
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
        }

        .lightbox-nav:hover {
            background: rgba(255,255,255,0.2);
        }

        .lightbox-prev { left: var(--space-md); }
        .lightbox-next { right: var(--space-md); }

        /* Inline Loader */
        .inline-loader {
            display: none;
            text-align: center;
            padding: var(--space-xl) var(--space-lg);
            background: var(--white);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-lg);
            margin-top: var(--space-lg);
        }

        .inline-loader.visible {
            display: block;
        }

        .loader-message {
            font-size: var(--text-lg);
            font-weight: 500;
            color: var(--jet);
            margin-bottom: var(--space-sm);
            transition: opacity 0.25s ease;
        }

        .loader-message.fade-out {
            opacity: 0;
        }

        .loader-message.fade-in {
            opacity: 1;
        }

        .loader-progress {
            font-size: var(--text-sm);
            color: var(--slate);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="hero">
            <h1>Talent Creator</h1>
            <p class="hero-subtitle">Generate diverse talent headshots matching the Setset aesthetic</p>
        </div>

        <!-- Generator Controls -->
        <div class="generator-grid">
            <!-- Description -->
            <div class="generator-section full-width">
                <div class="section-title">Describe the Person</div>
                <textarea class="description-input" id="description-input"
                    placeholder="Describe the person you want to create...&#10;&#10;Example: Scandinavian woman with sharp features, high cheekbones, cool undertones, natural freckles, strawberry blonde hair"></textarea>
            </div>

            <!-- Gender -->
            <div class="generator-section">
                <div class="section-title">Gender</div>
                <div class="button-group" id="gender-group">
                    <button class="btn btn--toggle active" data-value="female">Female</button>
                    <button class="btn btn--toggle active" data-value="male">Male</button>
                </div>
            </div>

            <!-- Age Range -->
            <div class="generator-section">
                <div class="section-title">Age Range</div>
                <div class="button-group" id="age-group">
                    <button class="btn btn--toggle active" data-value="20s">20s</button>
                    <button class="btn btn--toggle active" data-value="30s">30s</button>
                    <button class="btn btn--toggle" data-value="40s">40s</button>
                    <button class="btn btn--toggle" data-value="50s">50s</button>
                </div>
            </div>

            <!-- Expression -->
            <div class="generator-section full-width">
                <div class="section-title">Expression</div>
                <div class="button-group-wrap" id="expression-group">
                    <button class="btn btn--toggle active" data-value="random">Random</button>
                    <button class="btn btn--toggle" data-value="neutral">Neutral</button>
                    <button class="btn btn--toggle" data-value="subtle-smile">Subtle Smile</button>
                    <button class="btn btn--toggle" data-value="warm-smile">Warm Smile</button>
                    <button class="btn btn--toggle" data-value="laugh">Laugh</button>
                    <button class="btn btn--toggle" data-value="serious">Serious</button>
                    <button class="btn btn--toggle" data-value="contemplative">Contemplative</button>
                </div>
            </div>

            <!-- Edginess -->
            <div class="generator-section full-width">
                <div class="section-title">Edginess</div>
                <div class="slider-row">
                    <span class="slider-label">Clean</span>
                    <input type="range" class="edginess-slider" id="edginess-slider" min="0" max="100" value="50">
                    <span class="slider-label right">Raw</span>
                </div>
                <label class="randomize-toggle">
                    <input type="checkbox" id="edginess-random" checked>
                    Randomize per image
                </label>
            </div>

            <!-- Model (multi-select) -->
            <div class="generator-section">
                <div class="section-title">Model</div>
                <div class="button-group" id="model-group">
                    <button class="btn btn--toggle active" data-value="reve">Reve</button>
                    <button class="btn btn--toggle active" data-value="zimage">Z-Image</button>
                </div>
            </div>

            <!-- Aspect Ratio -->
            <div class="generator-section">
                <div class="section-title">Aspect Ratio</div>
                <div class="button-group" id="aspect-group">
                    <button class="btn btn--toggle" data-value="2:3">2:3</button>
                    <button class="btn btn--toggle active" data-value="3:4">3:4</button>
                    <button class="btn btn--toggle" data-value="4:5">4:5</button>
                    <button class="btn btn--toggle" data-value="1:1">1:1</button>
                </div>
            </div>

            <!-- Number of Results -->
            <div class="generator-section full-width">
                <div class="section-title">Number of Results</div>
                <div class="button-group" id="count-group">
                    <button class="btn btn--toggle" data-value="5">5</button>
                    <button class="btn btn--toggle active" data-value="10">10</button>
                    <button class="btn btn--toggle" data-value="15">15</button>
                    <button class="btn btn--toggle" data-value="20">20</button>
                </div>
            </div>
        </div>

        <!-- Generate -->
        <div class="generate-section">
            <div class="calc-display" id="calc-display">10 images @ $0.03 each = $0.30</div>
            <button class="btn btn--primary btn--lg btn--block" id="generate-btn">Generate Talent</button>
        </div>

        <!-- Progress -->
        <div class="progress-section" id="progress-section">
            <div class="progress-header">
                <span class="progress-title">Generating</span>
                <span class="progress-count" id="progress-count">0 / 0</span>
            </div>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
        </div>

        <!-- Results -->
        <div class="results-section" id="results-section">
            <div class="results-header">
                <h3>Generated Talent</h3>
                <button class="btn" id="download-all-btn">Download All</button>
            </div>
            <div class="results-grid" id="results-grid"></div>
        </div>
    </div>

    <!-- Lightbox -->
    <div class="lightbox" id="lightbox" onclick="if(event.target === this) closeLightbox()">
        <button class="lightbox-close" onclick="closeLightbox()">&times;</button>
        <button class="lightbox-nav lightbox-prev" onclick="navigateLightbox(-1)">&#8249;</button>
        <button class="lightbox-nav lightbox-next" onclick="navigateLightbox(1)">&#8250;</button>
        <div class="lightbox-content">
            <img class="lightbox-image" id="lightbox-image" src="" alt="Generated talent">
            <div class="lightbox-info">
                <h3>Prompt</h3>
                <p id="lightbox-prompt"></p>
                <h3>Settings</h3>
                <p id="lightbox-settings"></p>
                <button class="btn btn--primary btn--block" id="lightbox-download">Download</button>
            </div>
        </div>
    </div>

    <script src="/shared/js/api.js"></script>
    <script src="/shared/js/loader.js"></script>
    <script>
        // State
        const state = {
            description: '',
            genders: ['female', 'male'],
            ages: ['20s', '30s'],
            expression: 'random',
            edginess: 50,
            edginessRandom: true,
            models: ['reve', 'zimage'],
            aspectRatio: '3:4',
            resultCount: 10,
            results: [],
            generating: false,
            lightboxIndex: 0
        };

        // Model costs per image
        const MODEL_COSTS = {
            'reve': 0.04,
            'zimage': 0.01
        };

        // Aspect ratio to dimensions (for models that need explicit sizes)
        const ASPECT_SIZES = {
            '2:3': { width: 768, height: 1152 },
            '3:4': { width: 768, height: 1024 },
            '4:5': { width: 816, height: 1020 },
            '1:1': { width: 1024, height: 1024 }
        };

        // Base prompt for Setset aesthetic
        const SETSET_STYLE = `Professional headshot portrait photography, soft diffused natural lighting, clean white background, head and shoulders framing, centered composition, wearing a simple black or white crew neck t-shirt, natural skin texture with minimal retouching, editorial fashion photography style, shot on medium format camera, shallow depth of field, neutral color grading, no harsh shadows`;

        // Expression prompts
        const EXPRESSIONS = {
            'neutral': 'neutral composed expression, direct confident gaze at camera, relaxed facial muscles',
            'subtle-smile': 'subtle hint of a smile, corners of mouth slightly raised, warm eyes, approachable',
            'warm-smile': 'genuine warm smile showing some teeth, bright friendly expression, sparkling eyes',
            'laugh': 'candid laughing expression, genuine joy, natural mid-laugh moment, eyes crinkled',
            'serious': 'serious intense expression, strong focused gaze, commanding presence, slightly furrowed brow',
            'contemplative': 'thoughtful contemplative expression, gazing slightly off-camera, introspective mood'
        };

        // Edginess feature pools - randomly selected to create variety
        const EDGINESS_FEATURES = {
            // Level 3 (40-59): subtle, one feature maybe
            medium: [
                'a subtle beauty mark',
                'very light natural freckles',
                'a small mole',
                'natural skin texture',
                'slight asymmetry in features'
            ],
            // Level 4 (60-79): more pronounced, pick one
            high: [
                'a distinctive mole',
                'light scattered freckles across nose and cheeks',
                'an interesting beauty mark',
                'natural freckles',
                'a gap between front teeth',
                'slightly uneven features adding character'
            ],
            // Level 5 (80-100): raw, pick one distinctive feature
            raw: [
                'a small facial mole adding character',
                'subtle freckles across the face',
                'a tiny faint scar near eyebrow',
                'a beauty mark on cheek',
                'natural freckles and a small mole',
                'a healed piercing mark',
                'slight crooked nose adding character',
                'distinctive natural birthmark'
            ]
        };

        function getRandomFeature(pool) {
            return pool[Math.floor(Math.random() * pool.length)];
        }

        // Edginess descriptions
        function getEdginessPrompt(level) {
            if (level < 20) {
                return 'very polished refined appearance, perfectly groomed hair neatly styled, flawless clear skin, symmetrical features, conventionally attractive, clean-cut classic look';
            } else if (level < 40) {
                return 'polished but natural appearance, well-groomed hair with some natural texture, clear skin, attractive features, approachable everyday look';
            } else if (level < 60) {
                const feature = getRandomFeature(EDGINESS_FEATURES.medium);
                return `natural authentic appearance, hair with natural texture and movement, ${feature}, interesting distinctive features, effortlessly cool`;
            } else if (level < 80) {
                const feature = getRandomFeature(EDGINESS_FEATURES.high);
                return `raw editorial appearance, slightly undone tousled hair, ${feature}, striking unconventional features, high fashion edge, interesting asymmetry`;
            } else {
                const feature = getRandomFeature(EDGINESS_FEATURES.raw);
                return `raw striking appearance, messy textured hair with attitude, ${feature}, bold unconventional features, high fashion editorial edge, distinctive memorable face`;
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            setupEventListeners();
            updateCalcDisplay();
        });

        function setupEventListeners() {
            // Description
            document.getElementById('description-input').addEventListener('input', (e) => {
                state.description = e.target.value;
            });

            // Gender toggle buttons
            document.querySelectorAll('#gender-group .btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    btn.classList.toggle('active');
                    state.genders = Array.from(document.querySelectorAll('#gender-group .btn.active'))
                        .map(b => b.dataset.value);
                    updateUI();
                });
            });

            // Age toggle buttons
            document.querySelectorAll('#age-group .btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    btn.classList.toggle('active');
                    state.ages = Array.from(document.querySelectorAll('#age-group .btn.active'))
                        .map(b => b.dataset.value);
                    updateUI();
                });
            });

            // Expression single-select
            document.querySelectorAll('#expression-group .btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#expression-group .btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.expression = btn.dataset.value;
                });
            });

            // Edginess slider
            document.getElementById('edginess-slider').addEventListener('input', (e) => {
                state.edginess = parseInt(e.target.value);
            });

            // Edginess random toggle
            document.getElementById('edginess-random').addEventListener('change', (e) => {
                state.edginessRandom = e.target.checked;
                document.getElementById('edginess-slider').classList.toggle('randomize', e.target.checked);
            });

            // Model multi-select (toggle)
            document.querySelectorAll('#model-group .btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const value = btn.dataset.value;
                    const index = state.models.indexOf(value);

                    if (index > -1) {
                        // Don't allow deselecting if it's the only one selected
                        if (state.models.length > 1) {
                            state.models.splice(index, 1);
                            btn.classList.remove('active');
                        }
                    } else {
                        state.models.push(value);
                        btn.classList.add('active');
                    }
                    updateCalcDisplay();
                });
            });

            // Aspect ratio single-select
            document.querySelectorAll('#aspect-group .btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#aspect-group .btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.aspectRatio = btn.dataset.value;
                });
            });

            // Count single-select
            document.querySelectorAll('#count-group .btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#count-group .btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.resultCount = parseInt(btn.dataset.value);
                    updateCalcDisplay();
                });
            });

            // Generate button
            document.getElementById('generate-btn').addEventListener('click', generateTalent);

            // Download all button
            document.getElementById('download-all-btn').addEventListener('click', downloadAll);

            // Keyboard navigation for lightbox
            document.addEventListener('keydown', (e) => {
                if (!document.getElementById('lightbox').classList.contains('visible')) return;
                if (e.key === 'Escape') closeLightbox();
                if (e.key === 'ArrowLeft') navigateLightbox(-1);
                if (e.key === 'ArrowRight') navigateLightbox(1);
            });
        }

        function updateUI() {
            const hasGender = state.genders.length > 0;
            const hasAge = state.ages.length > 0;
            document.getElementById('generate-btn').disabled = !hasGender || !hasAge || state.generating;
        }

        function updateCalcDisplay() {
            // Each model gets resultCount images
            const totalImages = state.resultCount * state.models.length;
            const totalCost = state.models.reduce((sum, m) => sum + (MODEL_COSTS[m] || 0.04) * state.resultCount, 0);
            const modelNames = state.models.map(m => m === 'reve' ? 'Reve' : 'Z-Image').join(' + ');
            document.getElementById('calc-display').textContent = `${state.resultCount} prompts Ã— ${state.models.length} model${state.models.length > 1 ? 's' : ''} = ${totalImages} images â‰ˆ $${totalCost.toFixed(2)}`;
        }

        // Generate prompts via GPT
        async function generatePrompts(count) {
            const genderText = state.genders.join(' and ');
            const ageText = state.ages.join(', ');

            const systemPrompt = `You are creating detailed prompts for AI-generated headshot portraits.
Each prompt MUST describe a completely DIFFERENT person - vary everything systematically.

ABSOLUTE RULES:
- Professional headshot framing: head and shoulders, centered, white background
- Soft diffused lighting, no harsh shadows
- Wearing simple black or white crew neck t-shirt
- Natural skin texture, editorial fashion photography style
- Shot on medium format camera
- NO celebrities, NO named people, NO brand names

DIVERSITY IS CRITICAL - use these pools and pick DIFFERENT options for each person:

ETHNICITIES (use many different ones):
East Asian, Southeast Asian, South Asian, Middle Eastern, North African, West African, East African,
Northern European, Southern European, Eastern European, Latin American, Caribbean, Pacific Islander,
Indigenous American, Mixed heritage

FACE SHAPES: oval, round, square, heart-shaped, diamond, oblong, rectangular

SKIN TONES: fair porcelain, light beige, medium olive, warm tan, golden brown, deep brown, rich ebony,
cool undertones, warm undertones, neutral undertones

HAIR TEXTURES: pin-straight, slightly wavy, loose waves, tight curls, coily 4c texture,
naturally textured, slicked back, tousled, cropped short, buzz cut, long flowing

HAIR COLORS: jet black, dark brown, chestnut, auburn, strawberry blonde, platinum blonde,
silver gray, natural gray streaks, honey highlights`;

            // Check if user provided a specific description or wants general diversity
            const hasSpecificDescription = state.description && state.description.trim().length > 10;

            const userPrompt = hasSpecificDescription
            ? `Create ${count} unique portrait prompts. ALL must match this description but each should be a DIFFERENT INDIVIDUAL.

USER'S DESCRIPTION (follow this closely - all ${count} people should match this type):
${state.description}

REQUIREMENTS:
- Genders: ${genderText} (distribute evenly)
- Ages: ${ageText} (spread across these)
- Expression: ${state.expression === 'random' ? 'VARY each one (neutral, subtle smile, warm smile, serious, contemplative, playful, intense)' : EXPRESSIONS[state.expression]}
- Edginess: ${state.edginessRandom ? 'VARY from clean/polished to raw/editorial' : getEdginessPrompt(state.edginess)}

CRITICAL - SKIN TONE MUST BE REALISTIC FOR THE ETHNICITY DESCRIBED!
The user said "${state.description.substring(0, 50)}..." - identify the ethnicity and ONLY use skin tones that are realistic for that group.

Examples of CORRECT skin tone matching:
- Northern European/Nordic/Scandinavian â†’ ONLY: fair, pale, light, light beige, pale pink undertones (NEVER dark/ebony/mahogany)
- Mediterranean/Southern European â†’ ONLY: light olive, warm olive, golden tan, sun-bronzed
- East Asian â†’ ONLY: fair porcelain, light, medium, warm beige, golden
- South Asian â†’ ONLY: light golden, warm brown, medium brown, deep brown, caramel
- African/Black â†’ ONLY: warm brown, deep brown, mahogany, ebony (NEVER fair/pale)
- Latin American â†’ varies widely: light tan to deep brown depending on heritage

DO NOT MIX - a "Northern European" should NEVER have "ebony" or "mahogany" skin. An "African" should NEVER have "pale" or "porcelain" skin.

ALWAYS explicitly state the skin tone and make sure it matches the ethnicity!

MAKE EACH PERSON UNIQUE BY VARYING:
- SKIN TONE (must vary! some lighter, some darker - state it explicitly like "deep olive skin" or "warm golden-brown skin")
- Face shape (oval, square, heart-shaped, angular, etc.)
- Specific facial features (nose shape, lip fullness, cheekbone prominence, jawline)
- Hairstyle (different cuts, lengths, textures - appropriate for the ethnicity)
- Small unique details (beauty marks, freckles, etc.)
- Expression and gaze

All ${count} people should clearly match "${state.description}" but look like ${count} DIFFERENT individuals with VARIED SKIN TONES.

Write each as ONE detailed sentence. ALWAYS include explicit skin tone description. Return ONLY a JSON array.`

            : `Create ${count} unique portrait prompts. EACH MUST BE A COMPLETELY DIFFERENT LOOKING PERSON with maximum diversity.

REQUIREMENTS:
- Genders: ${genderText} (distribute evenly)
- Ages: ${ageText} (spread across these)
- Expression: ${state.expression === 'random' ? 'VARY each one (neutral, subtle smile, warm smile, serious, contemplative, playful, intense)' : EXPRESSIONS[state.expression]}
- Edginess: ${state.edginessRandom ? 'VARY from clean/polished to raw/editorial' : getEdginessPrompt(state.edginess)}

FOR EACH PERSON, VARY ALL OF THESE (no two people should share the same combination):
1. ETHNICITY: Pick different ones (East Asian, South Asian, West African, Northern European, Latin American, Middle Eastern, Southeast Asian, Caribbean, Pacific Islander, etc.)
2. FACE SHAPE: oval, round, square, heart-shaped, diamond, angular, soft, strong bone structure
3. SKIN TONE: Must match ethnicity naturally
4. HAIRSTYLE: Must be ethnicity-appropriate! Examples:
   - East Asian: straight hair, blunt bangs, two-block cut, middle part
   - African descent: natural afro, locs, twists, braids, fade, coils
   - European: wavy, tousled, side part, messy bedhead, textured crop
   - South Asian: thick wavy, voluminous, long straight
5. HAIR COLOR: Must match ethnicity (blonde for Northern Europeans, jet black for East Asian, etc.)
6. DISTINCTIVE FEATURE: strong nose, full lips, sharp cheekbones, defined jaw, hooded eyes, wide-set eyes, thick brows

Write each as ONE detailed sentence. Return ONLY a JSON array.
Example: ["Korean woman in her 20s, oval face, fair skin, straight black hair with middle part, subtle smile, strong cheekbones", "Nigerian man in his 30s, square jaw, deep ebony skin, short fade, neutral gaze, full lips"]`;

            try {
                console.log('ðŸŽ­ [Talent Creator] Generating prompts...');
                console.log('ðŸŽ­ [Talent Creator] Has specific description:', hasSpecificDescription);
                console.log('ðŸŽ­ [Talent Creator] Description:', state.description?.substring(0, 100));

                const response = await fetch('/api/analyze', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        images: [],
                        prompt: userPrompt,
                        system: systemPrompt
                    })
                });

                const data = await response.json();

                if (data.error) {
                    console.error('ðŸŽ­ [Talent Creator] GPT Error:', data.error);
                    throw new Error(data.error);
                }

                let content = data.content || '';
                console.log('ðŸŽ­ [Talent Creator] GPT Response received, length:', content.length);

                // Extract JSON array from response
                const jsonMatch = content.match(/\[[\s\S]*\]/);
                if (jsonMatch) {
                    const rawPrompts = JSON.parse(jsonMatch[0]);
                    console.log('ðŸŽ­ [Talent Creator] GPT returned type:', typeof rawPrompts[0], rawPrompts[0]);

                    // Handle both string arrays and object arrays
                    const processedPrompts = rawPrompts.map(p => {
                        let promptText = p;
                        if (typeof p === 'object' && p !== null) {
                            promptText = p.prompt || p.description || p.text || p.content || JSON.stringify(p);
                        }
                        return `${promptText} ${SETSET_STYLE}`;
                    });

                    // Remove duplicates
                    const uniquePrompts = [...new Set(processedPrompts)];
                    if (uniquePrompts.length < processedPrompts.length) {
                        console.log(`ðŸŽ­ [Talent Creator] Removed ${processedPrompts.length - uniquePrompts.length} duplicate prompts`);
                    }

                    return uniquePrompts;
                }

                throw new Error('Failed to parse prompts');
            } catch (error) {
                console.error('ðŸŽ­ [Talent Creator] Prompt generation error:', error);
                console.log('ðŸŽ­ [Talent Creator] Using FALLBACK prompts');
                const fallbackPrompts = generateFallbackPrompts(count);
                console.log('ðŸŽ­ [Talent Creator] First fallback prompt:', fallbackPrompts[0]?.substring(0, 200));
                return fallbackPrompts;
            }
        }

        // Fallback pools for variety when GPT fails
        // Ethnicity-specific data with appropriate hairstyles and hair colors
        const ETHNICITY_DATA = {
            'East Asian': {
                skinTones: ['fair porcelain skin', 'light skin with warm undertones', 'golden beige skin', 'honey-toned skin'],
                hairstyles: ['straight black hair with blunt bangs', 'short textured crop', 'slicked back hair', 'middle-parted straight hair', 'choppy layered cut', 'two-block haircut', 'long flowing straight hair', 'asymmetrical bob', 'soft waves', 'undercut with longer top', 'curtain bangs with layers'],
                hairColors: ['jet black', 'dark brown', 'soft black', 'dark ash brown', 'subtle brown highlights']
            },
            'South Asian': {
                skinTones: ['warm brown skin', 'golden tan skin', 'deep brown skin', 'medium olive skin', 'rich caramel skin'],
                hairstyles: ['thick wavy hair', 'long straight black hair', 'short textured cut', 'slicked back hair', 'medium length with natural wave', 'side-parted classic cut', 'voluminous curls', 'cropped fade', 'layered shoulder-length hair', 'natural thick waves'],
                hairColors: ['jet black', 'deep dark brown', 'dark brown with subtle warmth', 'natural black']
            },
            'West African': {
                skinTones: ['deep ebony skin', 'rich dark brown skin', 'warm mahogany skin', 'deep chocolate skin'],
                hairstyles: ['short natural curls', 'buzz cut', 'high top fade', 'locs', 'short twists', 'natural afro', 'tapered fade', 'braided cornrows', 'short cropped natural hair', 'medium length twists', 'defined coils', 'low fade with texture'],
                hairColors: ['jet black', 'natural black', 'deep dark brown']
            },
            'East African': {
                skinTones: ['warm brown skin', 'deep brown skin', 'rich mahogany skin', 'golden brown skin'],
                hairstyles: ['short natural curls', 'buzz cut', 'tapered sides', 'locs', 'short twists', 'natural texture cropped short', 'defined curls', 'fade with natural top', 'medium length natural hair', 'braids'],
                hairColors: ['jet black', 'natural black', 'deep brown']
            },
            'Northern European': {
                skinTones: ['fair porcelain skin', 'light skin with pink undertones', 'pale skin with cool undertones', 'light beige skin'],
                hairstyles: ['short textured blonde hair', 'slicked back hair', 'medium wavy hair', 'messy bedhead style', 'side-parted classic cut', 'cropped buzz cut', 'tousled waves', 'swept back undercut', 'long flowing hair', 'layered shag', 'clean side part', 'textured crop'],
                hairColors: ['platinum blonde', 'ash blonde', 'honey blonde', 'light brown', 'strawberry blonde', 'dirty blonde', 'sandy brown', 'golden blonde']
            },
            'Southern European': {
                skinTones: ['olive skin', 'warm tan skin', 'medium skin with warm undertones', 'sun-kissed olive skin'],
                hairstyles: ['dark wavy hair', 'slicked back hair', 'short textured cut', 'medium curly hair', 'tousled waves', 'classic side part', 'messy textured style', 'cropped with texture', 'longer swept back style', 'natural waves'],
                hairColors: ['dark brown', 'jet black', 'chestnut brown', 'espresso brown', 'warm dark brown']
            },
            'Latin American': {
                skinTones: ['warm tan skin', 'golden brown skin', 'olive skin', 'caramel skin', 'light brown skin', 'medium brown skin'],
                hairstyles: ['dark wavy hair', 'short textured cut', 'slicked back hair', 'curly hair', 'medium length waves', 'tapered fade', 'long flowing dark hair', 'tousled curls', 'classic pompadour', 'natural waves', 'cropped with volume'],
                hairColors: ['jet black', 'dark brown', 'deep brown', 'chestnut', 'warm brown with highlights']
            },
            'Middle Eastern': {
                skinTones: ['olive skin', 'warm tan skin', 'medium skin with golden undertones', 'light olive skin', 'warm brown skin'],
                hairstyles: ['thick dark wavy hair', 'short textured cut', 'slicked back hair', 'medium length waves', 'cropped sides longer top', 'classic side part', 'natural thick curls', 'tapered cut', 'voluminous dark hair', 'swept back style'],
                hairColors: ['jet black', 'dark brown', 'deep espresso', 'warm dark brown']
            },
            'Southeast Asian': {
                skinTones: ['golden tan skin', 'warm brown skin', 'medium skin with warm undertones', 'honey-toned skin', 'light brown skin'],
                hairstyles: ['straight black hair', 'short textured crop', 'slicked back hair', 'medium wavy hair', 'undercut style', 'side-parted classic', 'soft layers', 'cropped natural style', 'tousled texture'],
                hairColors: ['jet black', 'dark brown', 'soft black', 'deep brown']
            },
            'Caribbean': {
                skinTones: ['warm brown skin', 'deep brown skin', 'golden brown skin', 'rich caramel skin', 'medium brown skin'],
                hairstyles: ['short natural curls', 'locs', 'tapered fade', 'twists', 'natural texture', 'cropped curls', 'braids', 'high top', 'defined coils', 'medium length natural hair'],
                hairColors: ['jet black', 'natural black', 'dark brown']
            },
            'Pacific Islander': {
                skinTones: ['warm tan skin', 'golden brown skin', 'medium brown skin', 'sun-kissed skin'],
                hairstyles: ['thick wavy dark hair', 'long flowing hair', 'short cropped cut', 'natural waves', 'slicked back style', 'textured medium length', 'voluminous waves'],
                hairColors: ['jet black', 'dark brown', 'deep black']
            },
            'Mixed heritage': {
                skinTones: ['warm tan skin', 'golden skin', 'light brown skin', 'medium olive skin', 'caramel skin', 'honey-toned skin'],
                hairstyles: ['loose curls', 'wavy hair', 'textured crop', 'natural curls', 'medium waves', 'defined curls', 'tousled style', 'slicked back', 'voluminous natural hair'],
                hairColors: ['dark brown', 'chestnut', 'light brown', 'auburn tones', 'honey brown', 'natural brown with highlights']
            }
        };

        const FALLBACK_POOLS = {
            faceShapes: ['oval face', 'round face', 'square jaw', 'heart-shaped face', 'diamond face', 'angular features', 'soft features', 'strong bone structure', 'delicate bone structure'],
            features: ['strong nose', 'full lips', 'sharp cheekbones', 'defined jawline', 'hooded eyes', 'wide-set eyes', 'thick natural brows', 'delicate features', 'prominent brow bone', 'high cheekbones', 'almond-shaped eyes', 'aquiline nose', 'soft rounded features', 'striking gaze']
        };

        function shuffleArray(arr) {
            const shuffled = [...arr];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        function generateFallbackPrompts(count) {
            const prompts = [];
            const genders = state.genders;
            const ages = state.ages;
            const expressions = state.expression === 'random'
                ? Object.keys(EXPRESSIONS)
                : [state.expression];

            // If user provided a specific description, use it as base
            const hasSpecificDescription = state.description && state.description.trim().length > 10;

            if (hasSpecificDescription) {
                // Use user's description with variations
                const faceShapes = shuffleArray(FALLBACK_POOLS.faceShapes);
                const features = shuffleArray(FALLBACK_POOLS.features);
                const hairstyleVariations = shuffleArray([
                    'short textured hair', 'medium wavy hair', 'slicked back hair',
                    'tousled natural hair', 'cropped cut', 'longer swept back style',
                    'classic side part', 'natural waves', 'messy textured style'
                ]);

                for (let i = 0; i < count; i++) {
                    const gender = genders[i % genders.length];
                    const age = ages[i % ages.length];
                    const expression = expressions[i % expressions.length];
                    const edginess = state.edginessRandom ? Math.random() * 100 : state.edginess;

                    const faceShape = faceShapes[i % faceShapes.length];
                    const feature = features[i % features.length];
                    const hairstyle = hairstyleVariations[i % hairstyleVariations.length];

                    // Build prompt using user's description as base
                    const prompt = `Portrait headshot of a ${gender} in their ${age}. ${state.description}. This individual has ${faceShape}, ${feature}, ${hairstyle}. ${EXPRESSIONS[expression]}. ${getEdginessPrompt(edginess)}. ${SETSET_STYLE}`;
                    prompts.push(prompt);
                }
            } else {
                // No specific description - use diverse ethnicities
                const ethnicityKeys = shuffleArray(Object.keys(ETHNICITY_DATA));
                const faceShapes = shuffleArray(FALLBACK_POOLS.faceShapes);
                const features = shuffleArray(FALLBACK_POOLS.features);

                for (let i = 0; i < count; i++) {
                    const gender = genders[i % genders.length];
                    const age = ages[i % ages.length];
                    const expression = expressions[i % expressions.length];
                    const edginess = state.edginessRandom ? Math.random() * 100 : state.edginess;

                    // Pick ethnicity and get matching attributes
                    const ethnicity = ethnicityKeys[i % ethnicityKeys.length];
                    const ethData = ETHNICITY_DATA[ethnicity];

                    const skinTone = ethData.skinTones[Math.floor(Math.random() * ethData.skinTones.length)];
                    const hairstyle = ethData.hairstyles[Math.floor(Math.random() * ethData.hairstyles.length)];
                    const hairColor = ethData.hairColors[Math.floor(Math.random() * ethData.hairColors.length)];

                    const faceShape = faceShapes[i % faceShapes.length];
                    const feature = features[i % features.length];

                    const personDesc = `${ethnicity} ${gender} in their ${age}, ${faceShape}, ${skinTone}, ${hairstyle} in ${hairColor}, ${feature}`;
                    const prompt = `Portrait headshot of a ${personDesc}. ${EXPRESSIONS[expression]}. ${getEdginessPrompt(edginess)}. ${SETSET_STYLE}`;
                    prompts.push(prompt);
                }
            }
            return prompts;
        }

        // Main generation function
        async function generateTalent() {
            if (state.generating) return;
            state.generating = true;
            state.results = [];

            const count = state.resultCount;
            const totalImages = count * state.models.length;

            // Show loader and progress
            startLoadingAnimation(`Creating ${count} unique prompts...`);
            document.getElementById('progress-section').classList.add('visible');
            document.getElementById('progress-count').textContent = `0 / ${totalImages}`;
            document.getElementById('progress-bar').style.width = '0%';
            document.getElementById('results-section').classList.remove('visible');
            document.getElementById('results-grid').innerHTML = '';

            updateUI();

            try {
                // Step 1: Generate prompts via GPT
                document.querySelector('.progress-title').textContent = 'Creating prompts...';
                const prompts = await generatePrompts(count);
                console.log(`ðŸŽ­ [Talent Creator] Generated ${prompts.length} prompts`);
                console.log('ðŸŽ­ [Talent Creator] Sample prompts:');
                prompts.slice(0, 3).forEach((p, i) => console.log(`   ${i+1}: ${p.substring(0, 150)}...`));

                // Step 2: Create placeholder cards for ALL images (prompts Ã— models)
                // Each prompt gets sent to each selected model
                const jobs = []; // { index, prompt, model }
                let resultIndex = 0;

                prompts.forEach((prompt, promptIndex) => {
                    state.models.forEach((model) => {
                        addResultPlaceholder(resultIndex, prompt);
                        state.results.push({ id: resultIndex, prompt, model, url: null, generating: true });
                        jobs.push({ index: resultIndex, prompt, model });
                        resultIndex++;
                    });
                });

                // Stop loader, show results with placeholders
                stopLoadingAnimation();
                document.getElementById('results-section').classList.add('visible');
                document.querySelector('.progress-title').textContent = 'Generating';

                // Step 3: Generate images in parallel (batches of 4)
                let completed = 0;
                const batchSize = 4;

                for (let i = 0; i < jobs.length; i += batchSize) {
                    const batch = jobs.slice(i, i + batchSize);
                    const batchPromises = batch.map(async (job) => {
                        const { index, prompt, model } = job;
                        try {
                            // Build params based on model
                            const params = {
                                model: model,
                                prompt: prompt,
                                num_images: 1
                            };

                            // Reve uses aspect_ratio string, others use image_size
                            if (model === 'reve') {
                                params.aspect_ratio = state.aspectRatio;
                            } else {
                                params.image_size = ASPECT_SIZES[state.aspectRatio] || ASPECT_SIZES['3:4'];
                            }

                            const response = await fetch('/api/generate', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(params)
                            });

                            const data = await response.json();

                            if (data.images && data.images[0]) {
                                const imageUrl = data.images[0].url;
                                state.results[index].url = imageUrl;
                                state.results[index].generating = false;
                                state.results[index].aspectRatio = state.aspectRatio;
                                updateResultCard(index, imageUrl);
                            } else {
                                throw new Error('No image returned');
                            }
                        } catch (error) {
                            console.error(`Generation ${index} failed:`, error);
                            state.results[index].error = error.message;
                            state.results[index].generating = false;
                            updateResultError(index);
                        }

                        completed++;
                        document.getElementById('progress-count').textContent = `${completed} / ${totalImages}`;
                        document.getElementById('progress-bar').style.width = `${(completed / totalImages) * 100}%`;
                    });

                    await Promise.all(batchPromises);
                }

                document.querySelector('.progress-title').textContent = 'Complete';

            } catch (error) {
                console.error('Generation error:', error);
                stopLoadingAnimation();
                alert('Failed to generate: ' + error.message);
            } finally {
                state.generating = false;
                updateUI();
            }
        }

        function addResultPlaceholder(index, prompt) {
            const grid = document.getElementById('results-grid');
            const html = `
                <div class="result-card" id="result-${index}" data-index="${index}">
                    <div class="result-placeholder">
                        <div class="spinner"></div>
                        <p>Generating...</p>
                    </div>
                </div>
            `;
            grid.insertAdjacentHTML('beforeend', html);
        }

        function updateResultCard(index, imageUrl) {
            const card = document.getElementById(`result-${index}`);
            if (!card) return;

            card.innerHTML = `
                <img src="${imageUrl}" alt="Generated talent ${index + 1}" onclick="openLightbox(${index})">
                <div class="result-overlay">
                    <div class="result-actions">
                        <button class="result-btn" onclick="event.stopPropagation(); downloadImage(${index})">Download</button>
                    </div>
                </div>
            `;
        }

        function updateResultError(index) {
            const card = document.getElementById(`result-${index}`);
            if (!card) return;

            card.innerHTML = `
                <div class="result-placeholder">
                    <p>Failed</p>
                </div>
            `;
        }

        // Lightbox functions
        function openLightbox(index) {
            state.lightboxIndex = index;
            updateLightboxContent();
            document.getElementById('lightbox').classList.add('visible');
        }

        function closeLightbox() {
            document.getElementById('lightbox').classList.remove('visible');
        }

        function navigateLightbox(direction) {
            const validResults = state.results.filter(r => r.url);
            const currentValidIndex = validResults.findIndex(r => r.id === state.lightboxIndex);
            const newValidIndex = currentValidIndex + direction;

            if (newValidIndex >= 0 && newValidIndex < validResults.length) {
                state.lightboxIndex = validResults[newValidIndex].id;
                updateLightboxContent();
            }
        }

        function updateLightboxContent() {
            const result = state.results[state.lightboxIndex];
            if (!result || !result.url) return;

            const modelNames = { 'reve': 'Reve', 'zimage': 'Z-Image' };
            document.getElementById('lightbox-image').src = result.url;
            document.getElementById('lightbox-prompt').textContent = result.prompt;
            document.getElementById('lightbox-settings').textContent = `Model: ${modelNames[result.model] || result.model || 'Reve'}\nAspect: ${result.aspectRatio || '3:4'}\nGender: ${state.genders.join(', ')}\nAge: ${state.ages.join(', ')}\nExpression: ${state.expression}`;
            document.getElementById('lightbox-download').onclick = () => downloadImage(state.lightboxIndex);
        }

        // Download functions
        async function downloadImage(index) {
            const result = state.results[index];
            if (!result || !result.url) return;

            const filename = `Setset_Talent_${String(index + 1).padStart(2, '0')}_${Date.now()}.png`;

            try {
                const response = await fetch(`/api/proxy-download?url=${encodeURIComponent(result.url)}`);
                const blob = await response.blob();
                const downloadUrl = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = downloadUrl;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(downloadUrl);
            } catch (error) {
                console.error('Download failed:', error);
                window.open(result.url, '_blank');
            }
        }

        async function downloadAll() {
            const validResults = state.results.filter(r => r.url);
            for (let i = 0; i < validResults.length; i++) {
                await downloadImage(validResults[i].id);
                await new Promise(r => setTimeout(r, 300));
            }
        }
    </script>
</body>
</html>
