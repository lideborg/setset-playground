<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video - Image to Video</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üé¨</text></svg>">
    <link rel="stylesheet" href="/shared/css/tokens.css">
    <link rel="stylesheet" href="/shared/css/base.css">
    <link rel="stylesheet" href="/shared/css/components.css">
    <style>
        .container {
            max-width: 1200px;
        }

        /* Settings section */
        .settings-section {
            background: var(--white);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-md);
            padding: var(--space-md);
            margin-bottom: var(--space-lg);
        }

        .setting-row {
            display: flex;
            align-items: center;
            gap: var(--space-lg);
            flex-wrap: wrap;
            margin-bottom: var(--space-md);
        }

        .setting-row:last-child {
            margin-bottom: 0;
        }

        .setting-group {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }

        .setting-label {
            font-size: var(--text-xs);
            font-weight: 500;
            color: var(--slate);
            min-width: 60px;
        }

        /* Model tabs */
        .model-tabs {
            display: flex;
            gap: var(--space-xs);
        }

        .model-tab {
            padding: 8px 16px;
            font-size: var(--text-sm);
            font-weight: 500;
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-sm);
            background: var(--off-white);
            color: var(--slate);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .model-tab:hover {
            border-color: var(--ash-grey);
        }

        .model-tab.active {
            background: var(--jet);
            color: var(--white);
            border-color: var(--jet);
        }

        .model-tab .model-badge {
            font-size: var(--text-2xs);
            opacity: 0.7;
            margin-left: 4px;
        }

        /* Toggle buttons */
        .toggle-buttons {
            display: flex;
            gap: 4px;
        }

        .toggle-btn {
            padding: 6px 12px;
            font-size: var(--text-xs);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-sm);
            background: var(--off-white);
            color: var(--slate);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .toggle-btn:hover {
            border-color: var(--ash-grey);
        }

        .toggle-btn.active {
            background: var(--jet);
            color: var(--white);
            border-color: var(--jet);
        }

        /* Checkbox toggle */
        .checkbox-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .checkbox-toggle input {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .checkbox-toggle span {
            font-size: var(--text-sm);
            color: var(--slate);
        }

        /* Pairs slider */
        .pairs-slider-group {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }

        .pairs-slider {
            width: 100px;
            cursor: pointer;
        }

        .pairs-value {
            font-size: var(--text-sm);
            font-weight: 600;
            color: var(--jet);
            min-width: 40px;
        }

        /* Duration slider */
        .duration-slider-group {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }

        .duration-slider {
            width: 120px;
            cursor: pointer;
        }

        .duration-value {
            font-size: var(--text-sm);
            font-weight: 600;
            color: var(--jet);
            min-width: 30px;
        }

        /* Input pairs grid */
        .pairs-container {
            margin-bottom: var(--space-lg);
        }

        .pairs-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-md);
            margin-bottom: var(--space-lg);
        }

        .pair-group {
            display: flex;
            flex-direction: column;
            gap: var(--space-sm);
        }

        .pair-frames {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-sm);
        }

        .pair-number {
            font-size: var(--text-xs);
            font-weight: 600;
            color: var(--slate);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: var(--space-xs);
        }

        /* Image upload slots */
        .frame-slot {
            aspect-ratio: 16/9;
            border: 2px dashed var(--gainsboro);
            border-radius: var(--radius-md);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            background: var(--off-white);
            transition: all var(--transition-fast);
        }

        .frame-slot:hover {
            border-color: var(--ash-grey);
            background: var(--white);
        }

        .frame-slot.filled {
            border-style: solid;
            border-color: var(--jet);
        }

        .frame-slot.filled img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .frame-slot .placeholder {
            text-align: center;
            color: var(--ash-grey);
        }

        .frame-slot .placeholder-icon {
            font-size: 24px;
            margin-bottom: 4px;
        }

        .frame-slot .placeholder-text {
            font-size: var(--text-xs);
            font-weight: 500;
        }

        .frame-slot .remove-btn {
            position: absolute;
            top: 6px;
            right: 6px;
            width: 24px;
            height: 24px;
            background: rgba(0,0,0,0.7);
            color: var(--white);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 14px;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .frame-slot.filled:hover .remove-btn {
            display: flex;
        }

        .frame-slot.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            pointer-events: none;
        }

        .frame-label {
            font-size: var(--text-2xs);
            font-weight: 500;
            color: var(--slate);
            text-align: center;
            margin-top: 4px;
        }

        /* Prompt textarea for each pair */
        .pair-prompt {
            width: 100%;
            min-height: 60px;
            padding: var(--space-xs);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-sm);
            font-family: var(--font-sans);
            font-size: var(--text-xs);
            resize: vertical;
            transition: border-color var(--transition-fast);
        }

        .pair-prompt:focus {
            outline: none;
            border-color: var(--jet);
        }

        .pair-prompt::placeholder {
            color: var(--ash-grey);
        }

        /* Generate section */
        .generate-section {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--space-lg);
        }

        .generate-btn {
            padding: 14px 32px;
            font-size: 15px;
            min-width: 180px;
        }

        .generate-info {
            font-size: var(--text-sm);
            color: var(--slate);
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Results */
        .results-section {
            display: none;
        }

        .results-section.visible {
            display: block;
        }

        .results-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--space-md);
        }

        .results-header h2 {
            font-size: var(--text-lg);
            font-weight: 600;
        }

        .videos-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: var(--space-md);
        }

        .batch-divider {
            grid-column: 1 / -1;
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            color: var(--french-gray);
            font-size: var(--text-xs);
            padding: var(--space-xs) 0;
        }

        .batch-divider::before,
        .batch-divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: var(--gainsboro);
        }

        .video-card {
            background: var(--white);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-md);
            overflow: hidden;
        }

        .video-card video {
            width: 100%;
            display: block;
            background: var(--carbon);
        }

        .video-card-footer {
            padding: var(--space-sm);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: var(--space-sm);
        }

        .video-card-info {
            flex: 1;
            overflow: hidden;
        }

        .video-card-pair {
            font-size: var(--text-2xs);
            font-weight: 600;
            color: var(--jet);
            margin-bottom: 2px;
        }

        .video-card-prompt {
            font-size: var(--text-xs);
            color: var(--slate);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .video-card-cost {
            font-size: var(--text-xs);
            color: var(--ash-grey);
            margin-left: var(--space-xs);
        }

        .video-card.generating {
            position: relative;
        }

        .video-card .generating-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--off-white);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1;
        }

        .video-card .generating-spinner {
            width: 32px;
            height: 32px;
            border: 2px solid var(--gainsboro);
            border-top-color: var(--jet);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: var(--space-xs);
        }

        .video-card .generating-text {
            font-size: var(--text-sm);
            color: var(--slate);
        }

        input[type="file"] {
            display: none;
        }

        @media (max-width: 900px) {
            .pairs-row {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="hero">
            <h1>Image to Video</h1>
            <p class="hero-subtitle">Transform images into video using Kling AI</p>
        </div>

        <!-- Settings -->
        <div class="settings-section">
            <div class="setting-row">
                <div class="setting-group">
                    <span class="setting-label">Model</span>
                    <div class="model-tabs">
                        <button class="model-tab" data-model="v1.6">v1.6 Pro <span class="model-badge">F+L</span></button>
                        <button class="model-tab" data-model="v2.6">v2.6 Pro <span class="model-badge">Audio</span></button>
                        <button class="model-tab active" data-model="v3.0">v3.0 <span class="model-badge">F+L New</span></button>
                    </div>
                </div>
                <div class="setting-group" id="v3-quality-group" style="display: flex;">
                    <span class="setting-label">Quality</span>
                    <div class="toggle-buttons" id="v3-quality-buttons">
                        <button class="toggle-btn active" data-value="pro">Pro</button>
                        <button class="toggle-btn" data-value="standard">Standard</button>
                    </div>
                </div>
            </div>

            <div class="setting-row">
                <div class="setting-group">
                    <span class="setting-label">Duration</span>
                    <div class="toggle-buttons" id="duration-buttons">
                        <button class="toggle-btn" data-value="5">5s</button>
                        <button class="toggle-btn active" data-value="10">10s</button>
                    </div>
                    <div class="duration-slider-group" id="duration-slider-v3" style="display: none;">
                        <input type="range" class="duration-slider" id="v3-duration-slider" min="3" max="15" value="5" step="1">
                        <span class="duration-value" id="v3-duration-value">5s</span>
                    </div>
                </div>

                <div class="setting-group" id="aspect-ratio-group">
                    <span class="setting-label">Aspect</span>
                    <div class="toggle-buttons" id="aspect-buttons">
                        <button class="toggle-btn active" data-value="16:9">16:9</button>
                        <button class="toggle-btn" data-value="9:16">9:16</button>
                        <button class="toggle-btn" data-value="1:1">1:1</button>
                    </div>
                </div>

                <div class="setting-group" id="audio-group" style="display: none;">
                    <label class="checkbox-toggle">
                        <input type="checkbox" id="generate-audio" checked>
                        <span>Generate Audio</span>
                    </label>
                </div>

                <div class="setting-group pairs-slider-group">
                    <span class="setting-label">Pairs</span>
                    <input type="range" class="pairs-slider" id="pairs-slider" min="1" max="3" value="1" step="1">
                    <span class="pairs-value" id="pairs-value">2</span>
                </div>

                <div class="setting-group">
                    <label class="checkbox-toggle">
                        <input type="checkbox" id="enhance-prompt">
                        <span>Enhance Prompts</span>
                    </label>
                </div>
            </div>
        </div>

        <!-- Input Pairs -->
        <div class="pairs-container" id="pairs-container">
            <!-- Dynamically generated -->
        </div>

        <!-- Generate -->
        <div class="generate-section">
            <div class="generate-info" id="generate-info">
                Upload images to generate videos
            </div>
            <button class="btn btn--primary generate-btn" id="generate-btn" disabled>
                Generate Videos
            </button>
        </div>

        <!-- Results -->
        <div class="results-section" id="results-section">
            <div class="results-header">
                <h2>Results</h2>
            </div>
            <div class="videos-grid" id="videos-grid"></div>
        </div>
    </div>

    <script src="/shared/js/utils.js"></script>
    <script src="/shared/js/api.js"></script>
    <script>
        // Logging with timestamps
        const startTime = performance.now();
        function log(message, ...args) {
            const elapsed = ((performance.now() - startTime) / 1000).toFixed(2);
            console.log(`[${elapsed}s] ${message}`, ...args);
        }

        // State
        const state = {
            model: 'v3.0',
            v3Quality: { pro: true, standard: false }, // Can select both
            duration: '5',
            aspectRatio: '16:9',
            generateAudio: false,
            enhancePrompt: false,
            numPairs: 1, // 1 = 2 pairs per row (actual pairs = numPairs * 2)
            pairs: [], // Array of { firstFrame, lastFrame, prompt }
            results: [],
            batchCounter: 0
        };

        // Initialize pairs array
        function initializePairs() {
            const totalPairs = state.numPairs * 2;
            while (state.pairs.length < totalPairs) {
                state.pairs.push({ firstFrame: null, lastFrame: null, prompt: '' });
            }
            // Trim if reduced
            state.pairs.length = totalPairs;
        }

        // Kling pricing
        function calculateVideoCost() {
            const duration = parseInt(state.duration);
            if (state.model === 'v3.0') {
                // v3.0/O3 pricing per second (audio always off for v3.0)
                // Pro: $0.224/sec, Standard: $0.084/sec
                let cost = 0;
                if (state.v3Quality.pro) cost += duration * 0.224;
                if (state.v3Quality.standard) cost += duration * 0.084;
                return cost;
            } else if (state.model === 'v2.6') {
                return duration === 5 ? 0.65 : 1.30;
            } else {
                return duration === 5 ? 0.50 : 1.00;
            }
        }

        // Get number of v3 variants selected
        function getV3VariantCount() {
            let count = 0;
            if (state.v3Quality.pro) count++;
            if (state.v3Quality.standard) count++;
            return count;
        }

        // DOM Elements
        const elements = {
            modelTabs: document.querySelectorAll('.model-tab'),
            durationButtons: document.getElementById('duration-buttons'),
            durationSliderV3: document.getElementById('duration-slider-v3'),
            v3DurationSlider: document.getElementById('v3-duration-slider'),
            v3DurationValue: document.getElementById('v3-duration-value'),
            v3QualityGroup: document.getElementById('v3-quality-group'),
            v3QualityButtons: document.getElementById('v3-quality-buttons'),
            aspectButtons: document.querySelectorAll('#aspect-buttons .toggle-btn'),
            aspectGroup: document.getElementById('aspect-ratio-group'),
            audioGroup: document.getElementById('audio-group'),
            generateAudio: document.getElementById('generate-audio'),
            pairsSlider: document.getElementById('pairs-slider'),
            pairsValue: document.getElementById('pairs-value'),
            enhancePrompt: document.getElementById('enhance-prompt'),
            pairsContainer: document.getElementById('pairs-container'),
            generateBtn: document.getElementById('generate-btn'),
            generateInfo: document.getElementById('generate-info'),
            resultsSection: document.getElementById('results-section'),
            videosGrid: document.getElementById('videos-grid')
        };

        // Initialize
        function init() {
            initializePairs();
            setupEventListeners();
            renderPairs();
            updateUI();
        }

        function setupEventListeners() {
            // Model tabs
            elements.modelTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    elements.modelTabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    state.model = tab.dataset.model;
                    updateUI();
                    renderPairs();
                });
            });

            // Duration buttons (v1.6 and v2.6)
            elements.durationButtons.querySelectorAll('.toggle-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    elements.durationButtons.querySelectorAll('.toggle-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.duration = btn.dataset.value;
                    updateUI();
                });
            });

            // Duration slider (v3.0)
            elements.v3DurationSlider.addEventListener('input', () => {
                state.duration = elements.v3DurationSlider.value;
                elements.v3DurationValue.textContent = `${state.duration}s`;
                updateUI();
            });

            // V3 quality buttons (multi-select)
            elements.v3QualityButtons.querySelectorAll('.toggle-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const quality = btn.dataset.value;
                    state.v3Quality[quality] = !state.v3Quality[quality];
                    btn.classList.toggle('active', state.v3Quality[quality]);
                    // Ensure at least one is selected
                    if (!state.v3Quality.pro && !state.v3Quality.standard) {
                        state.v3Quality[quality] = true;
                        btn.classList.add('active');
                    }
                    updateUI();
                });
            });

            // Aspect ratio buttons
            elements.aspectButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    elements.aspectButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.aspectRatio = btn.dataset.value;
                });
            });

            // Audio toggle
            elements.generateAudio.addEventListener('change', () => {
                state.generateAudio = elements.generateAudio.checked;
            });

            // Pairs slider
            elements.pairsSlider.addEventListener('input', () => {
                state.numPairs = parseInt(elements.pairsSlider.value);
                elements.pairsValue.textContent = state.numPairs * 2;
                initializePairs();
                renderPairs();
                updateUI();
            });

            // Enhance prompt toggle
            elements.enhancePrompt.addEventListener('change', () => {
                state.enhancePrompt = elements.enhancePrompt.checked;
                log(`Enhance prompts: ${state.enhancePrompt ? 'enabled' : 'disabled'}`);
            });

            // Generate button
            elements.generateBtn.addEventListener('click', handleGenerate);

            // Global paste handler
            document.addEventListener('paste', handlePaste);
        }

        function handlePaste(e) {
            const items = e.clipboardData?.items;
            if (!items) return;

            for (const item of items) {
                if (item.type.startsWith('image/')) {
                    e.preventDefault();
                    const file = item.getAsFile();
                    if (file) {
                        // Find first empty slot
                        for (let i = 0; i < state.pairs.length; i++) {
                            if (!state.pairs[i].firstFrame) {
                                handleFileUpload(file, i, 'first');
                                log(`üìã Pasted image to pair ${i + 1} first frame`);
                                return;
                            }
                            const supportsLastFrame = state.model === 'v1.6' || state.model === 'v3.0';
                            if (supportsLastFrame && !state.pairs[i].lastFrame) {
                                handleFileUpload(file, i, 'last');
                                log(`üìã Pasted image to pair ${i + 1} last frame`);
                                return;
                            }
                        }
                    }
                    break;
                }
            }
        }

        function renderPairs() {
            const totalPairs = state.numPairs * 2;
            const supportsLastFrame = state.model === 'v1.6' || state.model === 'v3.0';

            let html = '';
            for (let row = 0; row < state.numPairs; row++) {
                html += '<div class="pairs-row">';
                for (let col = 0; col < 2; col++) {
                    const pairIndex = row * 2 + col;
                    const pair = state.pairs[pairIndex] || { firstFrame: null, lastFrame: null, prompt: '' };

                    html += `
                        <div class="pair-group" data-pair="${pairIndex}">
                            <div class="pair-number">Video ${pairIndex + 1}</div>
                            <div class="pair-frames">
                                <div class="frame-wrapper">
                                    <div class="frame-slot ${pair.firstFrame ? 'filled' : ''}"
                                         data-pair="${pairIndex}" data-type="first">
                                        ${pair.firstFrame ? `
                                            <img src="${pair.firstFrame.url}" alt="First frame">
                                            <button class="remove-btn">&times;</button>
                                        ` : `
                                            <div class="placeholder">
                                                <div class="placeholder-icon">üñºÔ∏è</div>
                                                <div class="placeholder-text">First Frame</div>
                                            </div>
                                        `}
                                    </div>
                                    <div class="frame-label">First</div>
                                </div>
                                <div class="frame-wrapper">
                                    <div class="frame-slot ${pair.lastFrame ? 'filled' : ''} ${!supportsLastFrame ? 'disabled' : ''}"
                                         data-pair="${pairIndex}" data-type="last">
                                        ${pair.lastFrame ? `
                                            <img src="${pair.lastFrame.url}" alt="Last frame">
                                            <button class="remove-btn">&times;</button>
                                        ` : `
                                            <div class="placeholder">
                                                <div class="placeholder-icon">üé¨</div>
                                                <div class="placeholder-text">Last Frame</div>
                                            </div>
                                        `}
                                    </div>
                                    <div class="frame-label">Last ${!supportsLastFrame ? '(v1.6/v3.0)' : ''}</div>
                                </div>
                            </div>
                            <textarea class="pair-prompt" data-pair="${pairIndex}"
                                placeholder="Describe the motion... (e.g., slowly turns head and smiles)">${pair.prompt}</textarea>
                            <input type="file" class="file-input" data-pair="${pairIndex}" accept="image/*">
                        </div>
                    `;
                }
                html += '</div>';
            }

            elements.pairsContainer.innerHTML = html;

            // Attach event listeners to new elements
            document.querySelectorAll('.frame-slot').forEach(slot => {
                const pairIndex = parseInt(slot.dataset.pair);
                const type = slot.dataset.type;

                slot.addEventListener('click', (e) => {
                    if (e.target.classList.contains('remove-btn')) {
                        state.pairs[pairIndex][type === 'first' ? 'firstFrame' : 'lastFrame'] = null;
                        renderPairs();
                        updateUI();
                    } else if (!slot.classList.contains('disabled') && !slot.classList.contains('filled')) {
                        const input = document.querySelector(`.file-input[data-pair="${pairIndex}"]`);
                        input.dataset.targetType = type;
                        input.click();
                    }
                });

                // Drag and drop
                slot.addEventListener('dragover', (e) => e.preventDefault());
                slot.addEventListener('drop', (e) => {
                    e.preventDefault();
                    if (slot.classList.contains('disabled')) return;
                    const file = e.dataTransfer.files[0];
                    if (file && file.type.startsWith('image/')) {
                        handleFileUpload(file, pairIndex, type);
                    }
                });
            });

            // File input handlers
            document.querySelectorAll('.file-input').forEach(input => {
                input.addEventListener('change', (e) => {
                    const pairIndex = parseInt(input.dataset.pair);
                    const type = input.dataset.targetType || 'first';
                    handleFileUpload(e.target.files[0], pairIndex, type);
                    e.target.value = '';
                });
            });

            // Prompt textarea handlers
            document.querySelectorAll('.pair-prompt').forEach(textarea => {
                textarea.addEventListener('input', (e) => {
                    const pairIndex = parseInt(textarea.dataset.pair);
                    state.pairs[pairIndex].prompt = e.target.value;
                    updateUI();
                });
            });
        }

        // Compress image
        async function compressImage(dataUrl, maxSizeBytes = 9 * 1024 * 1024) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    let width = img.width;
                    let height = img.height;

                    const maxDimension = 2048;
                    if (width > maxDimension || height > maxDimension) {
                        const scale = maxDimension / Math.max(width, height);
                        width = Math.round(width * scale);
                        height = Math.round(height * scale);
                    }

                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);

                    let quality = 0.92;
                    let result = canvas.toDataURL('image/jpeg', quality);

                    while (result.length > maxSizeBytes * 1.37 && quality > 0.3) {
                        quality -= 0.1;
                        result = canvas.toDataURL('image/jpeg', quality);
                    }

                    log(`üì¶ Compressed image: ${(result.length / 1024 / 1024).toFixed(2)}MB at quality ${quality.toFixed(1)}`);
                    resolve(result);
                };
                img.src = dataUrl;
            });
        }

        async function handleFileUpload(file, pairIndex, type) {
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                let dataUrl = e.target.result;

                if (dataUrl.length > 8 * 1024 * 1024) {
                    log(`üîÑ Image too large (${(dataUrl.length / 1024 / 1024).toFixed(2)}MB), compressing...`);
                    dataUrl = await compressImage(dataUrl);
                }

                if (type === 'first') {
                    state.pairs[pairIndex].firstFrame = { file, url: dataUrl };
                } else {
                    state.pairs[pairIndex].lastFrame = { file, url: dataUrl };
                }

                log(`üì∑ Uploaded ${type} frame for pair ${pairIndex + 1}`);
                renderPairs();
                updateUI();
            };
            reader.readAsDataURL(file);
        }

        function updateUI() {
            const isV16 = state.model === 'v1.6';
            const isV30 = state.model === 'v3.0';
            const supportsLastFrame = isV16 || isV30;

            // Show/hide model-specific options
            elements.aspectGroup.style.display = (isV16 || isV30) ? 'flex' : 'none';
            elements.audioGroup.style.display = state.model === 'v2.6' ? 'flex' : 'none'; // Only v2.6 has audio
            elements.v3QualityGroup.style.display = isV30 ? 'flex' : 'none';

            // Show correct duration controls
            elements.durationButtons.style.display = isV30 ? 'none' : 'flex';
            elements.durationSliderV3.style.display = isV30 ? 'flex' : 'none';

            // Count valid pairs (has at least first frame)
            const validPairs = state.pairs.filter(p => p.firstFrame);
            const pairsWithPrompt = validPairs.filter(p => p.prompt.trim());

            elements.generateBtn.disabled = validPairs.length === 0;

            if (validPairs.length === 0) {
                elements.generateInfo.textContent = 'Upload images to generate videos';
            } else {
                let modelInfo;
                if (isV30) {
                    const variants = [];
                    if (state.v3Quality.pro) variants.push('Pro');
                    if (state.v3Quality.standard) variants.push('Std');
                    modelInfo = `v3.0 ${variants.join('+')}`;
                } else {
                    modelInfo = isV16 ? 'v1.6 Pro' : 'v2.6 Pro';
                }
                const costPerVideo = calculateVideoCost();
                const variantCount = isV30 ? getV3VariantCount() : 1;
                const totalVideos = validPairs.length * variantCount;
                const totalCost = (costPerVideo * validPairs.length).toFixed(2);
                const enhanceNote = state.enhancePrompt ? ' ‚Ä¢ Enhanced' : '';
                elements.generateInfo.textContent = `${modelInfo} ‚Ä¢ ${state.duration}s ‚Ä¢ ${totalVideos} video${totalVideos > 1 ? 's' : ''}${enhanceNote} ‚Ä¢ $${totalCost}`;
            }
        }

        // Analyze image with Gemini for prompt enhancement
        async function analyzeImageWithGemini(imageUrl, type) {
            log(`üîç Analyzing ${type} image with Gemini...`);
            const analyzeStart = performance.now();

            const analysisPrompt = type === 'first'
                ? `Briefly describe this image for video generation context. Focus on:
                   - Subject (person, object, scene)
                   - Current pose/position
                   - Setting/environment (2-3 key elements)
                   - Mood/atmosphere
                   Keep it under 50 words.`
                : `Briefly describe the target state in this image for video transition. Focus on:
                   - Final pose/position
                   - Key differences from a starting frame
                   - Movement endpoint
                   Keep it under 30 words.`;

            try {
                const response = await fetch('/api/analyze-gemini', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        image_url: imageUrl,
                        prompt: analysisPrompt
                    })
                });

                const data = await response.json();
                const elapsed = ((performance.now() - analyzeStart) / 1000).toFixed(2);
                log(`‚úÖ ${type} image analysis complete (${elapsed}s):`, data.content?.substring(0, 100) + '...');
                return data.content || '';
            } catch (error) {
                log(`‚ùå ${type} image analysis failed:`, error.message);
                return '';
            }
        }

        // Enhance prompt using Gemini
        async function enhancePromptWithGemini(userPrompt, firstAnalysis, lastAnalysis, imageUrl) {
            log(`‚ú® Enhancing prompt with Gemini...`);
            const enhanceStart = performance.now();

            const enhancePromptText = `You are helping create a prompt for Kling 1.6 AI video generation (image-to-video).

CONTEXT:
- First frame: ${firstAnalysis || 'Not analyzed'}
- Last frame: ${lastAnalysis || 'Not provided'}
- User's motion description: "${userPrompt || 'Subtle natural movement'}"

KLING 1.6 BEST PRACTICES:
- Focus ONLY on motion/movement - never describe what's already in the image
- Use single, simple actions (1-3 movements max)
- Include one camera movement if appropriate (tracking shot, slow zoom, static)
- Add motion endpoint ("then settles", "comes to rest")
- Keep it under 40 words
- Use natural language, not keyword spam

Write an enhanced prompt that describes the motion to transition from first to last frame (or create natural movement if no last frame). Return ONLY the prompt text, nothing else.`;

            try {
                const response = await fetch('/api/analyze-gemini', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        image_url: imageUrl,
                        prompt: enhancePromptText
                    })
                });

                const data = await response.json();
                let enhanced = data.content || userPrompt || 'Subtle natural movement and gentle motion';

                // Clean up quotes if present
                if ((enhanced.startsWith('"') && enhanced.endsWith('"')) ||
                    (enhanced.startsWith("'") && enhanced.endsWith("'"))) {
                    enhanced = enhanced.slice(1, -1);
                }

                const elapsed = ((performance.now() - enhanceStart) / 1000).toFixed(2);
                log(`‚úÖ Prompt enhanced (${elapsed}s):`, enhanced);
                return enhanced;
            } catch (error) {
                log(`‚ùå Prompt enhancement failed:`, error.message);
                return userPrompt || 'Subtle natural movement and gentle motion';
            }
        }

        async function handleGenerate() {
            const validPairs = state.pairs
                .map((p, i) => ({ ...p, index: i }))
                .filter(p => p.firstFrame);

            if (validPairs.length === 0) return;

            log(`üöÄ Starting generation for ${validPairs.length} video(s)`);
            const totalStart = performance.now();

            state.batchCounter++;
            const currentBatch = state.batchCounter;
            elements.generateBtn.disabled = true;

            const costPerVideo = calculateVideoCost();

            // Show results section
            elements.resultsSection.classList.add('visible');

            // Create batch divider
            const now = new Date();
            const timeStr = now.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
            const batchDivider = document.createElement('div');
            batchDivider.className = 'batch-divider';
            batchDivider.id = `batch-divider-${currentBatch}`;
            batchDivider.textContent = `Batch ${currentBatch} ‚Ä¢ ${timeStr}`;

            // Build list of models to generate
            let modelsToGenerate = [];
            if (state.model === 'v3.0') {
                if (state.v3Quality.pro) modelsToGenerate.push('v3.0-pro');
                if (state.v3Quality.standard) modelsToGenerate.push('v3.0-standard');
            } else {
                modelsToGenerate.push(state.model);
            }

            // Build tasks: each pair √ó each model variant
            const tasks = [];
            validPairs.forEach(pair => {
                modelsToGenerate.forEach(model => {
                    tasks.push({ pair, model, variantLabel: model.replace('v3.0-', '').toUpperCase() });
                });
            });

            // Create placeholder cards for all tasks
            const placeholderCards = tasks.map((task, i) => {
                const card = document.createElement('div');
                card.className = 'video-card generating';
                card.id = `video-card-${currentBatch}-${task.pair.index}-${task.model}`;
                const isV3 = task.model.startsWith('v3.0');
                const variantTag = isV3 ? ` <span style="opacity:0.6">(${task.variantLabel})</span>` : '';
                const perVideoCost = isV3
                    ? (task.model === 'v3.0-pro' ? 0.224 : 0.084) * parseInt(state.duration)
                    : costPerVideo;
                card.innerHTML = `
                    <div class="generating-overlay">
                        <div class="generating-spinner"></div>
                        <div class="generating-text">Preparing...</div>
                    </div>
                    <video style="aspect-ratio: 16/9;"></video>
                    <div class="video-card-footer">
                        <div class="video-card-info">
                            <div class="video-card-pair">Video ${task.pair.index + 1}${variantTag}</div>
                            <span class="video-card-prompt" title="${task.pair.prompt || 'Auto motion'}">${task.pair.prompt || 'Auto motion'}</span>
                        </div>
                        <span class="video-card-cost">$${perVideoCost.toFixed(2)}</span>
                        <button class="btn btn--sm" disabled>Download</button>
                    </div>
                `;
                return card;
            });

            // Insert batch divider and cards at the beginning
            const firstChild = elements.videosGrid.firstChild;
            placeholderCards.reverse().forEach(card => {
                elements.videosGrid.insertBefore(card, firstChild);
            });
            elements.videosGrid.insertBefore(batchDivider, firstChild);

            // Process all tasks in parallel
            const generatePromises = tasks.map(async (task) => {
                const { pair, model, variantLabel } = task;
                const pairStart = performance.now();
                const card = document.getElementById(`video-card-${currentBatch}-${pair.index}-${model}`);
                const statusText = card?.querySelector('.generating-text');

                try {
                    // Step 1: Upload images
                    if (statusText) statusText.textContent = 'Uploading...';
                    log(`[Video ${pair.index + 1}] Uploading first frame...`);

                    const uploadStart = performance.now();
                    const firstFrameResult = await api.uploadBase64(pair.firstFrame.url);
                    const imageUrl = firstFrameResult.url;

                    let tailImageUrl = null;
                    const supportsLastFrame = state.model === 'v1.6' || state.model === 'v3.0';
                    if (supportsLastFrame && pair.lastFrame) {
                        log(`[Video ${pair.index + 1}] Uploading last frame...`);
                        const lastFrameResult = await api.uploadBase64(pair.lastFrame.url);
                        tailImageUrl = lastFrameResult.url;
                    }

                    const uploadElapsed = ((performance.now() - uploadStart) / 1000).toFixed(2);
                    log(`[Video ${pair.index + 1}] Uploads complete (${uploadElapsed}s)`);

                    // Step 2: Enhance prompt if enabled
                    let finalPrompt = pair.prompt.trim() || 'Subtle natural movement and gentle motion';

                    if (state.enhancePrompt) {
                        if (statusText) statusText.textContent = 'Analyzing...';

                        // Analyze images in parallel
                        const [firstAnalysis, lastAnalysis] = await Promise.all([
                            analyzeImageWithGemini(imageUrl, 'first'),
                            tailImageUrl ? analyzeImageWithGemini(tailImageUrl, 'last') : Promise.resolve('')
                        ]);

                        if (statusText) statusText.textContent = 'Enhancing prompt...';
                        finalPrompt = await enhancePromptWithGemini(pair.prompt, firstAnalysis, lastAnalysis, imageUrl);

                        // Update the card prompt display
                        const promptSpan = card?.querySelector('.video-card-prompt');
                        if (promptSpan) {
                            promptSpan.textContent = finalPrompt;
                            promptSpan.title = finalPrompt;
                        }
                    }

                    // Step 3: Generate video
                    if (statusText) statusText.textContent = 'Generating...';
                    const variantInfo = model.startsWith('v3.0') ? ` [${variantLabel}]` : '';
                    log(`[Video ${pair.index + 1}${variantInfo}] Starting video generation with prompt: "${finalPrompt.substring(0, 60)}..."`);

                    const genStart = performance.now();

                    const params = {
                        model: model,
                        image_url: imageUrl,
                        prompt: finalPrompt,
                        duration: state.duration,
                        falKey: api.getFalKey()
                    };

                    if (model === 'v1.6') {
                        if (tailImageUrl) params.tail_image_url = tailImageUrl;
                        params.aspect_ratio = state.aspectRatio;
                    } else if (model.startsWith('v3.0')) {
                        if (tailImageUrl) params.tail_image_url = tailImageUrl;
                        params.aspect_ratio = state.aspectRatio;
                        params.generate_audio = false; // Always off for v3.0
                    } else {
                        params.generate_audio = state.generateAudio;
                    }

                    const response = await fetch('/api/video', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(params)
                    });

                    const data = await response.json();

                    if (!response.ok) {
                        throw new Error(data.error || 'Video generation failed');
                    }

                    const videoUrl = data.video?.url || data.url;
                    const genElapsed = ((performance.now() - genStart) / 1000).toFixed(2);
                    const totalElapsed = ((performance.now() - pairStart) / 1000).toFixed(2);

                    log(`[Video ${pair.index + 1}${variantInfo}] ‚úÖ Generation complete (gen: ${genElapsed}s, total: ${totalElapsed}s)`);

                    if (videoUrl && card) {
                        card.classList.remove('generating');
                        const overlay = card.querySelector('.generating-overlay');
                        if (overlay) overlay.remove();

                        const video = card.querySelector('video');
                        video.src = videoUrl;
                        video.controls = true;
                        video.loop = true;

                        const downloadBtn = card.querySelector('.btn');
                        downloadBtn.disabled = false;
                        downloadBtn.onclick = () => {
                            const now = new Date();
                            const timestamp = `${now.getFullYear()}${String(now.getMonth()+1).padStart(2,'0')}${String(now.getDate()).padStart(2,'0')}_${String(now.getHours()).padStart(2,'0')}${String(now.getMinutes()).padStart(2,'0')}`;
                            const variantSuffix = model.startsWith('v3.0') ? `_${variantLabel}` : '';
                            downloadFile(videoUrl, `Setset_Video_${timestamp}_${pair.index + 1}${variantSuffix}.mp4`);
                        };

                        state.results.push({ url: videoUrl, prompt: finalPrompt, pairIndex: pair.index });
                    }

                } catch (error) {
                    const totalElapsed = ((performance.now() - pairStart) / 1000).toFixed(2);
                    const variantInfo = model.startsWith('v3.0') ? ` [${variantLabel}]` : '';
                    log(`[Video ${pair.index + 1}${variantInfo}] ‚ùå Failed after ${totalElapsed}s:`, error.message);

                    if (card) {
                        card.classList.remove('generating');
                        const overlay = card.querySelector('.generating-overlay');
                        if (overlay) {
                            overlay.innerHTML = `<div class="generating-text" style="color: #dc2626;">Failed: ${error.message}</div>`;
                        }
                    }
                }
            });

            await Promise.all(generatePromises);

            const totalElapsed = ((performance.now() - totalStart) / 1000).toFixed(2);
            log(`üèÅ All generations complete! Total time: ${totalElapsed}s, Success: ${state.results.length}/${tasks.length}`);

            elements.generateBtn.disabled = false;
        }

        // Initialize
        init();
    </script>
</body>
</html>
