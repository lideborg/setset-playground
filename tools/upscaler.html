<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Upscaler</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üîç</text></svg>">
    <link rel="stylesheet" href="/shared/css/tokens.css">
    <link rel="stylesheet" href="/shared/css/base.css">
    <link rel="stylesheet" href="/shared/css/components.css">
    <style>
        /* Upload Grid - 6x2 grid matching batch-remix style */
        .upload-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 4px;
            padding: 6px;
            border: 2px dashed var(--gainsboro);
            border-radius: var(--radius-sm);
            background: var(--white);
            margin-bottom: var(--space-md);
        }

        .upload-grid.drag-over {
            border-color: var(--jet);
        }

        .upload-slot {
            aspect-ratio: 3/4;
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-xs);
            cursor: pointer;
            position: relative;
            overflow: hidden;
            background: var(--off-white);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: var(--gainsboro);
        }

        .upload-slot:hover {
            border-color: var(--jet);
        }

        .upload-slot.filled {
            border-color: var(--jet);
            background: var(--white);
        }

        .upload-slot img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .upload-slot .remove-btn {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 12px;
            height: 12px;
            background: rgba(0, 0, 0, 0.7);
            color: var(--white);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 8px;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .upload-slot.filled:hover .remove-btn {
            display: flex;
        }

        .upload-slot.paste-ready {
            border-color: #2563eb;
            border-width: 2px;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.3);
        }

        /* Inline loader styles are in /shared/css/components.css */

        /* Results Grid */
        .results-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: var(--space-sm);
        }

        .result-card {
            background: white;
            border-radius: var(--radius-md);
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            cursor: pointer;
        }

        .result-card img {
            width: 100%;
            display: block;
        }

        .result-card .result-info {
            padding: var(--space-sm);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .result-card .result-meta {
            font-size: var(--text-xs);
            color: var(--slate);
        }

        .result-card .result-mode {
            font-size: var(--text-xs);
            font-weight: 600;
            color: var(--jet);
            text-transform: uppercase;
        }

        .result-card .download-btn {
            padding: var(--space-2xs) var(--space-sm);
            background: var(--off-white);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-sm);
            font-size: var(--text-xs);
            cursor: pointer;
        }

        .result-card .download-btn:hover {
            background: var(--gainsboro);
        }

        /* Settings */
        .settings-row {
            display: flex;
            gap: var(--space-md);
            flex-wrap: wrap;
            margin-bottom: var(--space-sm);
        }

        .setting-group {
            display: flex;
            flex-direction: column;
            gap: var(--space-2xs);
        }

        .setting-group.flex-1 {
            flex: 1;
        }

        .setting-label {
            font-size: var(--text-xs);
            color: var(--slate);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Slider */
        .slider-row {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }

        .slider-row input[type="range"] {
            flex: 1;
        }

        .slider-row .slider-value {
            min-width: 30px;
            text-align: center;
            font-size: var(--text-sm);
            font-weight: 500;
        }

        /* Checkbox group */
        .checkbox-group {
            display: flex;
            gap: var(--space-md);
            flex-wrap: wrap;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: var(--space-xs);
            cursor: pointer;
        }

        .checkbox-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .checkbox-item label {
            font-size: var(--text-sm);
            cursor: pointer;
        }

        .checkbox-item .mode-desc {
            font-size: var(--text-xs);
            color: var(--slate);
            display: block;
        }

        /* Mode-specific settings */
        .mode-specific-settings {
            margin-top: var(--space-sm);
            padding: var(--space-sm);
            background: var(--off-white);
            border-radius: var(--radius-sm);
            display: none;
        }

        .mode-specific-settings.visible {
            display: block;
        }

        .mode-specific-settings h4 {
            font-size: var(--text-xs);
            text-transform: uppercase;
            color: var(--slate);
            margin-bottom: var(--space-xs);
        }

        /* Generate section */
        .generate-section {
            padding-top: var(--space-sm);
            border-top: 1px solid var(--gainsboro);
            margin-top: var(--space-sm);
        }

        .calc-display {
            font-size: var(--text-sm);
            color: var(--slate);
            margin-bottom: var(--space-xs);
            text-align: center;
        }

        /* Result group headers */
        .result-group {
            margin-bottom: var(--space-lg);
        }

        .result-group-header {
            font-size: var(--text-sm);
            font-weight: 600;
            color: var(--jet);
            margin-bottom: var(--space-sm);
            padding-bottom: var(--space-xs);
            border-bottom: 1px solid var(--gainsboro);
        }

        /* Comparison Slider */
        .comparison-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            border-radius: var(--radius-md);
            cursor: ew-resize;
            user-select: none;
        }

        .comparison-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .comparison-image img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .comparison-original {
            z-index: 1;
            clip-path: inset(0 0 0 50%);
        }

        .comparison-enhanced {
            z-index: 0;
        }

        .comparison-label {
            position: absolute;
            top: 16px;
            padding: 4px 12px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 12px;
            font-weight: 500;
            border-radius: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            pointer-events: none;
        }

        .comparison-label-left {
            left: 16px;
        }

        .comparison-label-right {
            right: 16px;
        }

        .comparison-slider {
            position: absolute;
            top: 0;
            bottom: 0;
            left: 50%;
            width: 4px;
            z-index: 10;
            transform: translateX(-50%);
        }

        .comparison-slider-line {
            position: absolute;
            top: 0;
            bottom: 0;
            left: 50%;
            width: 2px;
            background: white;
            transform: translateX(-50%);
            box-shadow: 0 0 4px rgba(0, 0, 0, 0.5);
        }

        .comparison-slider-handle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: ew-resize;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }

        .comparison-slider-handle svg {
            width: 32px;
            height: 32px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="hero">
            <a href="/" style="text-decoration: none; color: inherit;"><h1>Upscaler</h1></a>
            <p class="hero-subtitle">Upscale images or enhance skin using Freepik AI</p>
        </div>

        <!-- Mode Toggle -->
        <div class="section-label">Mode</div>
        <div class="btn-group" id="mode-buttons" style="margin-bottom: var(--space-md);">
            <button class="btn btn--toggle active" data-mode="upscale">Upscale (Magnific)</button>
            <button class="btn btn--toggle" data-mode="skin-enhance">Skin Enhance</button>
        </div>

        <!-- Upload Grid -->
        <div class="section-label">Images</div>
        <div class="upload-grid" id="upload-grid"></div>

        <!-- Upscale Settings -->
        <div class="settings-section" id="upscale-settings">
            <div class="settings-row">
                <div class="setting-group">
                    <label class="setting-label">Scale Factor</label>
                    <div class="btn-group" id="scale-buttons">
                        <button class="btn btn--toggle active" data-scale="2x">2x</button>
                        <button class="btn btn--toggle" data-scale="4x">4x</button>
                        <button class="btn btn--toggle" data-scale="8x">8x</button>
                        <button class="btn btn--toggle" data-scale="16x">16x</button>
                    </div>
                </div>

                <div class="setting-group">
                    <label class="setting-label">Engine</label>
                    <div class="btn-group" id="engine-buttons">
                        <button class="btn btn--toggle active" data-engine="automatic">Auto</button>
                        <button class="btn btn--toggle" data-engine="magnific_illusio">Illusio</button>
                        <button class="btn btn--toggle" data-engine="magnific_sharpy">Sharpy</button>
                        <button class="btn btn--toggle" data-engine="magnific_sparkle">Sparkle</button>
                    </div>
                </div>
            </div>

            <div class="settings-row">
                <div class="setting-group flex-1">
                    <label class="setting-label">Optimized For</label>
                    <div class="btn-group" id="optimized-buttons">
                        <button class="btn btn--toggle active" data-opt="standard">Standard</button>
                        <button class="btn btn--toggle" data-opt="soft_portraits">Portraits (Soft)</button>
                        <button class="btn btn--toggle" data-opt="hard_portraits">Portraits (Sharp)</button>
                        <button class="btn btn--toggle" data-opt="films_n_photography">Photography</button>
                        <button class="btn btn--toggle" data-opt="art_n_illustration">Art</button>
                    </div>
                </div>
            </div>

            <div class="settings-row">
                <div class="setting-group">
                    <label class="setting-label">Creativity (-10 to 10)</label>
                    <div class="slider-row">
                        <input type="range" id="creativity-slider" min="-10" max="10" value="0">
                        <span class="slider-value" id="creativity-value">0</span>
                    </div>
                </div>

                <div class="setting-group">
                    <label class="setting-label">HDR / Detail (-10 to 10)</label>
                    <div class="slider-row">
                        <input type="range" id="hdr-slider" min="-10" max="10" value="0">
                        <span class="slider-value" id="hdr-value">0</span>
                    </div>
                </div>

                <div class="setting-group">
                    <label class="setting-label">Resemblance (-10 to 10)</label>
                    <div class="slider-row">
                        <input type="range" id="resemblance-slider" min="-10" max="10" value="0">
                        <span class="slider-value" id="resemblance-value">0</span>
                    </div>
                </div>
            </div>

            <div class="settings-row">
                <div class="setting-group flex-1">
                    <label class="setting-label">Prompt (optional - guides upscaling)</label>
                    <div style="display: flex; gap: var(--space-sm); align-items: center;">
                        <input type="text" class="input" id="prompt-input" placeholder="e.g., high fashion portrait, detailed skin texture..." style="flex: 1;">
                        <label class="analyze-toggle" style="display: flex; align-items: center; gap: 6px; cursor: pointer; white-space: nowrap;">
                            <input type="checkbox" id="auto-analyze-toggle" style="width: 16px; height: 16px;">
                            <span style="font-size: var(--text-sm);">Auto-analyze</span>
                        </label>
                    </div>
                    <p id="analyze-hint" style="font-size: var(--text-xs); color: var(--slate); margin-top: 4px; display: none;">
                        Will analyze each image and use the description as the prompt
                    </p>
                </div>
            </div>

            <div class="settings-row">
                <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                    <input type="checkbox" id="keep-filenames" style="width: 16px; height: 16px;">
                    <span style="font-size: var(--text-sm);">Keep filenames</span>
                    <span style="font-size: var(--text-xs); color: var(--slate);">(saves as x2_originalname.png)</span>
                </label>
            </div>
        </div>

        <!-- Skin Enhance Settings -->
        <div class="settings-section" id="skin-enhance-settings" style="display: none;">
            <!-- Mode Selection (can select multiple) -->
            <div class="settings-row">
                <div class="setting-group flex-1">
                    <label class="setting-label">Enhancement Modes (select one or more to compare)</label>
                    <div class="checkbox-group" id="skin-mode-checkboxes">
                        <div class="checkbox-item">
                            <input type="checkbox" id="mode-creative" value="creative" checked>
                            <label for="mode-creative">
                                Creative
                                <span class="mode-desc">Artistic, stylized enhancements</span>
                            </label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="mode-faithful" value="faithful">
                            <label for="mode-faithful">
                                Faithful
                                <span class="mode-desc">Natural look with skin detail control</span>
                            </label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="mode-flexible" value="flexible">
                            <label for="mode-flexible">
                                Flexible
                                <span class="mode-desc">Multiple optimization targets</span>
                            </label>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Common Settings -->
            <div class="settings-row">
                <div class="setting-group">
                    <label class="setting-label">Sharpen (0-100)</label>
                    <div class="slider-row">
                        <input type="range" id="sharpen-slider" min="0" max="100" value="0">
                        <span class="slider-value" id="sharpen-value">0</span>
                    </div>
                </div>

                <div class="setting-group">
                    <label class="setting-label">Smart Grain (0-100)</label>
                    <div class="slider-row">
                        <input type="range" id="grain-slider" min="0" max="100" value="2">
                        <span class="slider-value" id="grain-value">2</span>
                    </div>
                </div>
            </div>

            <!-- Faithful Mode Settings -->
            <div class="mode-specific-settings" id="faithful-settings">
                <h4>Faithful Mode Settings</h4>
                <div class="setting-group">
                    <label class="setting-label">Skin Detail (0-100)</label>
                    <div class="slider-row">
                        <input type="range" id="skin-detail-slider" min="0" max="100" value="80">
                        <span class="slider-value" id="skin-detail-value">80</span>
                    </div>
                </div>
            </div>

            <!-- Flexible Mode Settings -->
            <div class="mode-specific-settings" id="flexible-settings">
                <h4>Flexible Mode Settings</h4>
                <div class="setting-group">
                    <label class="setting-label">Optimized For (select multiple to compare)</label>
                    <div class="checkbox-group" id="flexible-optimized-checkboxes">
                        <div class="checkbox-item">
                            <input type="checkbox" id="flexopt-skin" value="enhance_skin" checked>
                            <label for="flexopt-skin">Skin</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="flexopt-lighting" value="improve_lighting">
                            <label for="flexopt-lighting">Lighting</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="flexopt-everything" value="enhance_everything">
                            <label for="flexopt-everything">Everything</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="flexopt-real" value="transform_to_real">
                            <label for="flexopt-real">To Real</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="flexopt-nomakeup" value="no_make_up">
                            <label for="flexopt-nomakeup">No Makeup</label>
                        </div>
                    </div>
                </div>
            </div>

            <p style="font-size: var(--text-xs); color: var(--slate); margin-top: var(--space-sm);">
                Select multiple modes to run them in parallel and compare results side-by-side.
            </p>
        </div>

        <!-- Generate Section (shared) -->
        <div class="settings-section">
            <div class="generate-section">
                <div class="calc-display" id="calc-display">0 images selected</div>
                <button class="btn btn--primary btn--lg btn--block" id="upscale-btn" disabled>
                    Upscale Images
                </button>
            </div>
        </div>

        <!-- Inline Loader -->
        <div class="inline-loader" id="inline-loader">
            <div class="loader-message" id="loader-message">Setting up the Studio...</div>
            <div class="loader-progress" id="loader-progress">Preparing...</div>
        </div>

        <!-- Progress -->
        <div class="progress-section" id="progress-section">
            <div class="progress-header">
                <span class="progress-title">Processing</span>
                <span class="progress-count" id="progress-count">0 / 0</span>
            </div>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
        </div>

        <!-- Results -->
        <div class="results-section" id="results-section">
            <div class="results-header">
                <h2>Results</h2>
                <p class="results-subtitle">Click to view full size</p>
            </div>
            <div id="results-container"></div>
        </div>
    </div>

    <!-- Lightbox -->
    <div class="lightbox" id="lightbox">
        <div class="lightbox-content">
            <button class="lightbox-close" id="lightbox-close">&times;</button>
            <div class="lightbox-left">
                <!-- Comparison Slider -->
                <div class="comparison-container" id="comparison-container">
                    <div class="comparison-image comparison-original" id="comparison-original">
                        <img src="" alt="Original" id="comparison-original-img">
                        <span class="comparison-label comparison-label-right">Original</span>
                    </div>
                    <div class="comparison-image comparison-enhanced" id="comparison-enhanced">
                        <img src="" alt="Enhanced" id="comparison-enhanced-img">
                        <span class="comparison-label comparison-label-left">Enhanced</span>
                    </div>
                    <div class="comparison-slider" id="comparison-slider">
                        <div class="comparison-slider-line"></div>
                        <div class="comparison-slider-handle">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
                                <circle cx="12" cy="12" r="11" fill="white" stroke="#333" stroke-width="2"/>
                                <path d="M8 12L5 9M8 12L5 15M8 12H3" stroke="#333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                <path d="M16 12L19 9M16 12L19 15M16 12H21" stroke="#333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                        </div>
                    </div>
                </div>
            </div>
            <div class="lightbox-right">
                <div class="lightbox-section">
                    <h3 class="lightbox-section-title">Original</h3>
                    <img src="" alt="" id="lightbox-original" style="max-width: 200px; border-radius: 8px;">
                </div>
                <div class="lightbox-section">
                    <h3 class="lightbox-section-title">Settings</h3>
                    <p id="lightbox-settings" style="font-size: 14px; color: #666;"></p>
                </div>
                <button class="lightbox-download" id="lightbox-download">
                    Download Image
                </button>
            </div>
        </div>
    </div>

    <script src="/shared/js/utils.js"></script>
    <script src="/shared/js/loader.js"></script>

    <script>
        // Custom messages for upscaler (overrides default studio messages)
        const UPSCALER_MESSAGES = [
            "Enhancing Details...",
            "Analyzing Textures...",
            "Upscaling Pixels...",
            "Refining Edges...",
            "Boosting Resolution...",
            "Processing Highlights...",
            "Sharpening Features...",
            "Reconstructing Details...",
            "Magnifying Beauty...",
            "Adding Clarity...",
            "Perfecting Tones...",
            "Almost There..."
        ];

        // Create custom loader with upscaler messages
        const upscalerLoader = new StudioLoader({ messages: UPSCALER_MESSAGES });

        // State
        let pasteTargetIndex = null; // Index of slot ready for paste
        let batchCounter = 0; // Track batch numbers for history

        const state = {
            mode: 'upscale', // 'upscale' or 'skin-enhance'
            images: [], // Array of { dataUrl, file }
            // Upscale settings
            scaleFactor: '2x',
            engine: 'automatic',
            optimizedFor: 'standard',
            creativity: 0,
            hdr: 0,
            resemblance: 0,
            prompt: '',
            autoAnalyze: false,
            keepFilenames: false,
            // Skin enhance settings
            skinModes: ['creative'], // Can be multiple: 'creative', 'faithful', 'flexible'
            sharpen: 0,
            smartGrain: 2,
            skinDetail: 80, // For faithful mode
            flexibleOptimizations: ['enhance_skin'], // For flexible mode - can be multiple
            // Results
            results: [],
            lightboxIndex: 0
        };

        const NUM_SLOTS = 12; // 6x2 grid

        // DOM Elements
        const elements = {
            // Mode
            modeButtons: document.getElementById('mode-buttons'),
            upscaleSettings: document.getElementById('upscale-settings'),
            skinEnhanceSettings: document.getElementById('skin-enhance-settings'),
            // Upload
            uploadGrid: document.getElementById('upload-grid'),
            // Upscale settings
            scaleButtons: document.getElementById('scale-buttons'),
            engineButtons: document.getElementById('engine-buttons'),
            optimizedButtons: document.getElementById('optimized-buttons'),
            creativitySlider: document.getElementById('creativity-slider'),
            creativityValue: document.getElementById('creativity-value'),
            hdrSlider: document.getElementById('hdr-slider'),
            hdrValue: document.getElementById('hdr-value'),
            resemblanceSlider: document.getElementById('resemblance-slider'),
            resemblanceValue: document.getElementById('resemblance-value'),
            promptInput: document.getElementById('prompt-input'),
            autoAnalyzeToggle: document.getElementById('auto-analyze-toggle'),
            analyzeHint: document.getElementById('analyze-hint'),
            keepFilenamesCheckbox: document.getElementById('keep-filenames'),
            // Skin enhance settings
            skinModeCheckboxes: document.getElementById('skin-mode-checkboxes'),
            sharpenSlider: document.getElementById('sharpen-slider'),
            sharpenValue: document.getElementById('sharpen-value'),
            grainSlider: document.getElementById('grain-slider'),
            grainValue: document.getElementById('grain-value'),
            faithfulSettings: document.getElementById('faithful-settings'),
            flexibleSettings: document.getElementById('flexible-settings'),
            skinDetailSlider: document.getElementById('skin-detail-slider'),
            skinDetailValue: document.getElementById('skin-detail-value'),
            flexibleOptimizedCheckboxes: document.getElementById('flexible-optimized-checkboxes'),
            // Shared
            calcDisplay: document.getElementById('calc-display'),
            upscaleBtn: document.getElementById('upscale-btn'),
            inlineLoader: document.getElementById('inline-loader'),
            loaderMessage: document.getElementById('loader-message'),
            loaderProgress: document.getElementById('loader-progress'),
            progressSection: document.getElementById('progress-section'),
            progressCount: document.getElementById('progress-count'),
            progressBar: document.getElementById('progress-bar'),
            resultsSection: document.getElementById('results-section'),
            resultsContainer: document.getElementById('results-container'),
            lightbox: document.getElementById('lightbox'),
            lightboxImage: document.getElementById('lightbox-image'),
            lightboxOriginal: document.getElementById('lightbox-original'),
            lightboxSettings: document.getElementById('lightbox-settings'),
            lightboxClose: document.getElementById('lightbox-close'),
            lightboxDownload: document.getElementById('lightbox-download'),
            // Comparison slider
            comparisonContainer: document.getElementById('comparison-container'),
            comparisonOriginal: document.getElementById('comparison-original'),
            comparisonOriginalImg: document.getElementById('comparison-original-img'),
            comparisonEnhancedImg: document.getElementById('comparison-enhanced-img'),
            comparisonSlider: document.getElementById('comparison-slider')
        };

        // Loading animation uses upscalerLoader (defined above)
        function startLoadingAnimation(progressText = 'Preparing...') {
            upscalerLoader.start(progressText);
        }

        function updateLoadingProgress(text) {
            upscalerLoader.updateProgress(text);
        }

        function stopLoadingAnimation() {
            upscalerLoader.stop();
        }

        // Initialize upload grid
        function initUploadGrid() {
            elements.uploadGrid.innerHTML = '';
            for (let i = 0; i < NUM_SLOTS; i++) {
                const slot = document.createElement('div');
                slot.className = 'upload-slot';
                slot.dataset.index = i;
                slot.innerHTML = `+`;
                slot.addEventListener('click', (e) => handleSlotClick(i, e));
                elements.uploadGrid.appendChild(slot);
            }
            console.log(`[Upscaler] Initialized ${NUM_SLOTS} upload slots`);
        }

        function handleSlotClick(index, event) {
            console.log(`[Upscaler] Slot ${index} clicked, detail: ${event?.detail}, hasImage: ${!!state.images[index]}, pasteTarget: ${pasteTargetIndex}`);

            // If slot already has image, double-click to replace via file picker
            if (state.images[index] && event?.detail === 2) {
                console.log(`[Upscaler] Double-click on filled slot ${index}, opening file picker`);
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'image/*';
                input.onchange = (e) => handleFileSelect(e, index);
                input.click();
                return;
            }

            // Single click on empty slot: set as paste target OR open file picker
            if (!state.images[index]) {
                // If already the paste target, open file picker
                if (pasteTargetIndex === index) {
                    console.log(`[Upscaler] Second click on paste target ${index}, opening file picker`);
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = 'image/*';
                    input.onchange = (e) => handleFileSelect(e, index);
                    input.click();
                    return;
                }

                // Set as paste target
                console.log(`[Upscaler] Setting slot ${index} as paste target (Cmd+V to paste)`);
                clearPasteTarget();
                pasteTargetIndex = index;
                const slots = elements.uploadGrid.querySelectorAll('.upload-slot');
                slots[index].classList.add('paste-ready');
            }
        }

        function clearPasteTarget() {
            if (pasteTargetIndex !== null) {
                console.log(`[Upscaler] Clearing paste target (was slot ${pasteTargetIndex})`);
            }
            document.querySelectorAll('.upload-slot.paste-ready').forEach(el => el.classList.remove('paste-ready'));
            pasteTargetIndex = null;
        }

        function handleFileSelect(e, index) {
            const file = e.target.files[0];
            if (!file) return;

            console.log(`[Upscaler] File selected for slot ${index}: ${file.name}, size: ${file.size}`);
            const reader = new FileReader();
            reader.onload = (event) => {
                // Extract original filename without extension
                const originalName = file.name.replace(/\.[^/.]+$/, '');
                state.images[index] = {
                    dataUrl: event.target.result,
                    file: file,
                    originalName: originalName
                };
                console.log(`[Upscaler] File loaded into slot ${index}, originalName: ${originalName}`);
                clearPasteTarget();
                renderUploadGrid();
                updateCalc();
            };
            reader.readAsDataURL(file);
        }

        function removeImage(index) {
            console.log(`[Upscaler] Removing image from slot ${index}`);
            // Remove the image and shift remaining images forward
            state.images.splice(index, 1);
            renderUploadGrid();
            updateCalc();
        }

        function renderUploadGrid() {
            const slots = elements.uploadGrid.querySelectorAll('.upload-slot');
            slots.forEach((slot, i) => {
                const img = state.images[i];
                if (img) {
                    slot.className = 'upload-slot filled';
                    slot.innerHTML = `
                        <img src="${img.dataUrl}" alt="Image ${i + 1}">
                        <button class="remove-btn" onclick="event.stopPropagation(); removeImage(${i})">&times;</button>
                    `;
                } else {
                    slot.className = 'upload-slot';
                    slot.innerHTML = `+`;
                }
            });
        }

        function updateCalc() {
            const imageCount = state.images.filter(img => img).length;
            let totalTasks = imageCount;

            if (state.mode === 'skin-enhance') {
                // Count tasks: each mode runs once, except flexible runs once per optimization
                let modeTaskCount = 0;
                state.skinModes.forEach(mode => {
                    if (mode === 'flexible') {
                        modeTaskCount += state.flexibleOptimizations.length;
                    } else {
                        modeTaskCount += 1;
                    }
                });
                totalTasks = imageCount * modeTaskCount;
                elements.calcDisplay.textContent = `${imageCount} image${imageCount !== 1 ? 's' : ''} √ó ${modeTaskCount} variation${modeTaskCount !== 1 ? 's' : ''} = ${totalTasks} tasks`;
            } else {
                elements.calcDisplay.textContent = `${imageCount} image${imageCount !== 1 ? 's' : ''} selected`;
            }

            const hasValidModes = state.skinModes.length > 0 &&
                (!state.skinModes.includes('flexible') || state.flexibleOptimizations.length > 0);
            elements.upscaleBtn.disabled = imageCount === 0 || (state.mode === 'skin-enhance' && !hasValidModes);
        }

        // Mode toggle
        elements.modeButtons.addEventListener('click', (e) => {
            if (e.target.classList.contains('btn--toggle')) {
                elements.modeButtons.querySelectorAll('.btn--toggle').forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');
                state.mode = e.target.dataset.mode;

                // Toggle settings visibility
                if (state.mode === 'upscale') {
                    elements.upscaleSettings.style.display = 'block';
                    elements.skinEnhanceSettings.style.display = 'none';
                    elements.upscaleBtn.textContent = 'Upscale Images';
                } else {
                    elements.upscaleSettings.style.display = 'none';
                    elements.skinEnhanceSettings.style.display = 'block';
                    elements.upscaleBtn.textContent = 'Enhance Skin';
                }
                updateCalc();
            }
        });

        // Skin enhance mode checkboxes
        elements.skinModeCheckboxes.addEventListener('change', (e) => {
            if (e.target.type === 'checkbox') {
                state.skinModes = Array.from(elements.skinModeCheckboxes.querySelectorAll('input:checked'))
                    .map(cb => cb.value);

                // Show/hide mode-specific settings
                elements.faithfulSettings.classList.toggle('visible', state.skinModes.includes('faithful'));
                elements.flexibleSettings.classList.toggle('visible', state.skinModes.includes('flexible'));

                updateCalc();
            }
        });

        // Event listeners - Upscale
        elements.scaleButtons.addEventListener('click', (e) => {
            if (e.target.classList.contains('btn--toggle')) {
                elements.scaleButtons.querySelectorAll('.btn--toggle').forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');
                state.scaleFactor = e.target.dataset.scale;
            }
        });

        elements.engineButtons.addEventListener('click', (e) => {
            if (e.target.classList.contains('btn--toggle')) {
                elements.engineButtons.querySelectorAll('.btn--toggle').forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');
                state.engine = e.target.dataset.engine;
            }
        });

        elements.optimizedButtons.addEventListener('click', (e) => {
            if (e.target.classList.contains('btn--toggle')) {
                elements.optimizedButtons.querySelectorAll('.btn--toggle').forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');
                state.optimizedFor = e.target.dataset.opt;
            }
        });

        elements.creativitySlider.addEventListener('input', (e) => {
            state.creativity = parseInt(e.target.value);
            elements.creativityValue.textContent = state.creativity;
        });

        elements.hdrSlider.addEventListener('input', (e) => {
            state.hdr = parseInt(e.target.value);
            elements.hdrValue.textContent = state.hdr;
        });

        elements.resemblanceSlider.addEventListener('input', (e) => {
            state.resemblance = parseInt(e.target.value);
            elements.resemblanceValue.textContent = state.resemblance;
        });

        elements.promptInput.addEventListener('input', (e) => {
            state.prompt = e.target.value;
        });

        elements.autoAnalyzeToggle.addEventListener('change', (e) => {
            state.autoAnalyze = e.target.checked;
            elements.analyzeHint.style.display = state.autoAnalyze ? 'block' : 'none';
            // Disable manual prompt input when auto-analyze is on
            elements.promptInput.disabled = state.autoAnalyze;
            if (state.autoAnalyze) {
                elements.promptInput.placeholder = 'Auto-analyze will generate prompt...';
            } else {
                elements.promptInput.placeholder = 'e.g., high fashion portrait, detailed skin texture...';
            }
        });

        elements.keepFilenamesCheckbox.addEventListener('change', (e) => {
            state.keepFilenames = e.target.checked;
        });

        // Skin enhance sliders
        elements.sharpenSlider.addEventListener('input', (e) => {
            state.sharpen = parseInt(e.target.value);
            elements.sharpenValue.textContent = state.sharpen;
        });

        elements.grainSlider.addEventListener('input', (e) => {
            state.smartGrain = parseInt(e.target.value);
            elements.grainValue.textContent = state.smartGrain;
        });

        elements.skinDetailSlider.addEventListener('input', (e) => {
            state.skinDetail = parseInt(e.target.value);
            elements.skinDetailValue.textContent = state.skinDetail;
        });

        // Flexible mode optimization checkboxes
        elements.flexibleOptimizedCheckboxes.addEventListener('change', (e) => {
            if (e.target.type === 'checkbox') {
                state.flexibleOptimizations = Array.from(elements.flexibleOptimizedCheckboxes.querySelectorAll('input:checked'))
                    .map(cb => cb.value);
                console.log(`[Upscaler] Flexible optimizations: ${state.flexibleOptimizations.join(', ')}`);
                updateCalc();
            }
        });

        // Process function
        elements.upscaleBtn.addEventListener('click', handleProcess);

        async function handleProcess() {
            const imagesToProcess = state.images.filter(img => img);
            if (imagesToProcess.length === 0) return;

            // Increment batch counter for this run
            batchCounter++;
            const currentBatchId = batchCounter;

            // Build task list
            const tasks = [];

            if (state.mode === 'skin-enhance') {
                // For skin enhance, create tasks for each image √ó mode combination
                // For flexible mode, create a separate task for each optimization
                imagesToProcess.forEach((img, imgIndex) => {
                    state.skinModes.forEach(skinMode => {
                        if (skinMode === 'flexible') {
                            // Create a task for each flexible optimization
                            state.flexibleOptimizations.forEach(flexOpt => {
                                tasks.push({
                                    image: img,
                                    imageIndex: imgIndex,
                                    skinMode: skinMode,
                                    flexibleOptimizedFor: flexOpt
                                });
                            });
                        } else {
                            tasks.push({
                                image: img,
                                imageIndex: imgIndex,
                                skinMode: skinMode
                            });
                        }
                    });
                });
            } else {
                // For upscale, one task per image
                imagesToProcess.forEach((img, imgIndex) => {
                    tasks.push({
                        image: img,
                        imageIndex: imgIndex
                    });
                });
            }

            const total = tasks.length;
            let completed = 0;

            elements.progressSection.classList.add('visible');
            elements.progressCount.textContent = `0 / ${total}`;
            elements.progressBar.style.width = '0%';
            elements.upscaleBtn.disabled = true;

            const actionName = state.mode === 'skin-enhance' ? 'skin enhance' : 'upscale';
            startLoadingAnimation(`Starting ${actionName}...`);

            // Process tasks with concurrency limit to avoid rate limiting
            const MAX_CONCURRENT = 6; // Process up to 6 images in parallel
            const processTask = async (task, taskIndex) => {
                try {
                    updateLoadingProgress(`${completed}/${total} complete`);

                    // Extract base64 data (remove data:image/xxx;base64, prefix)
                    const base64Data = task.image.dataUrl.split(',')[1];

                    let apiEndpoint, requestBody, statusEndpoint, modeName;

                    if (state.mode === 'skin-enhance') {
                        // Skin Enhance mode
                        apiEndpoint = '/api/skin-enhance';
                        statusEndpoint = '/api/skin-enhance';

                        // For flexible mode, include the optimization type in the mode name
                        if (task.skinMode === 'flexible' && task.flexibleOptimizedFor) {
                            modeName = `flexible_${task.flexibleOptimizedFor}`;
                        } else {
                            modeName = task.skinMode;
                        }

                        requestBody = {
                            image: base64Data,
                            mode: task.skinMode,
                            sharpen: state.sharpen,
                            smart_grain: state.smartGrain
                        };

                        // Add mode-specific params
                        if (task.skinMode === 'faithful') {
                            requestBody.skin_detail = state.skinDetail;
                        } else if (task.skinMode === 'flexible') {
                            requestBody.optimized_for = task.flexibleOptimizedFor;
                        }
                    } else {
                        // Upscale mode
                        apiEndpoint = '/api/upscale';
                        statusEndpoint = '/api/upscale';
                        modeName = 'upscale';

                        // Determine prompt - either manual or auto-analyzed
                        let promptToUse = state.prompt || undefined;

                        if (state.autoAnalyze) {
                            updateLoadingProgress(`Analyzing image ${task.imageIndex + 1}...`);
                            try {
                                const analyzeResponse = await fetch('/api/analyze-gemini', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        image: task.image.dataUrl,
                                        prompt: 'Describe this image concisely for an AI upscaler. Focus on: subject matter, materials/textures, lighting quality, and key details that should be preserved and enhanced. Keep it under 100 words. Do not use markdown or formatting.'
                                    })
                                });
                                const analyzeData = await analyzeResponse.json();
                                if (analyzeResponse.ok && analyzeData.content) {
                                    promptToUse = analyzeData.content;
                                    console.log(`[Upscaler] Auto-analyzed prompt (Gemini): ${promptToUse.substring(0, 80)}...`);
                                }
                            } catch (analyzeError) {
                                console.error('[Upscaler] Auto-analyze failed:', analyzeError);
                                // Continue without prompt if analysis fails
                            }
                        }

                        requestBody = {
                            image: base64Data,
                            scale_factor: state.scaleFactor,
                            optimized_for: state.optimizedFor,
                            creativity: state.creativity,
                            hdr: state.hdr,
                            resemblance: state.resemblance,
                            engine: state.engine,
                            prompt: promptToUse
                        };
                    }

                    // Start task
                    const startResponse = await fetch(apiEndpoint, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(requestBody)
                    });

                    const startData = await startResponse.json();
                    if (!startResponse.ok) {
                        throw new Error(startData.error || `Failed to start ${actionName}`);
                    }

                    const taskId = startData.data.task_id;
                    console.log(`[${taskIndex + 1}/${total}] Task started (${modeName}): ${taskId}`);

                    // Poll for completion with retry logic for rate limiting
                    let result = null;
                    let pollDelay = 2000; // Start with 2 seconds
                    let retryCount = 0;
                    const maxRetries = 5;

                    while (!result) {
                        await new Promise(r => setTimeout(r, pollDelay));

                        const statusResponse = await fetch(`${statusEndpoint}/${taskId}`);

                        // Handle rate limiting with exponential backoff
                        if (statusResponse.status === 429) {
                            retryCount++;
                            if (retryCount >= maxRetries) {
                                throw new Error(`Rate limited after ${maxRetries} retries`);
                            }
                            pollDelay = Math.min(pollDelay * 2, 10000); // Double delay, max 10 seconds
                            console.log(`[${taskIndex + 1}/${total}] Rate limited, waiting ${pollDelay}ms...`);
                            continue;
                        }

                        const statusData = await statusResponse.json();

                        if (!statusData.data) {
                            console.error(`[${taskIndex + 1}/${total}] Invalid response:`, statusData);
                            throw new Error('Invalid API response');
                        }

                        if (statusData.data.status === 'COMPLETED') {
                            result = statusData.data.generated[0];
                            console.log(`[${taskIndex + 1}/${total}] Completed (${modeName})!`);
                        } else if (statusData.data.status === 'FAILED') {
                            throw new Error(`${actionName} task failed`);
                        }
                        // Otherwise still IN_PROGRESS, keep polling
                    }

                    const resultData = {
                        url: result,
                        originalUrl: task.image.dataUrl,
                        originalName: task.image.originalName, // For keep filenames feature
                        imageIndex: task.imageIndex,
                        batchId: currentBatchId, // For batch history
                        mode: state.mode === 'skin-enhance' ? task.skinMode : 'upscale',
                        modeName: modeName // Full mode name for filename (e.g., 'flexible_enhance_skin')
                    };

                    if (state.mode === 'skin-enhance') {
                        resultData.skinMode = task.skinMode;
                        resultData.sharpen = state.sharpen;
                        resultData.smartGrain = state.smartGrain;
                        if (task.skinMode === 'faithful') {
                            resultData.skinDetail = state.skinDetail;
                        }
                        if (task.skinMode === 'flexible') {
                            resultData.flexibleOptimizedFor = task.flexibleOptimizedFor;
                        }
                    } else {
                        resultData.scaleFactor = state.scaleFactor;
                        resultData.engine = state.engine;
                        resultData.optimizedFor = state.optimizedFor;
                    }

                    state.results.push(resultData);
                    renderResults();

                } catch (error) {
                    console.error(`[${taskIndex + 1}/${total}] Error:`, error.message);
                }

                completed++;
                elements.progressCount.textContent = `${completed} / ${total}`;
                elements.progressBar.style.width = `${(completed / total) * 100}%`;
                updateLoadingProgress(`${completed}/${total} complete`);
            };

            // Process with concurrency limit
            const runWithConcurrency = async (tasks, maxConcurrent) => {
                const results = [];
                const executing = new Set();

                for (let i = 0; i < tasks.length; i++) {
                    const task = tasks[i];
                    const promise = processTask(task, i).then(() => {
                        executing.delete(promise);
                    });
                    executing.add(promise);
                    results.push(promise);

                    if (executing.size >= maxConcurrent) {
                        await Promise.race(executing);
                    }
                }

                return Promise.all(results);
            };

            await runWithConcurrency(tasks, MAX_CONCURRENT);

            stopLoadingAnimation();
            elements.progressSection.classList.remove('visible');
            elements.upscaleBtn.disabled = false;
        }

        function renderResults() {
            if (state.results.length === 0) {
                elements.resultsSection.classList.remove('visible');
                return;
            }

            elements.resultsSection.classList.add('visible');

            // Group results by batchId
            const batches = {};
            state.results.forEach((result, idx) => {
                const batchKey = result.batchId || 1;
                if (!batches[batchKey]) {
                    batches[batchKey] = [];
                }
                batches[batchKey].push({ ...result, globalIndex: idx });
            });

            // Sort batches in reverse order (newest first)
            const sortedBatchIds = Object.keys(batches).map(Number).sort((a, b) => b - a);

            elements.resultsContainer.innerHTML = sortedBatchIds.map(batchId => {
                const batchResults = batches[batchId];

                const cardsHtml = batchResults.map(result => {
                    const modeName = result.mode.charAt(0).toUpperCase() + result.mode.slice(1);
                    let metaText = '';

                    if (result.mode === 'upscale') {
                        metaText = `${result.scaleFactor} ¬∑ ${result.optimizedFor}`;
                    } else if (result.mode === 'creative') {
                        metaText = `Sharpen: ${result.sharpen}`;
                    } else if (result.mode === 'faithful') {
                        metaText = `Detail: ${result.skinDetail}`;
                    } else if (result.mode === 'flexible') {
                        metaText = (result.flexibleOptimizedFor || '').replace(/_/g, ' ');
                    }

                    return `
                        <div class="result-card" onclick="openLightbox(${result.globalIndex})">
                            <img src="${result.url}" alt="Processed">
                            <div class="result-info">
                                <div>
                                    <span class="result-mode">${modeName}</span>
                                    <span class="result-meta">${metaText}</span>
                                </div>
                                <button class="download-btn" onclick="event.stopPropagation(); downloadResult(${result.globalIndex})">Download</button>
                            </div>
                        </div>
                    `;
                }).join('');

                return `
                    <div class="result-group">
                        <div class="result-group-header">Upscale ${batchId}</div>
                        <div class="results-grid">${cardsHtml}</div>
                    </div>
                `;
            }).join('');
        }

        // Lightbox
        window.openLightbox = function(index) {
            state.lightboxIndex = index;
            const result = state.results[index];

            // Set up comparison slider images
            elements.comparisonEnhancedImg.src = result.url;
            elements.comparisonOriginalImg.src = result.originalUrl;

            // Set sidebar original thumbnail
            elements.lightboxOriginal.src = result.originalUrl;

            // Reset slider to 50%
            updateComparisonSlider(50);

            let settingsText = '';
            if (result.mode === 'upscale') {
                settingsText = `Mode: Upscale\nScale: ${result.scaleFactor}\nEngine: ${result.engine}\nOptimized: ${result.optimizedFor}`;
            } else {
                settingsText = `Mode: ${result.mode}\nSharpen: ${result.sharpen}\nSmart Grain: ${result.smartGrain}`;
                if (result.skinDetail !== undefined) {
                    settingsText += `\nSkin Detail: ${result.skinDetail}`;
                }
                if (result.flexibleOptimizedFor) {
                    settingsText += `\nOptimized For: ${result.flexibleOptimizedFor}`;
                }
            }
            elements.lightboxSettings.textContent = settingsText;

            elements.lightbox.classList.add('visible');
            document.body.style.overflow = 'hidden';
        };

        // Comparison slider logic
        function updateComparisonSlider(percent) {
            // Clamp between 0 and 100
            percent = Math.max(0, Math.min(100, percent));

            // Update slider position
            elements.comparisonSlider.style.left = `${percent}%`;

            // Update clip-path for original (right side)
            // clip-path: inset(top right bottom left)
            // We want to show original on the RIGHT side of the slider
            elements.comparisonOriginal.style.clipPath = `inset(0 0 0 ${percent}%)`;
        }

        // Slider drag handling
        let isDragging = false;

        function handleSliderStart(e) {
            isDragging = true;
            e.preventDefault();
            updateSliderFromEvent(e);
        }

        function handleSliderMove(e) {
            if (!isDragging) return;
            e.preventDefault();
            updateSliderFromEvent(e);
        }

        function handleSliderEnd() {
            isDragging = false;
        }

        function updateSliderFromEvent(e) {
            const container = elements.comparisonContainer;
            const rect = container.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const x = clientX - rect.left;
            const percent = (x / rect.width) * 100;
            updateComparisonSlider(percent);
        }

        // Mouse events
        elements.comparisonContainer.addEventListener('mousedown', handleSliderStart);
        document.addEventListener('mousemove', handleSliderMove);
        document.addEventListener('mouseup', handleSliderEnd);

        // Touch events
        elements.comparisonContainer.addEventListener('touchstart', handleSliderStart);
        document.addEventListener('touchmove', handleSliderMove);
        document.addEventListener('touchend', handleSliderEnd);

        elements.lightboxClose.addEventListener('click', closeLightbox);
        elements.lightbox.addEventListener('click', (e) => {
            // Only close if clicking the backdrop itself, not the content or comparison slider
            if (e.target === elements.lightbox) closeLightbox();
        });

        // Prevent comparison container clicks from closing lightbox
        elements.comparisonContainer.addEventListener('click', (e) => {
            e.stopPropagation();
        });

        function closeLightbox() {
            elements.lightbox.classList.remove('visible');
            document.body.style.overflow = '';
        }

        elements.lightboxDownload.addEventListener('click', () => {
            downloadResult(state.lightboxIndex);
        });

        // Download with proper filename: Setset_Upscale_Creative_YYMMDD_HHMM_XX
        // For flexible mode: Setset_Upscale_Flexible_EnhanceSkin_YYMMDD_HHMM_XX
        window.downloadResult = async function(index) {
            const result = state.results[index];
            let filename;

            if (state.keepFilenames && result.originalName) {
                // Use original filename with scale prefix (e.g., x2_originalname.png)
                const scalePrefix = result.scaleFactor || '2x';
                filename = `${scalePrefix}_${result.originalName}.png`;
            } else {
                // Default timestamped filename
                const now = new Date();
                const date = now.toISOString().slice(2, 10).replace(/-/g, '');
                const time = now.toTimeString().slice(0, 5).replace(':', '');
                const num = String(index + 1).padStart(2, '0');

                // Format mode name for filename
                let modeName;
                if (result.modeName) {
                    // Use the full modeName (e.g., 'flexible_enhance_skin')
                    // Convert to PascalCase: flexible_enhance_skin -> Flexible_EnhanceSkin
                    modeName = result.modeName.split('_').map((part, i) => {
                        return part.charAt(0).toUpperCase() + part.slice(1);
                    }).join('_');
                } else {
                    modeName = result.mode.charAt(0).toUpperCase() + result.mode.slice(1);
                }
                filename = `Setset_Upscale_${modeName}_${date}_${time}_${num}.png`;
            }

            downloadFile(result.url, filename);
        };

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') closeLightbox();
        });

        // Paste handler - only works when a slot is selected
        document.addEventListener('paste', async (e) => {
            console.log(`[Upscaler] Paste event, pasteTargetIndex: ${pasteTargetIndex}`);

            // Only handle if we have a paste target
            if (pasteTargetIndex === null) {
                console.log(`[Upscaler] No paste target set, ignoring paste`);
                return;
            }

            const items = e.clipboardData?.items;
            if (!items) {
                console.log(`[Upscaler] No clipboard items`);
                return;
            }

            console.log(`[Upscaler] Clipboard has ${items.length} items`);

            for (const item of items) {
                console.log(`[Upscaler] Item type: ${item.type}`);
                if (item.type.startsWith('image/')) {
                    const file = item.getAsFile();
                    console.log(`[Upscaler] Pasting image to slot ${pasteTargetIndex}, size: ${file.size} bytes`);
                    const reader = new FileReader();
                    const targetIndex = pasteTargetIndex;
                    reader.onload = (event) => {
                        state.images[targetIndex] = {
                            dataUrl: event.target.result,
                            file: file
                        };
                        console.log(`[Upscaler] Image loaded into slot ${targetIndex}`);
                        clearPasteTarget();
                        renderUploadGrid();
                        updateCalc();

                        // Auto-select next empty slot
                        const nextEmpty = state.images.findIndex((img, i) => i > targetIndex && !img);
                        if (nextEmpty !== -1) {
                            console.log(`[Upscaler] Auto-selecting next empty slot: ${nextEmpty}`);
                            pasteTargetIndex = nextEmpty;
                            const slots = elements.uploadGrid.querySelectorAll('.upload-slot');
                            slots[nextEmpty].classList.add('paste-ready');
                        } else {
                            console.log(`[Upscaler] No more empty slots after ${targetIndex}`);
                        }
                    };
                    reader.readAsDataURL(file);
                    break;
                }
            }
        });

        // Clear paste target when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.upload-slot') && !e.target.closest('.upload-grid')) {
                clearPasteTarget();
            }
        });

        // Drag and drop handling
        elements.uploadGrid.addEventListener('dragover', (e) => {
            e.preventDefault();
            elements.uploadGrid.classList.add('drag-over');
        });

        elements.uploadGrid.addEventListener('dragleave', (e) => {
            e.preventDefault();
            elements.uploadGrid.classList.remove('drag-over');
        });

        elements.uploadGrid.addEventListener('drop', (e) => {
            e.preventDefault();
            elements.uploadGrid.classList.remove('drag-over');

            const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
            if (files.length === 0) return;

            console.log(`[Upscaler] Dropped ${files.length} image(s)`);

            // Pre-allocate slots to avoid race condition
            const slotsToFill = [];
            for (let i = 0; i < files.length; i++) {
                // Find first empty slot that's not already claimed
                let targetIndex = -1;
                for (let j = 0; j < NUM_SLOTS; j++) {
                    if (!state.images[j] && !slotsToFill.includes(j)) {
                        targetIndex = j;
                        break;
                    }
                }
                if (targetIndex === -1) {
                    console.log(`[Upscaler] No empty slot for file ${i + 1}`);
                    break;
                }
                slotsToFill.push(targetIndex);
            }

            // Now load files into pre-allocated slots
            files.forEach((file, i) => {
                if (i >= slotsToFill.length) return;
                const targetIndex = slotsToFill[i];

                const reader = new FileReader();
                reader.onload = (event) => {
                    const originalName = file.name.replace(/\.[^/.]+$/, '');
                    state.images[targetIndex] = {
                        dataUrl: event.target.result,
                        file: file,
                        originalName: originalName
                    };
                    console.log(`[Upscaler] Loaded dropped file into slot ${targetIndex}, originalName: ${originalName}`);
                    renderUploadGrid();
                    updateCalc();
                };
                reader.readAsDataURL(file);
            });
        });

        // Initialize
        initUploadGrid();
        updateCalc();
    </script>
</body>
</html>
