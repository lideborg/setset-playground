<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Generator</title>
    <link rel="stylesheet" href="/shared/css/tokens.css">
    <link rel="stylesheet" href="/shared/css/base.css">
    <link rel="stylesheet" href="/shared/css/components.css">
    <style>
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: var(--space-lg);
        }

        header {
            margin-bottom: var(--space-lg);
        }

        header h1 {
            font-size: 1.5rem;
            font-weight: 500;
            margin-bottom: var(--space-xs);
        }

        header p {
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        /* Main layout */
        .main-layout {
            max-width: 800px;
            margin: 0 auto;
        }

        /* Controls panel */
        .controls-panel {
            display: flex;
            flex-direction: column;
            gap: var(--space-md);
        }

        .panel-section {
            background: var(--bg-secondary);
            border-radius: var(--radius-md);
            padding: var(--space-md);
        }

        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--space-sm);
        }

        .section-title {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-secondary);
            font-weight: 500;
        }

        /* Upload grid */
        .upload-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 4px;
            padding: 6px;
            border: 2px dashed var(--border-primary);
            border-radius: var(--radius-md);
            background: var(--bg-primary);
        }

        .upload-grid.drag-over {
            border-color: var(--accent-primary);
        }

        .upload-slot {
            aspect-ratio: 3/4;
            border: 1px solid #ccc;
            border-radius: var(--radius-xs);
            cursor: pointer;
            position: relative;
            overflow: hidden;
            background: #f5f5f5;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: #999;
            transition: all 0.2s;
        }

        .upload-slot:hover {
            border-color: var(--text-secondary);
        }

        .upload-slot.filled {
            border-color: var(--text-primary);
            background: var(--bg-primary);
        }

        .upload-slot img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .upload-slot .remove-btn {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 14px;
            height: 14px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 9px;
            display: none;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }

        .upload-slot.filled:hover .remove-btn {
            display: flex;
        }

        .upload-slot.paste-ready {
            border-color: #2563eb;
            border-width: 2px;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.3);
        }

        .upload-slot.deselected {
            opacity: 0.4;
        }

        .upload-slot.deselected img {
            filter: grayscale(100%);
        }

        .upload-slot.uploading::after {
            content: '';
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .upload-slot .upload-spinner {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        /* Movement grid */
        .movement-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: var(--space-xs);
        }

        .movement-card {
            display: flex;
            flex-direction: column;
            cursor: pointer;
            transition: all 0.2s;
        }

        .movement-card .video-wrapper {
            position: relative;
            aspect-ratio: 3/4;
            border-radius: var(--radius-sm);
            overflow: hidden;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .movement-card:hover .video-wrapper {
            border-color: var(--text-tertiary);
        }

        .movement-card.selected .video-wrapper {
            border-color: var(--accent-primary);
        }

        .movement-card video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .movement-card .movement-name {
            text-align: center;
            padding: 6px 0 0;
            font-size: 0.7rem;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .movement-card.selected .movement-name {
            color: var(--text-primary);
        }

        .movement-placeholder {
            width: 100%;
            height: 100%;
            background: var(--bg-tertiary);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-tertiary);
        }

        .movement-card:hover .movement-placeholder {
            color: var(--text-secondary);
        }

        .movement-card.selected .movement-placeholder {
            background: var(--bg-secondary);
            color: var(--accent-primary);
        }

        /* Group cards styling */
        .movement-card.is-group .video-wrapper {
            background: linear-gradient(135deg, var(--bg-tertiary) 0%, var(--bg-secondary) 100%);
        }

        .movement-card.is-group .group-icon {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            color: var(--text-tertiary);
        }

        .movement-card.is-group .group-icon svg {
            width: 28px;
            height: 28px;
        }

        .movement-card.is-group .group-icon span {
            font-size: 0.55rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .movement-card.is-group:hover .group-icon {
            color: var(--text-secondary);
        }

        .movement-card.is-group.selected .group-icon {
            color: var(--accent-primary);
        }

        .movement-card.is-group.selected .video-wrapper {
            background: linear-gradient(135deg, rgba(37, 99, 235, 0.1) 0%, rgba(37, 99, 235, 0.05) 100%);
        }

        /* Settings dropdown */
        .settings-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            padding: var(--space-xs) 0;
        }

        .settings-toggle .arrow {
            transition: transform 0.2s;
        }

        .settings-toggle.open .arrow {
            transform: rotate(180deg);
        }

        .settings-content {
            display: none;
            padding-top: var(--space-sm);
        }

        .settings-content.open {
            display: block;
        }

        .setting-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--space-sm);
        }

        .setting-row label {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .setting-row select,
        .setting-row input[type="number"] {
            padding: 4px 8px;
            font-size: 0.75rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-sm);
            color: var(--text-primary);
        }

        .setting-row select {
            min-width: 100px;
        }

        .setting-row input[type="number"] {
            width: 60px;
            text-align: center;
        }

        .checkbox-row {
            display: flex;
            align-items: center;
            gap: var(--space-xs);
        }

        .checkbox-row input[type="checkbox"] {
            width: 14px;
            height: 14px;
        }

        /* Duration slider */
        .slider-container {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }

        .duration-slider {
            flex: 1;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--border-primary);
            border-radius: 2px;
            cursor: pointer;
        }

        .duration-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--text-primary);
            border-radius: 50%;
            cursor: pointer;
        }

        .duration-slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: var(--text-primary);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        #duration-value {
            font-size: 0.75rem;
            color: var(--text-secondary);
            min-width: 24px;
        }

        /* Generate button */
        .generate-section {
            margin-top: var(--space-sm);
        }

        .generate-btn {
            width: 100%;
            padding: var(--space-sm);
            font-size: 0.875rem;
        }

        .stats-line {
            text-align: center;
            font-size: 0.7rem;
            color: var(--text-tertiary);
            margin-top: var(--space-xs);
        }

        /* Results section */
        .results-section {
            margin-top: var(--space-lg);
            display: none;
        }

        .results-section.visible {
            display: block;
        }

        .results-header {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: var(--space-md);
            gap: var(--space-md);
        }

        .results-header h3 {
            font-size: 0.875rem;
            font-weight: 500;
        }

        .results-header .btn {
            position: absolute;
            right: var(--space-lg);
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: var(--space-md);
        }

        .result-card {
            background: var(--bg-secondary);
            border-radius: var(--radius-md);
            overflow: hidden;
            border: 1px solid var(--border-primary);
        }

        .result-card.generating {
            opacity: 0.8;
        }

        .result-video {
            width: 100%;
            aspect-ratio: 3/4;
            object-fit: cover;
            display: block;
            background: var(--bg-tertiary);
        }

        .result-placeholder {
            width: 100%;
            aspect-ratio: 3/4;
            background: var(--bg-tertiary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: var(--space-xs);
        }

        .result-placeholder .spinner {
            width: 32px;
            height: 32px;
            border: 3px solid var(--border-primary);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .result-placeholder p {
            font-size: 0.75rem;
            color: var(--text-tertiary);
        }

        .result-info {
            padding: var(--space-sm);
        }

        .result-movement {
            font-size: 0.75rem;
            font-weight: 500;
            margin-bottom: 4px;
        }

        .result-cost {
            font-size: 0.65rem;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .result-status {
            font-size: 0.65rem;
            color: var(--text-tertiary);
        }

        .result-actions {
            display: flex;
            gap: var(--space-xs);
            margin-top: var(--space-xs);
        }

        .result-actions .btn {
            flex: 1;
            font-size: 0.65rem;
            padding: 4px;
            height: auto;
        }

        /* Progress bar */
        .progress-section {
            margin-top: var(--space-sm);
            display: none;
        }

        .progress-section.visible {
            display: block;
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-bottom: var(--space-xs);
        }

        .progress-bar-bg {
            height: 4px;
            background: var(--border-primary);
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-bar-fill {
            height: 100%;
            background: var(--accent-primary);
            width: 0%;
            transition: width 0.3s ease;
        }

        /* Speed slider */
        .speed-slider-container {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            margin-top: 8px;
        }
        .speed-slider {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: #ccc;
            border-radius: 3px;
            cursor: pointer;
        }
        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: var(--text-primary);
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.15s;
        }
        .speed-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }
        .speed-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: var(--text-primary);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        .speed-value {
            font-size: 0.875rem;
            font-weight: 600;
            min-width: 40px;
            text-align: right;
        }

        /* Lightbox video adjustments */
        #video-lightbox .lightbox-next {
            right: calc(33.333% + var(--space-lg) + var(--space-xl));
        }

        /* Mode Tabs */
        .mode-tabs {
            display: flex;
            gap: 0;
            margin-bottom: var(--space-lg);
            border-bottom: 1px solid var(--border-primary);
        }

        .mode-tab {
            padding: var(--space-sm) var(--space-lg);
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-secondary);
            background: none;
            border: none;
            border-bottom: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: -1px;
        }

        .mode-tab:hover {
            color: var(--text-primary);
        }

        .mode-tab.active {
            color: var(--text-primary);
            border-bottom-color: var(--text-primary);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Stitch Drop Zone */
        .stitch-dropzone {
            width: 100%;
            min-height: 180px;
            border: 2px dashed var(--border-primary);
            border-radius: var(--radius-lg);
            background: var(--bg-secondary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: var(--space-sm);
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: var(--space-md);
        }

        .stitch-dropzone:hover {
            border-color: var(--text-secondary);
            background: var(--bg-tertiary);
        }

        .stitch-dropzone.drag-over {
            border-color: var(--accent-primary);
            background: rgba(37, 99, 235, 0.08);
            border-style: solid;
        }

        .stitch-dropzone.has-videos {
            min-height: 100px;
        }

        .stitch-dropzone-icon {
            font-size: 2.5rem;
            color: var(--text-tertiary);
        }

        .stitch-dropzone-text {
            font-size: 0.875rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .stitch-dropzone-hint {
            font-size: 0.75rem;
            color: var(--text-tertiary);
        }

        /* Stitch Video Grid */
        .stitch-grid {
            display: flex;
            flex-wrap: wrap;
            gap: var(--space-sm);
            padding: var(--space-sm);
        }

        .stitch-grid:empty {
            display: none;
        }

        .stitch-slot {
            height: 120px;
            border: 2px solid var(--border-primary);
            border-radius: var(--radius-sm);
            cursor: pointer;
            position: relative;
            overflow: hidden;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            font-size: 12px;
            color: #999;
            transition: all 0.15s;
        }

        .stitch-slot:hover {
            border-color: var(--accent-primary);
            transform: scale(1.02);
        }

        .stitch-slot video {
            height: 100%;
            width: auto;
            max-width: 100%;
            object-fit: contain;
        }

        .stitch-slot .slot-number {
            position: absolute;
            top: 6px;
            left: 6px;
            width: 22px;
            height: 22px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            border-radius: 50%;
            font-size: 11px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .stitch-slot .slot-duration {
            position: absolute;
            bottom: 6px;
            right: 6px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
        }

        .stitch-slot .remove-btn {
            position: absolute;
            top: 6px;
            right: 6px;
            width: 22px;
            height: 22px;
            background: rgba(220, 38, 38, 0.9);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 12px;
            display: none;
            align-items: center;
            justify-content: center;
            transition: transform 0.15s;
        }

        .stitch-slot .remove-btn:hover {
            transform: scale(1.1);
        }

        .stitch-slot:hover .remove-btn {
            display: flex;
        }

        .stitch-slot .trim-indicator {
            position: absolute;
            bottom: 6px;
            left: 6px;
            background: var(--accent-primary);
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 500;
            text-transform: uppercase;
        }

        .stitch-slot.dragging {
            opacity: 0.4;
            transform: scale(0.95);
        }

        .stitch-slot.drag-target {
            border: 2px dashed var(--accent-primary);
            background: rgba(37, 99, 235, 0.2);
        }

        /* Trim Editor Modal */
        .trim-modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .trim-modal.visible {
            display: flex;
        }

        .trim-modal-content {
            background: var(--bg-primary);
            border-radius: var(--radius-lg);
            max-width: 900px;
            width: 90%;
            max-height: 90vh;
            overflow: hidden;
        }

        .trim-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-md);
            border-bottom: 1px solid var(--border-primary);
        }

        .trim-modal-header h3 {
            font-size: 1rem;
            font-weight: 500;
        }

        .trim-modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-secondary);
        }

        .trim-video-container {
            background: #000;
            position: relative;
        }

        .trim-video-container video {
            width: 100%;
            max-height: 50vh;
            display: block;
        }

        .trim-timeline-container {
            padding: var(--space-md);
        }

        .trim-timeline {
            position: relative;
            height: 70px;
            background: #1a1a1a;
            border-radius: var(--radius-md);
            overflow: visible;
            margin: 0 16px;
        }

        .trim-timeline-track {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: var(--radius-sm);
            overflow: hidden;
        }

        .trim-timeline-frames {
            display: flex;
            height: 100%;
        }

        .trim-timeline-frames img {
            height: 100%;
            width: auto;
            object-fit: cover;
            flex-shrink: 0;
        }

        .trim-selection {
            position: absolute;
            top: 0;
            height: 100%;
            background: rgba(37, 99, 235, 0.25);
            border-top: 4px solid #3b82f6;
            border-bottom: 4px solid #3b82f6;
            box-sizing: border-box;
        }

        .trim-handle {
            position: absolute;
            top: -4px;
            width: 20px;
            height: calc(100% + 8px);
            cursor: ew-resize;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            background: #3b82f6;
            border-radius: 4px;
            transition: transform 0.1s, background 0.15s;
        }

        .trim-handle:hover {
            background: #2563eb;
            transform: scaleX(1.15);
        }

        .trim-handle:active {
            background: #1d4ed8;
        }

        .trim-handle::before {
            content: '';
            width: 4px;
            height: 24px;
            background: white;
            border-radius: 2px;
            opacity: 0.9;
        }

        .trim-handle::after {
            content: '';
            position: absolute;
            width: 4px;
            height: 24px;
            background: white;
            border-radius: 2px;
            opacity: 0.9;
            margin-left: 6px;
        }

        .trim-handle-in {
            left: -10px;
            border-radius: 4px 0 0 4px;
        }

        .trim-handle-out {
            right: -10px;
            border-radius: 0 4px 4px 0;
        }

        .trim-playhead {
            position: absolute;
            top: -6px;
            width: 3px;
            height: calc(100% + 12px);
            background: #fff;
            pointer-events: none;
            z-index: 15;
            border-radius: 2px;
            box-shadow: 0 0 6px rgba(0,0,0,0.5);
        }

        .trim-playhead::before {
            content: '';
            position: absolute;
            top: 0;
            left: -4px;
            width: 11px;
            height: 11px;
            background: white;
            border-radius: 50%;
        }

        .trim-times {
            display: flex;
            justify-content: space-between;
            padding: var(--space-sm) 16px;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .trim-times .selected-range {
            color: #3b82f6;
            font-weight: 600;
            font-size: 0.85rem;
        }

        .trim-modal-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: var(--space-sm);
            padding: var(--space-md);
            border-top: 1px solid var(--border-primary);
        }

        .trim-modal-footer .footer-left {
            display: flex;
            gap: var(--space-sm);
        }

        .trim-modal-footer .footer-right {
            display: flex;
            gap: var(--space-sm);
        }

        /* Stitch button */
        .stitch-btn {
            width: 100%;
            padding: var(--space-sm);
            font-size: 0.875rem;
        }

    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Video Generator</h1>
            <p>Upload images, select movements, generate fashion videos with Seedance</p>
        </header>

        <div class="main-layout">
            <!-- Mode Tabs -->
            <div class="mode-tabs">
                <button class="mode-tab active" data-tab="generator">Generator</button>
                <button class="mode-tab" data-tab="stitch">Stitch</button>
            </div>

            <!-- Generator Tab -->
            <div class="tab-content active" id="generator-tab">
            <!-- Controls Panel -->
            <div class="controls-panel">
                <!-- Upload Section -->
                <div class="panel-section">
                    <div class="section-header">
                        <span class="section-title">1. Upload Images</span>
                        <span class="section-title" id="upload-count">0 / 12 images</span>
                    </div>
                    <div class="upload-grid" id="upload-grid"></div>
                    <input type="file" id="file-input" multiple accept="image/*" style="display: none;">
                </div>

                <!-- Movement Section -->
                <div class="panel-section">
                    <div class="section-header">
                        <span class="section-title">2. Select Movement</span>
                    </div>
                    <div class="movement-grid" id="movement-grid"></div>
                </div>

                <!-- Settings Section -->
                <div class="panel-section">
                    <div class="settings-toggle" id="settings-toggle">
                        <span class="section-title">Settings</span>
                        <span class="arrow">â–¼</span>
                    </div>
                    <div class="settings-content" id="settings-content">
                        <div class="setting-row">
                            <label>Model</label>
                            <select id="model-version">
                                <option value="1.5" selected>Seedance 1.5</option>
                                <option value="1.0">Seedance 1.0</option>
                            </select>
                        </div>
                        <div class="setting-row">
                            <label>Resolution</label>
                            <select id="resolution">
                                <option value="480p">480p (faster)</option>
                                <option value="720p" selected>720p</option>
                                <option value="1080p" id="resolution-1080p" style="display: none;">1080p (higher quality)</option>
                            </select>
                        </div>
                        <div class="setting-row">
                            <label>Duration</label>
                            <div class="slider-container">
                                <input type="range" id="duration" min="2" max="12" value="5" class="duration-slider">
                                <span id="duration-value">5s</span>
                            </div>
                        </div>
                        <div class="setting-row">
                            <label>Aspect Ratio</label>
                            <select id="aspect-ratio">
                                <option value="auto" selected>Auto (from image)</option>
                                <option value="16:9">16:9</option>
                                <option value="9:16">9:16</option>
                                <option value="3:4">3:4</option>
                                <option value="4:3">4:3</option>
                                <option value="1:1">1:1</option>
                                <option value="21:9">21:9 (ultra-wide)</option>
                            </select>
                        </div>
                        <div class="setting-row">
                            <div class="checkbox-row">
                                <input type="checkbox" id="camera-fixed" checked>
                                <label for="camera-fixed">Fixed Camera</label>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Generate Section -->
                <div class="generate-section">
                    <button class="btn btn--primary generate-btn" id="generate-btn" disabled>
                        Generate Videos
                    </button>
                    <div class="stats-line" id="stats-line">
                        Select images and a movement to start
                    </div>
                    <div class="progress-section" id="progress-section">
                        <div class="progress-header">
                            <span id="progress-status">Generating...</span>
                            <span id="progress-count">0 / 0</span>
                        </div>
                        <div class="progress-bar-bg">
                            <div class="progress-bar-fill" id="progress-bar"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Inline Loader -->
            <div class="inline-loader" id="inline-loader">
                <div class="loader-message" id="loader-message">Setting up the Studio...</div>
                <div class="loader-progress" id="loader-progress">Preparing...</div>
            </div>

            <!-- Results Section -->
            <div class="results-section" id="results-section">
                <div class="results-header">
                    <h3>Generated Videos</h3>
                    <button class="btn btn--secondary" id="download-all-btn" disabled>Download All</button>
                </div>
                <div class="results-grid" id="results-grid"></div>
            </div>
            </div> <!-- End generator-tab -->

            <!-- Stitch Tab -->
            <div class="tab-content" id="stitch-tab">
                <div class="controls-panel">
                    <!-- Drop Zone -->
                    <div class="stitch-dropzone" id="stitch-dropzone">
                        <div class="stitch-dropzone-icon">ðŸ“¹</div>
                        <div class="stitch-dropzone-text">Drop videos here to stitch them together</div>
                        <div class="stitch-dropzone-hint">Supports MP4, MOV, WebM â€¢ Drag to reorder â€¢ Click to trim</div>
                    </div>
                    <input type="file" id="stitch-file-input" multiple accept="video/*" style="display: none;">

                    <!-- Video Grid (appears after videos added) -->
                    <div class="panel-section" id="stitch-videos-section" style="display: none;">
                        <div class="section-header">
                            <span class="section-title">Videos (drag to reorder)</span>
                            <span class="section-title" id="stitch-count">0 videos</span>
                        </div>
                        <div class="stitch-grid" id="stitch-grid"></div>
                    </div>

                    <!-- Stitch Button -->
                    <div class="generate-section">
                        <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
                            <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-size: 13px;">
                                <input type="checkbox" id="stitch-instagram" style="width: 16px; height: 16px; cursor: pointer;">
                                <span>Crop to 4:5 (Instagram)</span>
                            </label>
                        </div>
                        <button class="btn btn--primary stitch-btn" id="stitch-btn" disabled>
                            Stitch Videos
                        </button>
                        <div class="stats-line" id="stitch-stats">
                            Drop video files to start
                        </div>
                        <!-- Inline Loader for Stitch -->
                        <div class="inline-loader" id="stitch-loader" style="display: none;">
                            <div class="loader-message" id="stitch-loader-message">Preparing...</div>
                            <div class="loader-progress" id="stitch-loader-progress"></div>
                        </div>
                    </div>

                    <!-- Stitch Result -->
                    <div class="results-section" id="stitch-result-section">
                        <div class="results-header">
                            <h3>Stitched Video</h3>
                        </div>
                        <div style="text-align: center;">
                            <video id="stitch-result-video" controls style="max-width: 100%; max-height: 400px; border-radius: var(--radius-md);"></video>
                            <div style="margin-top: var(--space-sm);">
                                <button class="btn btn--primary" id="stitch-download-btn">Download</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Trim Editor Modal -->
    <div class="trim-modal" id="trim-modal" onclick="if(event.target === this) closeTrimModal()">
        <div class="trim-modal-content">
            <div class="trim-modal-header">
                <h3>Trim Video</h3>
                <button class="trim-modal-close" onclick="closeTrimModal()">&times;</button>
            </div>
            <div class="trim-video-container">
                <video id="trim-video" onclick="toggleTrimPlayback()"></video>
            </div>
            <div class="trim-timeline-container">
                <div class="trim-timeline" id="trim-timeline">
                    <div class="trim-timeline-track" id="trim-track"></div>
                    <div class="trim-selection" id="trim-selection">
                        <div class="trim-handle trim-handle-in" id="trim-handle-in"></div>
                        <div class="trim-handle trim-handle-out" id="trim-handle-out"></div>
                    </div>
                    <div class="trim-playhead" id="trim-playhead"></div>
                </div>
                <div class="trim-times">
                    <span id="trim-time-start">0:00</span>
                    <span class="selected-range" id="trim-time-range">Selected: 0:00 - 0:00</span>
                    <span id="trim-time-end">0:00</span>
                </div>
            </div>
            <div class="trim-modal-footer">
                <div class="footer-left">
                    <button class="btn btn--secondary" onclick="resetTrim()">Reset</button>
                    <button class="btn btn--secondary" id="play-selection-btn" onclick="playSelection()">â–¶ Play Selection</button>
                </div>
                <div class="footer-right">
                    <button class="btn btn--primary" onclick="applyTrim()">Apply</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Video Lightbox (using shared component styles) -->
    <div class="lightbox" id="video-lightbox" onclick="if(event.target === this) closeVideoLightbox()">
        <button class="lightbox-close" onclick="closeVideoLightbox()">&times;</button>
        <button class="lightbox-nav lightbox-prev" onclick="navigateVideoLightbox(-1)">&#8249;</button>
        <button class="lightbox-nav lightbox-next" onclick="navigateVideoLightbox(1)">&#8250;</button>
        <div class="lightbox-content">
            <div class="lightbox-left">
                <video id="lightbox-video" controls loop autoplay style="max-width: 100%; max-height: 85vh; object-fit: contain;"></video>
            </div>
            <div class="lightbox-right">
                <div class="lightbox-section">
                    <h3 class="lightbox-section-title">Movement</h3>
                    <p class="lightbox-model-text" id="lightbox-video-movement"></p>
                </div>
                <div class="lightbox-section">
                    <h3 class="lightbox-section-title">Prompt</h3>
                    <p class="lightbox-prompt-text" id="lightbox-video-prompt" style="white-space: pre-wrap;"></p>
                </div>
                <div class="lightbox-section">
                    <h3 class="lightbox-section-title">Playback Speed</h3>
                    <div class="speed-slider-container">
                        <span style="font-size: 11px; color: #888;">1x</span>
                        <input type="range" id="speed-slider" class="speed-slider" min="1" max="2" step="0.05" value="1">
                        <span style="font-size: 11px; color: #888;">2x</span>
                        <span class="speed-value" id="speed-value">1.0x</span>
                    </div>
                    <p style="font-size: 11px; color: #888; margin-top: 8px;">Speed applies to download</p>
                </div>
                <button class="lightbox-download" id="lightbox-video-download">Download Video</button>
            </div>
        </div>
    </div>

    <script src="/shared/js/api.js"></script>
    <script src="/shared/js/loader.js"></script>
    <script src="/shared/data/video-movements.js"></script>
    <script>
        // Constants
        const NUM_SLOTS = 12;

        // State
        const state = {
            images: new Array(NUM_SLOTS).fill(null),  // Array of { file, url, dataUrl, selected, uploading } or null
            selectedMovements: [],  // Array of movement IDs
            results: [],         // Generated videos
            generating: false,
            lightboxIndex: 0,    // Current video index in lightbox
            playbackSpeed: 1,    // Video playback speed
            // Stitch state
            stitchVideos: [],    // Array of { file, url, thumbnail, duration, inPoint, outPoint }
            stitchDragIndex: null,
            trimVideoIndex: null
        };

        let api;
        let pasteTarget = null;  // { slotIndex: number }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            api = new API();

            // Render upload grid
            renderUploadGrid();

            // Render movement grid
            renderMovementGrid();

            const uploadGrid = document.getElementById('upload-grid');
            const fileInput = document.getElementById('file-input');

            // File input change handler
            fileInput.addEventListener('change', (e) => {
                const targetSlot = e.target.dataset.targetSlot ? parseInt(e.target.dataset.targetSlot) : null;
                handleFileUpload(Array.from(e.target.files), targetSlot);
                e.target.value = '';
            });

            // Drag and drop on grid
            uploadGrid.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadGrid.classList.add('drag-over');
            });

            uploadGrid.addEventListener('dragleave', () => {
                uploadGrid.classList.remove('drag-over');
            });

            uploadGrid.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadGrid.classList.remove('drag-over');
                const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
                if (files.length > 0) handleFileUpload(files, null);
            });

            // Clipboard paste handler
            document.addEventListener('paste', async (e) => {
                if (!pasteTarget) return;

                const items = e.clipboardData?.items;
                if (!items) return;

                for (const item of items) {
                    if (item.type.startsWith('image/')) {
                        e.preventDefault();
                        const file = item.getAsFile();
                        if (file) {
                            handleFileUpload([file], pasteTarget.slotIndex);
                            clearPasteTarget();
                        }
                        break;
                    }
                }
            });

            // Keyboard handler
            document.addEventListener('keydown', (e) => {
                const lightbox = document.getElementById('video-lightbox');
                if (!lightbox.classList.contains('visible')) return;

                if (e.key === 'Escape') {
                    closeVideoLightbox();
                } else if (e.key === 'ArrowLeft') {
                    navigateVideoLightbox(-1);
                } else if (e.key === 'ArrowRight') {
                    navigateVideoLightbox(1);
                }
            });

            // Settings toggle
            document.getElementById('settings-toggle').addEventListener('click', () => {
                document.getElementById('settings-toggle').classList.toggle('open');
                document.getElementById('settings-content').classList.toggle('open');
            });

            // Model version change handler
            document.getElementById('model-version').addEventListener('change', (e) => {
                const version = e.target.value;
                const resolution1080p = document.getElementById('resolution-1080p');
                const resolutionSelect = document.getElementById('resolution');

                if (version === '1.0') {
                    // Show 1080p option for Seedance 1.0
                    resolution1080p.style.display = '';
                } else {
                    // Hide 1080p option for Seedance 1.5
                    resolution1080p.style.display = 'none';
                    // Reset to 720p if 1080p was selected
                    if (resolutionSelect.value === '1080p') {
                        resolutionSelect.value = '720p';
                    }
                }
                updateStats();
            });

            // Resolution change handler
            document.getElementById('resolution').addEventListener('change', () => updateStats());

            // Duration slider handler
            const durationSlider = document.getElementById('duration');
            const durationValue = document.getElementById('duration-value');
            durationSlider.addEventListener('input', () => {
                durationValue.textContent = durationSlider.value + 's';
                updateStats();
            });

            // Generate button
            document.getElementById('generate-btn').addEventListener('click', generateVideos);

            // Download all
            document.getElementById('download-all-btn').addEventListener('click', downloadAll);

            // Initialize speed controls
            initSpeedButtons();

            // Tab switching
            document.querySelectorAll('.mode-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    const tabName = tab.dataset.tab;
                    document.querySelectorAll('.mode-tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    tab.classList.add('active');
                    document.getElementById(`${tabName}-tab`).classList.add('active');
                });
            });

            // Initialize stitch functionality
            initStitch();

            console.log('ðŸŽ¬ Video Generator initialized');
        });

        // Render upload grid with slots
        function renderUploadGrid() {
            const grid = document.getElementById('upload-grid');
            grid.innerHTML = '';

            for (let i = 0; i < NUM_SLOTS; i++) {
                const slot = createUploadSlot(i);
                grid.appendChild(slot);
            }

            updateUploadCount();
        }

        function createUploadSlot(slotIndex) {
            const slot = document.createElement('div');
            slot.className = 'upload-slot';
            slot.dataset.slotIndex = slotIndex;

            const img = state.images[slotIndex];
            if (img) {
                const isSelected = img.selected !== false;
                const isUploading = img.uploading === true;
                slot.classList.add('filled');
                if (!isSelected) slot.classList.add('deselected');
                if (isUploading) slot.classList.add('uploading');
                slot.innerHTML = `
                    <img src="${img.dataUrl}" alt="Image ${slotIndex + 1}">
                    <button class="remove-btn" onclick="event.stopPropagation(); removeImage(${slotIndex})">Ã—</button>
                    ${isUploading ? '<div class="upload-spinner"></div>' : ''}
                `;
            } else {
                slot.innerHTML = '+';
            }

            // Single click: toggle selection if filled, or set paste target if empty
            slot.addEventListener('click', (e) => {
                if (e.target.closest('.remove-btn')) return;
                if (state.images[slotIndex]) {
                    // Toggle selection
                    toggleImageSelection(slotIndex);
                } else {
                    setPasteTarget(slotIndex);
                }
            });

            // Double-click opens file picker for empty slots
            slot.addEventListener('dblclick', (e) => {
                if (e.target.closest('.remove-btn')) return;
                if (!state.images[slotIndex]) {
                    const input = document.getElementById('file-input');
                    input.dataset.targetSlot = slotIndex;
                    input.click();
                }
            });

            return slot;
        }

        function toggleImageSelection(index) {
            const img = state.images[index];
            if (!img) return;
            img.selected = img.selected === false ? true : false;

            // Just toggle the class, don't re-render the whole grid
            const grid = document.getElementById('upload-grid');
            const slot = grid.children[index];
            if (slot) {
                slot.classList.toggle('deselected', img.selected === false);
            }
            updateStats();
        }

        function setPasteTarget(slotIndex) {
            clearPasteTarget();
            pasteTarget = { slotIndex };
            const grid = document.getElementById('upload-grid');
            if (grid.children[slotIndex]) {
                grid.children[slotIndex].classList.add('paste-ready');
            }
        }

        function clearPasteTarget() {
            document.querySelectorAll('.upload-slot.paste-ready').forEach(el => el.classList.remove('paste-ready'));
            pasteTarget = null;
        }

        function updateUploadCount() {
            const total = state.images.filter(img => img !== null).length;
            const selected = state.images.filter(img => img !== null && img.selected !== false).length;
            if (total === 0) {
                document.getElementById('upload-count').textContent = `0 / ${NUM_SLOTS} images`;
            } else {
                document.getElementById('upload-count').textContent = `${selected} selected / ${total} uploaded`;
            }
        }

        // Handle file uploads - show instantly, upload in background
        function handleFileUpload(files, startIndex) {
            // Reserve slots synchronously first to avoid race conditions
            const reservations = [];
            files.forEach((file, i) => {
                if (!file.type.startsWith('image/')) return;

                let index;
                if (startIndex !== null) {
                    index = startIndex + i;
                } else {
                    // Find next empty slot that hasn't been reserved
                    index = state.images.findIndex((img, idx) =>
                        !img && !reservations.some(r => r.index === idx)
                    );
                }
                if (index === -1 || index >= NUM_SLOTS) return;
                reservations.push({ file, index });
            });

            // Read files and show immediately, upload in background
            reservations.forEach(({ file, index }) => {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    const dataUrl = e.target.result;

                    // Show image immediately with uploading state
                    state.images[index] = { file, url: null, dataUrl, selected: true, uploading: true };
                    renderUploadGrid();
                    updateStats();

                    // Upload in background
                    const url = await uploadToStorage(file);
                    if (state.images[index]) {  // Still exists
                        state.images[index].url = url;
                        state.images[index].uploading = false;
                        renderUploadGrid();
                    }
                };
                reader.readAsDataURL(file);
            });
        }

        async function uploadToStorage(file) {
            try {
                const formData = new FormData();
                formData.append('image', file);

                const response = await fetch('/api/upload', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();
                return data.url;
            } catch (error) {
                console.error('Upload failed:', error);
                return null;
            }
        }

        window.removeImage = function(index) {
            // Remove the image and shift remaining images up (compact the array)
            state.images.splice(index, 1);
            // Add null at the end to maintain array length
            state.images.push(null);
            renderUploadGrid();
            updateStats();
        };

        // Render movement grid (only called once on init)
        function renderMovementGrid() {
            const grid = document.getElementById('movement-grid');

            // Separate individual movements and groups
            const individualMovements = VIDEO_MOVEMENTS.filter(m => !m.isGroup);
            const groupMovements = VIDEO_MOVEMENTS.filter(m => m.isGroup);

            // Render individual movements
            let html = individualMovements.map(movement => `
                <div class="movement-card ${state.selectedMovements.includes(movement.id) ? 'selected' : ''}"
                     data-id="${movement.id}">
                    <div class="video-wrapper">
                        <video src="${movement.thumbnail}" muted loop playsinline onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"></video>
                        <div class="movement-placeholder" style="display:none;">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                                <polygon points="5 3 19 12 5 21 5 3"></polygon>
                            </svg>
                        </div>
                    </div>
                    <span class="movement-name">${movement.name}</span>
                </div>
            `).join('');

            // Render group movements (different style - no video preview)
            html += groupMovements.map(movement => `
                <div class="movement-card is-group ${state.selectedMovements.includes(movement.id) ? 'selected' : ''}"
                     data-id="${movement.id}" data-is-group="true" title="${movement.description}">
                    <div class="video-wrapper">
                        <div class="group-icon">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                                <rect x="3" y="3" width="7" height="7" rx="1"></rect>
                                <rect x="14" y="3" width="7" height="7" rx="1"></rect>
                                <rect x="3" y="14" width="7" height="7" rx="1"></rect>
                                <rect x="14" y="14" width="7" height="7" rx="1"></rect>
                            </svg>
                            <span>Mix</span>
                        </div>
                    </div>
                    <span class="movement-name">${movement.name}</span>
                </div>
            `).join('');

            grid.innerHTML = html;

            // Add click and hover handlers for individual movements
            grid.querySelectorAll('.movement-card:not(.is-group)').forEach(card => {
                const video = card.querySelector('video');
                const id = card.dataset.id;

                // Click to toggle
                card.addEventListener('click', () => toggleMovement(id));

                // Hover to play video
                card.addEventListener('mouseenter', () => video.play().catch(() => {}));
                card.addEventListener('mouseleave', () => {
                    video.pause();
                    video.currentTime = 0;
                });
            });

            // Add click handlers for group movements
            grid.querySelectorAll('.movement-card.is-group').forEach(card => {
                const id = card.dataset.id;
                card.addEventListener('click', () => toggleMovement(id));
            });
        }

        function toggleMovement(id) {
            const index = state.selectedMovements.indexOf(id);
            if (index === -1) {
                state.selectedMovements.push(id);
            } else {
                state.selectedMovements.splice(index, 1);
            }

            // Just toggle the class, don't re-render
            const card = document.querySelector(`.movement-card[data-id="${id}"]`);
            if (card) {
                card.classList.toggle('selected', state.selectedMovements.includes(id));
            }
            updateStats();
        }

        // Calculate cost per video based on current settings
        function calculateVideoCost() {
            const model = document.getElementById('model-version').value;
            const resolution = document.getElementById('resolution').value;
            const duration = parseInt(document.getElementById('duration').value);

            // Resolution pixels
            const resMap = {
                '480p': { w: 854, h: 480 },
                '720p': { w: 1280, h: 720 },
                '1080p': { w: 1920, h: 1080 }
            };
            const res = resMap[resolution] || resMap['720p'];
            const fps = 24;

            // tokens = (height Ã— width Ã— FPS Ã— duration) / 1024
            const tokens = (res.h * res.w * fps * duration) / 1024;

            // Cost per million tokens
            // Seedance 1.5: $1.2/M (no audio), Seedance 1.0: $2.5/M
            const costPerMillion = model === '1.5' ? 1.2 : 2.5;
            return (tokens / 1_000_000) * costPerMillion;
        }

        // Update stats and button state
        function updateStats() {
            const allImages = state.images.filter(img => img !== null);
            const selectedImages = allImages.filter(img => img.selected !== false && img.url);  // selected AND uploaded
            const uploadingImages = allImages.filter(img => img.uploading);
            const numSelected = selectedImages.length;
            const numMovements = state.selectedMovements.length;
            const hasMovements = numMovements > 0;
            // Don't check state.generating - allow concurrent generation batches
            const canGenerate = numSelected > 0 && hasMovements && uploadingImages.length === 0;

            document.getElementById('generate-btn').disabled = !canGenerate;
            updateUploadCount();

            if (allImages.length === 0) {
                document.getElementById('stats-line').textContent = 'Upload images to start';
            } else if (uploadingImages.length > 0) {
                document.getElementById('stats-line').textContent = `Uploading ${uploadingImages.length} image${uploadingImages.length > 1 ? 's' : ''}...`;
            } else if (numSelected === 0) {
                document.getElementById('stats-line').textContent = `${allImages.length} uploaded - click to select`;
            } else if (!hasMovements) {
                document.getElementById('stats-line').textContent = `${numSelected} selected - choose movement(s)`;
            } else {
                const totalVideos = numSelected * numMovements;
                const costPerVideo = calculateVideoCost();
                const totalCost = (totalVideos * costPerVideo).toFixed(2);
                const perVideoCost = costPerVideo.toFixed(2);
                document.getElementById('stats-line').textContent = `${totalVideos} video${totalVideos > 1 ? 's' : ''} (${numSelected} image${numSelected > 1 ? 's' : ''} Ã— ${numMovements} movement${numMovements > 1 ? 's' : ''}) â€” $${perVideoCost}/video â€” $${totalCost} total`;
            }

            document.getElementById('download-all-btn').disabled = state.results.filter(r => r.videoUrl).length === 0;
        }

        // Analyze image and build prompt
        async function analyzeAndBuildPrompt(imageUrl, movement, settings) {
            try {
                // Analyze the image with movement context using Gemini (more permissive with fashion images)
                const analysisResponse = await fetch('/api/analyze-gemini', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        image_url: imageUrl,
                        prompt: `You are creating a video prompt for a VERY SUBTLE fashion video. The movement must be extremely minimal and controlled.

Analyze this fashion image briefly (pose, clothing, setting), then incorporate this movement: "${movement.description}"

CRITICAL RULES:
- Movement must be EXTREMELY SUBTLE and SLOW
- Only ONE small action, then freeze
- Most of the body stays completely still
- Like a photograph barely coming to life
- No extra movements, fidgeting, or expressions beyond what's specified

Write a 2-3 sentence prompt. Emphasize how minimal and controlled the movement is.

Example: "A woman in a black gown stands frozen. She slowly shifts her gaze once to the right, then freezes completely. Only her eyes move, everything else remains perfectly still."

Write ONLY the prompt.`
                    })
                });

                const analysisData = await analysisResponse.json();
                let enhancedPrompt = analysisData.content || '';

                // Detect content moderation refusals
                const refusalPhrases = ['i can\'t help', 'i cannot help', 'i\'m sorry', 'i am sorry', 'i\'m unable', 'i cannot assist', 'not able to', 'i can\'t assist'];
                const isRefusal = !enhancedPrompt || refusalPhrases.some(phrase => enhancedPrompt.toLowerCase().includes(phrase));

                if (isRefusal) {
                    console.warn(`âš ï¸ Analysis refused or empty, using fallback for: ${movement.name}`);
                    enhancedPrompt = movement.fallbackPrompt;
                }

                // Add fixed camera instructions to prompt if enabled
                if (settings.camera_fixed) {
                    enhancedPrompt = `Static locked-off camera, no camera movement. ${enhancedPrompt} The camera remains completely still and fixed throughout.`;
                }

                console.log(`ðŸ“ Enhanced prompt: ${enhancedPrompt.substring(0, 100)}...`);
                return enhancedPrompt;

            } catch (error) {
                console.error('Analysis failed, using fallback:', error);
                let fallback = movement.fallbackPrompt;
                if (settings.camera_fixed) {
                    fallback = `Static locked-off camera, no camera movement. ${fallback} The camera remains completely still and fixed throughout.`;
                }
                return fallback;
            }
        }

        // Classify image type for movement selection
        async function classifyImageType(imageUrl) {
            try {
                const response = await fetch('/api/analyze-gemini', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        image_url: imageUrl,
                        prompt: `Classify this image into ONE category. Reply with ONLY one word:
- "face" if it shows a person's face/head (portrait, headshot, close-up with visible face)
- "body" if it shows a person's body (full body, half body, fashion shot with person)
- "product" if it shows a product without a person (shoes, bags, clothing on hanger/mannequin, accessories, objects)

Reply with exactly one word: face, body, or product`
                    })
                });
                const data = await response.json();
                const content = (data.content || '').toLowerCase().trim();

                // Extract the type from response
                if (content.includes('face')) return 'face';
                if (content.includes('body')) return 'body';
                if (content.includes('product')) return 'product';

                // Default to body if unclear
                return 'body';
            } catch (error) {
                console.warn('Image classification failed, defaulting to body:', error);
                return 'body';
            }
        }

        // Generate videos
        async function generateVideos() {
            // Only use selected images that have been uploaded
            const selectedImages = state.images.filter(img => img !== null && img.selected !== false && img.url);
            if (selectedImages.length === 0 || state.selectedMovements.length === 0) return;

            state.generating = true;  // Track that we're generating (for stats display)
            // Don't clear state.results - append to existing

            const settings = {
                model_version: document.getElementById('model-version').value,
                resolution: document.getElementById('resolution').value,
                duration: parseInt(document.getElementById('duration').value),
                aspect_ratio: document.getElementById('aspect-ratio').value,
                camera_fixed: document.getElementById('camera-fixed').checked
            };

            // Check if any groups are selected
            const hasGroups = state.selectedMovements.some(id => {
                const m = getMovementById(id);
                return m && m.isGroup;
            });

            // If groups are selected, classify all images first
            let imageTypes = null;
            if (hasGroups) {
                console.log('ðŸ” Classifying images for smart movement selection...');
                startLoadingAnimation('Analyzing images...');

                // Classify all images in parallel
                imageTypes = await Promise.all(
                    selectedImages.map(img => classifyImageType(img.url))
                );
                console.log('ðŸ“Š Image types:', imageTypes);
            }

            // Build all tasks - handling groups differently
            const tasks = [];
            const timestamp = Date.now();
            const numImages = selectedImages.length;

            // Pre-generate random movements for each group (with image type awareness)
            const groupMovementsMap = {};
            for (const movementId of state.selectedMovements) {
                const movementDef = getMovementById(movementId);
                if (movementDef && movementDef.isGroup) {
                    // Get shuffled unique movements for all images, filtered by type
                    groupMovementsMap[movementId] = getRandomsFromGroup(movementId, numImages, imageTypes);
                }
            }

            for (let i = 0; i < selectedImages.length; i++) {
                const image = selectedImages[i];

                for (let j = 0; j < state.selectedMovements.length; j++) {
                    const movementId = state.selectedMovements[j];
                    const movementDef = getMovementById(movementId);

                    if (movementDef && movementDef.isGroup) {
                        // It's a group - use the pre-shuffled movement for this image index
                        const randomMovement = groupMovementsMap[movementId][i];
                        if (randomMovement) {
                            const resultId = `result-${timestamp}-${i}-${j}`;
                            tasks.push({
                                image,
                                movement: randomMovement,
                                resultId,
                                displayName: `${randomMovement.name} (${movementDef.name})`
                            });
                        }
                    } else if (movementDef) {
                        // Regular individual movement
                        const resultId = `result-${timestamp}-${i}-${j}`;
                        tasks.push({
                            image,
                            movement: movementDef,
                            resultId,
                            displayName: movementDef.name
                        });
                    }
                }
            }

            const totalTasks = tasks.length;
            if (totalTasks === 0) return;

            // Show progress and loader
            document.getElementById('progress-section').classList.add('visible');
            document.getElementById('progress-count').textContent = `0 / ${totalTasks}`;
            document.getElementById('progress-bar').style.width = '0%';
            // Don't disable generate button - allow concurrent batches

            // Start the loader animation
            startLoadingAnimation(`Generating ${totalTasks} video${totalTasks > 1 ? 's' : ''}...`);

            // Show results section (don't clear - append to existing)
            document.getElementById('results-section').classList.add('visible');

            let completed = 0;

            // Calculate cost per video for this batch
            const costPerVideo = calculateVideoCost();

            // Add placeholders for all tasks
            for (const task of tasks) {
                addResultPlaceholder(task.resultId, task.displayName, task.image.dataUrl, costPerVideo);
            }

            // Process all tasks in parallel
            const promises = tasks.map(async ({ image, movement, resultId, displayName }) => {
                let prompt = '';
                try {
                    // Analyze image and build enhanced prompt
                    updateResultStatus(resultId, 'Analyzing...');
                    prompt = await analyzeAndBuildPrompt(image.url, movement, settings);

                    // Generate video
                    updateResultStatus(resultId, 'Generating...');

                    const response = await fetch('/api/video/seedance', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            image_url: image.url,
                            prompt: prompt,
                            ...settings
                        })
                    });

                    const data = await response.json();

                    if (data.video?.url) {
                        const result = {
                            id: resultId,
                            videoUrl: data.video.url,
                            url: data.video.url,  // For lightbox compatibility
                            movement: displayName,
                            prompt: prompt,
                            sourceImage: image.dataUrl
                        };
                        state.results.push(result);
                        updateResultWithVideo(resultId, data.video.url, prompt);
                        console.log(`âœ… Video complete (${displayName})`);
                    } else {
                        throw new Error(data.error || 'No video returned');
                    }

                } catch (error) {
                    console.error(`âŒ Video failed:`, error);
                    updateResultStatus(resultId, `Failed: ${error.message}`);
                    state.results.push({
                        id: resultId,
                        error: error.message,
                        movement: displayName,
                        prompt: prompt,
                        sourceImage: image.dataUrl
                    });
                }

                // Update progress
                completed++;
                document.getElementById('progress-count').textContent = `${completed} / ${totalTasks}`;
                document.getElementById('progress-bar').style.width = `${(completed / totalTasks) * 100}%`;
            });

            // Wait for all to complete
            await Promise.all(promises);

            // Stop the loader
            stopLoadingAnimation();

            document.getElementById('progress-status').textContent = 'Complete!';
            state.generating = false;
            updateStats();
        }

        // Add result placeholder
        function addResultPlaceholder(id, movementName, sourceImage, cost) {
            const resultsSection = document.getElementById('results-section');
            const grid = document.getElementById('results-grid');

            // Show results section
            resultsSection.classList.add('visible');

            const html = `
                <div class="result-card generating" id="${id}">
                    <div class="result-placeholder">
                        <div class="spinner"></div>
                        <p id="${id}-status">Preparing...</p>
                    </div>
                    <div class="result-info">
                        <div class="result-movement">${movementName}</div>
                        <div class="result-cost">$${cost.toFixed(2)}</div>
                    </div>
                </div>
            `;
            grid.insertAdjacentHTML('beforeend', html);
        }

        // Update result status
        function updateResultStatus(id, status) {
            const statusEl = document.getElementById(`${id}-status`);
            if (statusEl) statusEl.textContent = status;
        }

        // Update result with video
        function updateResultWithVideo(id, videoUrl, prompt) {
            const card = document.getElementById(id);
            if (!card) return;

            card.classList.remove('generating');
            card.dataset.videoUrl = videoUrl;
            card.dataset.prompt = prompt;

            const placeholder = card.querySelector('.result-placeholder');
            if (placeholder) {
                placeholder.outerHTML = `
                    <video class="result-video" src="${videoUrl}" loop muted playsinline></video>
                `;
            }

            // Add click handler to open lightbox and hover to play
            const video = card.querySelector('.result-video');
            if (video) {
                video.addEventListener('click', (e) => {
                    e.preventDefault();
                    openVideoLightbox(id);
                });
                video.style.cursor = 'pointer';

                // Play on hover only
                card.addEventListener('mouseenter', () => video.play().catch(() => {}));
                card.addEventListener('mouseleave', () => {
                    video.pause();
                    video.currentTime = 0;
                });
            }

            // Add actions
            const info = card.querySelector('.result-info');
            if (info && !info.querySelector('.result-actions')) {
                info.innerHTML += `
                    <div class="result-actions">
                        <button class="btn btn--secondary" onclick="event.stopPropagation(); downloadVideo('${videoUrl}', '${id}')">Download</button>
                    </div>
                `;
            }
        }

        // Open video in lightbox
        function openVideoLightbox(id) {
            const completedVideos = state.results.filter(r => r.videoUrl);
            const index = completedVideos.findIndex(r => r.id === id);
            if (index === -1) return;

            state.lightboxIndex = index;
            updateVideoLightboxContent();
            document.getElementById('video-lightbox').classList.add('visible');
        }

        function closeVideoLightbox() {
            const lightbox = document.getElementById('video-lightbox');
            const video = document.getElementById('lightbox-video');
            lightbox.classList.remove('visible');
            video.pause();
        }

        function navigateVideoLightbox(direction) {
            const completedVideos = state.results.filter(r => r.videoUrl);
            const newIndex = state.lightboxIndex + direction;
            if (newIndex >= 0 && newIndex < completedVideos.length) {
                state.lightboxIndex = newIndex;
                updateVideoLightboxContent();
            }
        }

        function updateVideoLightboxContent() {
            const completedVideos = state.results.filter(r => r.videoUrl);
            const result = completedVideos[state.lightboxIndex];
            if (!result) return;

            const video = document.getElementById('lightbox-video');
            const promptEl = document.getElementById('lightbox-video-prompt');
            const movementEl = document.getElementById('lightbox-video-movement');
            const downloadBtn = document.getElementById('lightbox-video-download');

            video.src = result.videoUrl;
            video.playbackRate = state.playbackSpeed;
            promptEl.textContent = result.prompt || 'No prompt available';
            movementEl.textContent = result.movement || '';
            downloadBtn.onclick = () => downloadVideo(result.videoUrl, result.id);

            // Update slider display to match current speed
            const slider = document.getElementById('speed-slider');
            const speedValue = document.getElementById('speed-value');
            if (slider) slider.value = state.playbackSpeed;
            if (speedValue) speedValue.textContent = state.playbackSpeed.toFixed(1) + 'x';
            updateDownloadButtonText();

            video.play();
        }

        // Set playback speed
        function setPlaybackSpeed(speed) {
            state.playbackSpeed = speed;
            const video = document.getElementById('lightbox-video');
            if (video) {
                video.playbackRate = speed;
            }
            // Update slider value display
            const speedValue = document.getElementById('speed-value');
            if (speedValue) {
                speedValue.textContent = speed.toFixed(1) + 'x';
            }
            // Update slider position
            const slider = document.getElementById('speed-slider');
            if (slider) {
                slider.value = speed;
            }
            updateDownloadButtonText();
        }

        // Update download button text based on speed
        function updateDownloadButtonText() {
            const downloadBtn = document.getElementById('lightbox-video-download');
            if (downloadBtn) {
                downloadBtn.textContent = state.playbackSpeed !== 1
                    ? `Download Video (${state.playbackSpeed.toFixed(1)}x)`
                    : 'Download Video';
            }
        }

        // Initialize speed slider
        function initSpeedButtons() {
            const slider = document.getElementById('speed-slider');
            if (slider) {
                // Update on input (real-time as user drags)
                slider.addEventListener('input', (e) => {
                    const speed = parseFloat(e.target.value);
                    setPlaybackSpeed(speed);
                });
            }
        }

        // Generate filename with proper naming convention
        function generateFilename(movement, index) {
            const now = new Date();
            const yy = String(now.getFullYear()).slice(-2);
            const mm = String(now.getMonth() + 1).padStart(2, '0');
            const dd = String(now.getDate()).padStart(2, '0');
            const hh = String(now.getHours()).padStart(2, '0');
            const min = String(now.getMinutes()).padStart(2, '0');
            const num = String(index).padStart(2, '0');

            // Clean movement name (remove spaces, capitalize)
            const movementName = movement.replace(/\s+/g, '');

            return `Setset_Video_${movementName}_${yy}${mm}${dd}_${hh}${min}_${num}.mp4`;
        }

        // Download video (with speed adjustment if needed)
        window.downloadVideo = async function(url, resultId) {
            // Find the result to get movement name
            const result = state.results.find(r => r.id === resultId);
            const movement = result?.movement || 'Unknown';
            const resultIndex = state.results.filter(r => r.videoUrl).indexOf(result) + 1;

            let filename = generateFilename(movement, resultIndex);

            // Add speed suffix if not 1x
            if (state.playbackSpeed !== 1) {
                const speedSuffix = `_${state.playbackSpeed}x`;
                const extIndex = filename.lastIndexOf('.');
                filename = extIndex > 0
                    ? filename.slice(0, extIndex) + speedSuffix + filename.slice(extIndex)
                    : filename + speedSuffix + '.mp4';
            }

            try {
                let blob;

                // If speed is not 1x, process with server-side FFmpeg
                if (state.playbackSpeed !== 1) {
                    const downloadBtn = document.getElementById('lightbox-video-download');
                    const originalText = downloadBtn?.textContent;

                    // Animated progress indicator
                    const stages = [
                        'Downloading video...',
                        'Processing 20%...',
                        'Processing 40%...',
                        'Processing 60%...',
                        'Processing 80%...',
                        'Finalizing...'
                    ];
                    let stageIndex = 0;

                    if (downloadBtn) {
                        downloadBtn.textContent = stages[0];
                        downloadBtn.disabled = true;
                    }

                    // Animate through stages (estimated timing ~3s per stage)
                    const progressInterval = setInterval(() => {
                        stageIndex++;
                        if (stageIndex < stages.length && downloadBtn) {
                            downloadBtn.textContent = stages[stageIndex];
                        }
                    }, 3000);

                    try {
                        const response = await fetch('/api/video/speed', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ url, speed: state.playbackSpeed })
                        });

                        if (!response.ok) {
                            const error = await response.json();
                            throw new Error(error.error || 'Speed adjustment failed');
                        }

                        blob = await response.blob();
                    } finally {
                        clearInterval(progressInterval);
                        if (downloadBtn) {
                            downloadBtn.textContent = originalText || 'Download Video';
                            downloadBtn.disabled = false;
                        }
                    }
                } else {
                    // Normal download at 1x speed
                    const response = await fetch(`/api/proxy-download?url=${encodeURIComponent(url)}`);
                    blob = await response.blob();
                }

                const downloadUrl = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = downloadUrl;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(downloadUrl);
            } catch (error) {
                console.error('Download failed:', error);
                alert('Download failed: ' + error.message);
                // Fallback: open in new tab
                window.open(url, '_blank');
            }
        }

        // Download all videos
        async function downloadAll() {
            const videos = state.results.filter(r => r.videoUrl);
            for (const result of videos) {
                await downloadVideo(result.videoUrl, result.id);
                await new Promise(r => setTimeout(r, 500));
            }
        }

        // =============================================
        // STITCH FUNCTIONALITY
        // =============================================

        function initStitch() {
            const dropzone = document.getElementById('stitch-dropzone');
            const stitchFileInput = document.getElementById('stitch-file-input');

            // File input handler
            stitchFileInput.addEventListener('change', (e) => {
                handleStitchFiles(Array.from(e.target.files));
                e.target.value = '';
            });

            // Click dropzone to upload
            dropzone.addEventListener('click', () => {
                stitchFileInput.click();
            });

            // Drag and drop on dropzone
            dropzone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropzone.classList.add('drag-over');
            });

            dropzone.addEventListener('dragleave', (e) => {
                if (!dropzone.contains(e.relatedTarget)) {
                    dropzone.classList.remove('drag-over');
                }
            });

            dropzone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropzone.classList.remove('drag-over');
                const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('video/'));
                if (files.length > 0) handleStitchFiles(files);
            });

            // Stitch button
            document.getElementById('stitch-btn').addEventListener('click', stitchVideos);

            // Download stitched video
            document.getElementById('stitch-download-btn').addEventListener('click', downloadStitchedVideo);

            console.log('âœ‚ï¸ Stitch functionality initialized');
        }

        async function handleStitchFiles(files) {
            for (const file of files) {
                if (!file.type.startsWith('video/')) continue;

                // Create video element to get metadata
                const video = document.createElement('video');
                video.preload = 'metadata';

                const url = URL.createObjectURL(file);
                video.src = url;

                await new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        const duration = video.duration;
                        const width = video.videoWidth;
                        const height = video.videoHeight;
                        const aspectRatio = width / height;

                        state.stitchVideos.push({
                            file,
                            url,
                            duration,
                            width,
                            height,
                            aspectRatio,
                            inPoint: 0,
                            outPoint: duration
                        });

                        resolve();
                    };
                    video.onerror = resolve;
                });
            }

            renderStitchGrid();
            updateStitchStats();
        }

        function captureVideoThumbnail(video) {
            // Seek to 0.5 seconds or 10% of duration
            const seekTime = Math.min(0.5, video.duration * 0.1);

            return new Promise((resolve) => {
                video.currentTime = seekTime;
                video.onseeked = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(video, 0, 0);
                    resolve(canvas.toDataURL('image/jpeg', 0.7));
                };
            });
        }

        function renderStitchGrid() {
            const grid = document.getElementById('stitch-grid');
            const videosSection = document.getElementById('stitch-videos-section');
            const dropzone = document.getElementById('stitch-dropzone');
            grid.innerHTML = '';

            // Show/hide sections based on video count
            if (state.stitchVideos.length > 0) {
                videosSection.style.display = 'block';
                dropzone.classList.add('has-videos');
            } else {
                videosSection.style.display = 'none';
                dropzone.classList.remove('has-videos');
            }

            state.stitchVideos.forEach((vid, index) => {
                const slot = document.createElement('div');
                slot.className = 'stitch-slot';
                slot.dataset.index = index;
                slot.draggable = true;

                // Calculate width based on aspect ratio (height is fixed at 120px)
                const slotHeight = 120;
                const slotWidth = Math.round(slotHeight * vid.aspectRatio);
                slot.style.width = `${slotWidth}px`;

                const isTrimmed = vid.inPoint > 0.1 || vid.outPoint < vid.duration - 0.1;
                const effectiveDuration = vid.outPoint - vid.inPoint;

                slot.innerHTML = `
                    <video src="${vid.url}" muted></video>
                    <span class="slot-number">${index + 1}</span>
                    <span class="slot-duration">${formatTime(effectiveDuration)}</span>
                    ${isTrimmed ? '<span class="trim-indicator">Trimmed</span>' : ''}
                    <button class="remove-btn" onclick="event.stopPropagation(); removeStitchVideo(${index})">Ã—</button>
                `;

                // Click to open trim editor
                slot.addEventListener('click', (e) => {
                    if (e.target.closest('.remove-btn')) return;
                    openTrimModal(index);
                });

                // Hover to play
                const video = slot.querySelector('video');
                slot.addEventListener('mouseenter', () => {
                    video.currentTime = vid.inPoint;
                    video.play().catch(() => {});
                });
                slot.addEventListener('mouseleave', () => {
                    video.pause();
                    video.currentTime = vid.inPoint;
                });

                // Drag handlers for reordering
                slot.addEventListener('dragstart', (e) => {
                    state.stitchDragIndex = index;
                    slot.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                });

                slot.addEventListener('dragend', () => {
                    slot.classList.remove('dragging');
                    state.stitchDragIndex = null;
                    document.querySelectorAll('.stitch-slot.drag-target').forEach(s => s.classList.remove('drag-target'));
                });

                slot.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    if (state.stitchDragIndex !== null && state.stitchDragIndex !== index) {
                        slot.classList.add('drag-target');
                    }
                });

                slot.addEventListener('dragleave', () => {
                    slot.classList.remove('drag-target');
                });

                slot.addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    slot.classList.remove('drag-target');

                    if (state.stitchDragIndex !== null && state.stitchDragIndex !== index) {
                        // Reorder
                        const draggedVideo = state.stitchVideos.splice(state.stitchDragIndex, 1)[0];
                        const newIndex = state.stitchDragIndex < index ? index : index;
                        state.stitchVideos.splice(newIndex, 0, draggedVideo);
                        renderStitchGrid();
                        updateStitchStats();
                    }
                });

                grid.appendChild(slot);
            });
        }

        window.removeStitchVideo = function(index) {
            URL.revokeObjectURL(state.stitchVideos[index].url);
            state.stitchVideos.splice(index, 1);
            renderStitchGrid();
            updateStitchStats();
        };

        function updateStitchStats() {
            const count = state.stitchVideos.length;
            document.getElementById('stitch-count').textContent = `${count} video${count !== 1 ? 's' : ''}`;

            const canStitch = count >= 2;
            document.getElementById('stitch-btn').disabled = !canStitch;

            if (count === 0) {
                document.getElementById('stitch-stats').textContent = 'Drop video files to start';
            } else if (count === 1) {
                document.getElementById('stitch-stats').textContent = 'Add at least one more video';
            } else {
                const totalDuration = state.stitchVideos.reduce((sum, v) => sum + (v.outPoint - v.inPoint), 0);
                document.getElementById('stitch-stats').textContent = `${count} videos â€” ${formatTime(totalDuration)} total`;
            }
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // =============================================
        // TRIM MODAL
        // =============================================

        function openTrimModal(index) {
            state.trimVideoIndex = index;
            const vid = state.stitchVideos[index];

            const modal = document.getElementById('trim-modal');
            const video = document.getElementById('trim-video');

            video.src = vid.url;
            video.currentTime = vid.inPoint;

            modal.classList.add('visible');

            video.onloadedmetadata = () => {
                updateTrimUI();
                setupTrimHandlers();
            };
        }

        function closeTrimModal() {
            document.getElementById('trim-modal').classList.remove('visible');
            const video = document.getElementById('trim-video');
            video.pause();
            video.src = '';
            state.trimVideoIndex = null;
        }

        function toggleTrimPlayback() {
            const video = document.getElementById('trim-video');
            if (video.paused) {
                video.play();
            } else {
                video.pause();
            }
        }

        function updateTrimUI() {
            if (state.trimVideoIndex === null) return;
            const vid = state.stitchVideos[state.trimVideoIndex];
            const video = document.getElementById('trim-video');
            const duration = video.duration;

            // Update time labels
            document.getElementById('trim-time-start').textContent = formatTime(0);
            document.getElementById('trim-time-end').textContent = formatTime(duration);
            document.getElementById('trim-time-range').textContent =
                `Selected: ${formatTime(vid.inPoint)} - ${formatTime(vid.outPoint)}`;

            // Update selection box position
            const selection = document.getElementById('trim-selection');
            const inPercent = (vid.inPoint / duration) * 100;
            const outPercent = (vid.outPoint / duration) * 100;
            selection.style.left = `${inPercent}%`;
            selection.style.width = `${outPercent - inPercent}%`;
        }

        function setupTrimHandlers() {
            const timeline = document.getElementById('trim-timeline');
            const video = document.getElementById('trim-video');
            const selection = document.getElementById('trim-selection');
            const handleIn = document.getElementById('trim-handle-in');
            const handleOut = document.getElementById('trim-handle-out');
            const playhead = document.getElementById('trim-playhead');

            let dragging = null; // 'in', 'out', 'scrub'

            const getTimeFromEvent = (e) => {
                const rect = timeline.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const percent = Math.max(0, Math.min(1, x / rect.width));
                return percent * video.duration;
            };

            // Handle dragging
            handleIn.onmousedown = (e) => {
                e.preventDefault();
                dragging = 'in';
            };

            handleOut.onmousedown = (e) => {
                e.preventDefault();
                dragging = 'out';
            };

            timeline.onmousedown = (e) => {
                if (e.target === handleIn || e.target === handleOut) return;
                dragging = 'scrub';
                const time = getTimeFromEvent(e);
                video.currentTime = time;
            };

            document.onmousemove = (e) => {
                if (!dragging || state.trimVideoIndex === null) return;

                const vid = state.stitchVideos[state.trimVideoIndex];
                const time = getTimeFromEvent(e);

                if (dragging === 'in') {
                    vid.inPoint = Math.max(0, Math.min(time, vid.outPoint - 0.1));
                    video.currentTime = vid.inPoint;
                } else if (dragging === 'out') {
                    vid.outPoint = Math.max(vid.inPoint + 0.1, Math.min(time, video.duration));
                    video.currentTime = vid.outPoint;
                } else if (dragging === 'scrub') {
                    video.currentTime = time;
                }

                updateTrimUI();
            };

            document.onmouseup = () => {
                dragging = null;
            };

            // Playhead tracking
            video.ontimeupdate = () => {
                const percent = (video.currentTime / video.duration) * 100;
                playhead.style.left = `${percent}%`;
            };
        }

        function resetTrim() {
            if (state.trimVideoIndex === null) return;
            const vid = state.stitchVideos[state.trimVideoIndex];
            const video = document.getElementById('trim-video');
            vid.inPoint = 0;
            vid.outPoint = video.duration;
            updateTrimUI();
        }

        function applyTrim() {
            closeTrimModal();
            renderStitchGrid();
            updateStitchStats();
        }

        // Play only the selected in/out portion
        function playSelection() {
            if (state.trimVideoIndex === null) return;
            const vid = state.stitchVideos[state.trimVideoIndex];
            const video = document.getElementById('trim-video');
            const btn = document.getElementById('play-selection-btn');

            // Jump to in point and play
            video.currentTime = vid.inPoint;
            video.play();

            // Update button to show playing state
            btn.textContent = 'â¸ Playing...';

            // Stop at out point
            const checkTime = () => {
                if (video.currentTime >= vid.outPoint) {
                    video.pause();
                    video.currentTime = vid.inPoint;
                    btn.textContent = 'â–¶ Play Selection';
                    video.removeEventListener('timeupdate', checkTime);
                }
            };
            video.addEventListener('timeupdate', checkTime);

            // Reset button if paused manually
            video.addEventListener('pause', () => {
                btn.textContent = 'â–¶ Play Selection';
            }, { once: true });
        }

        // =============================================
        // STITCH API
        // =============================================

        async function stitchVideos() {
            if (state.stitchVideos.length < 2) return;

            const btn = document.getElementById('stitch-btn');
            const loader = document.getElementById('stitch-loader');
            const loaderMessage = document.getElementById('stitch-loader-message');
            const loaderProgress = document.getElementById('stitch-loader-progress');

            btn.disabled = true;
            btn.textContent = 'Stitching...';
            loader.style.display = 'block';

            const stitchMessages = [
                'Preparing your clips...',
                'Analyzing video segments...',
                'Trimming to your selections...',
                'Aligning audio tracks...',
                'Merging video streams...',
                'Encoding final output...',
                'Almost there...',
                'Finalizing...'
            ];

            let messageIndex = 0;
            const messageInterval = setInterval(() => {
                messageIndex = (messageIndex + 1) % stitchMessages.length;
                loaderMessage.textContent = stitchMessages[messageIndex];
            }, 2500);

            try {
                // Create FormData with all videos and their trim points
                const formData = new FormData();
                const totalSize = state.stitchVideos.reduce((sum, v) => sum + v.file.size, 0);
                const totalSizeMB = (totalSize / (1024 * 1024)).toFixed(1);

                loaderMessage.textContent = 'Preparing your clips...';
                loaderProgress.textContent = `${state.stitchVideos.length} videos â€¢ ${totalSizeMB} MB`;

                for (let i = 0; i < state.stitchVideos.length; i++) {
                    const vid = state.stitchVideos[i];
                    formData.append('videos', vid.file);
                    formData.append(`inPoint_${i}`, vid.inPoint.toString());
                    formData.append(`outPoint_${i}`, vid.outPoint.toString());
                }

                // Check if Instagram 4:5 crop is enabled
                const cropInstagram = document.getElementById('stitch-instagram').checked;
                if (cropInstagram) {
                    formData.append('aspectRatio', '4:5');
                }

                loaderMessage.textContent = 'Uploading videos to server...';

                const response = await fetch('/api/video/stitch', {
                    method: 'POST',
                    body: formData
                });

                loaderMessage.textContent = 'Processing with FFmpeg...';
                loaderProgress.textContent = 'Trimming and concatenating clips';

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Stitch failed');
                }

                loaderMessage.textContent = 'Downloading result...';

                const blob = await response.blob();
                const resultUrl = URL.createObjectURL(blob);
                const resultSizeMB = (blob.size / (1024 * 1024)).toFixed(1);

                loaderMessage.textContent = 'Complete!';
                loaderProgress.textContent = `Output: ${resultSizeMB} MB`;

                // Show result
                const resultSection = document.getElementById('stitch-result-section');
                const resultVideo = document.getElementById('stitch-result-video');
                resultSection.classList.add('visible');
                resultVideo.src = resultUrl;

                // Store for download
                window.stitchedVideoBlob = blob;

            } catch (error) {
                console.error('Stitch failed:', error);
                alert('Failed to stitch videos: ' + error.message);
            } finally {
                clearInterval(messageInterval);
                btn.disabled = false;
                btn.textContent = 'Stitch Videos';
                setTimeout(() => { loader.style.display = 'none'; }, 1500);
            }
        }

        function downloadStitchedVideo() {
            if (!window.stitchedVideoBlob) return;

            const now = new Date();
            const timestamp = `${now.getFullYear()}${(now.getMonth()+1).toString().padStart(2,'0')}${now.getDate().toString().padStart(2,'0')}_${now.getHours().toString().padStart(2,'0')}${now.getMinutes().toString().padStart(2,'0')}`;
            const filename = `Setset_Stitched_${timestamp}.mp4`;

            const url = URL.createObjectURL(window.stitchedVideoBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
