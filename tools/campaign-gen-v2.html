<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Campaign Gen v2</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ“¸</text></svg>">
    <link rel="stylesheet" href="/shared/css/tokens.css">
    <link rel="stylesheet" href="/shared/css/base.css">
    <link rel="stylesheet" href="/shared/css/components.css">
    <style>
        .container {
            max-width: 1200px;
        }

        /* Section styling */
        .section {
            background: var(--white);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-md);
            padding: var(--space-md);
            margin-bottom: var(--space-md);
        }

        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--space-sm);
        }

        .section-title {
            font-size: var(--text-sm);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--carbon);
        }

        .section-badge {
            font-size: var(--text-2xs);
            padding: 2px 8px;
            border-radius: var(--radius-sm);
            background: var(--off-white);
            color: var(--slate);
        }

        .section-badge.required {
            background: var(--jet);
            color: var(--white);
        }

        /* Talent Grid - 12 columns, responsive */
        .talent-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: var(--space-xs);
        }

        @media (min-width: 800px) {
            .talent-grid {
                grid-template-columns: repeat(12, 1fr);
            }
        }

        .talent-card {
            position: relative;
            aspect-ratio: 3/4;
            border-radius: var(--radius-sm);
            overflow: hidden;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all var(--transition-fast);
        }

        .talent-card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .talent-card:hover {
            border-color: var(--ash-grey);
        }

        .talent-card.selected {
            border-color: var(--jet);
        }

        .talent-card.selected::after {
            content: 'âœ“';
            position: absolute;
            top: 4px;
            right: 4px;
            width: 20px;
            height: 20px;
            background: var(--jet);
            color: var(--white);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .talent-card.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* Talent names removed per user request */

        /* Mood Board Grid - 12 columns, responsive */
        .moodboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: var(--space-xs);
        }

        @media (min-width: 800px) {
            .moodboard-grid {
                grid-template-columns: repeat(12, 1fr);
            }
        }

        .upload-slot {
            aspect-ratio: 3/4;
            border: 1px dashed var(--gainsboro);
            border-radius: var(--radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            background: var(--off-white);
            transition: all var(--transition-fast);
        }

        .upload-slot:hover {
            border-color: var(--ash-grey);
        }

        .upload-slot.filled {
            border-style: solid;
            border-color: transparent;
        }

        .upload-slot.filled img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .upload-slot .plus {
            font-size: 18px;
            font-weight: 300;
            color: var(--ash-grey);
        }

        .upload-slot .remove-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 20px;
            height: 20px;
            background: rgba(0,0,0,0.7);
            color: var(--white);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 12px;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .upload-slot.filled:hover .remove-btn {
            display: flex;
        }

        .upload-slot.deselected {
            opacity: 0.4;
        }

        .upload-slot.deselected img {
            filter: grayscale(100%);
        }

        /* Product Grid - 12 columns, responsive */
        .product-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: var(--space-xs);
        }

        @media (min-width: 800px) {
            .product-grid {
                grid-template-columns: repeat(12, 1fr);
            }
        }

        /* Output Grid - 12 columns, responsive */
        .output-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
            gap: var(--space-xs);
        }

        @media (min-width: 900px) {
            .output-grid {
                grid-template-columns: repeat(12, 1fr);
            }
        }

        /* Output tabs */
        .output-tabs {
            display: flex;
            gap: var(--space-xs);
            margin-bottom: var(--space-sm);
        }

        .output-tab {
            padding: 6px 16px;
            font-size: var(--text-xs);
            font-weight: 500;
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-sm);
            background: var(--off-white);
            color: var(--slate);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .output-tab:hover {
            border-color: var(--ash-grey);
        }

        .output-tab.active {
            background: var(--jet);
            color: var(--white);
            border-color: var(--jet);
        }

        /* Aspect ratio buttons */
        .aspect-buttons {
            display: flex;
            gap: 4px;
        }

        .aspect-btn {
            padding: 6px 12px;
            font-size: var(--text-xs);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-sm);
            background: var(--off-white);
            color: var(--slate);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .aspect-btn:hover {
            border-color: var(--ash-grey);
        }

        .aspect-btn.active {
            background: var(--jet);
            color: var(--white);
            border-color: var(--jet);
        }

        /* Product count slider in product mode */
        .product-count-row {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            margin-bottom: var(--space-sm);
        }

        .product-count-row label {
            font-size: var(--text-xs);
            color: var(--slate);
        }

        .product-count-row input[type="range"] {
            flex: 1;
            max-width: 150px;
        }

        .product-count-row .count-value {
            font-size: var(--text-sm);
            font-weight: 600;
            min-width: 20px;
        }

        /* Drag hover state */
        .moodboard-grid.drag-over,
        .product-grid.drag-over {
            background: rgba(0, 0, 0, 0.03);
            border-radius: var(--radius-md);
        }

        .moodboard-grid.drag-over .upload-slot:not(.filled),
        .product-grid.drag-over .upload-slot:not(.filled) {
            border-color: var(--jet);
            background: rgba(0, 0, 0, 0.05);
        }

        /* Inline loader with studio messages */
        .inline-loader {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: var(--space-lg);
            background: var(--off-white);
            border-radius: var(--radius-md);
            margin-bottom: var(--space-md);
        }

        .inline-loader.visible {
            display: flex;
        }

        .loader-message {
            font-size: var(--text-lg);
            font-weight: 600;
            background: linear-gradient(90deg,
                rgba(0, 47, 167, 0.4) 0%,
                rgba(0, 47, 167, 1) 50%,
                rgba(0, 47, 167, 0.4) 100%);
            background-size: 200% 100%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: sweep 2s ease-in-out infinite;
        }

        .loader-message.fade-out {
            animation: fade-out 0.25s ease-out forwards;
        }

        .loader-message.fade-in {
            animation: fade-in 0.25s ease-out forwards, sweep 2s ease-in-out infinite;
        }

        @keyframes sweep {
            0% { background-position: 100% 0; }
            100% { background-position: -100% 0; }
        }

        @keyframes fade-out {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        @keyframes fade-in {
            0% { opacity: 0; }
            100% { opacity: 1; }
        }

        .loader-progress {
            font-size: var(--text-sm);
            color: var(--slate);
            margin-top: var(--space-xs);
        }

        .output-slot {
            aspect-ratio: 3/4;
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-sm);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            background: var(--off-white);
            transition: all var(--transition-fast);
            padding: var(--space-xs);
        }

        .output-slot:hover {
            border-color: var(--ash-grey);
        }

        .output-slot.active {
            border-color: var(--ash-grey);
            background: var(--white);
        }

        .output-type {
            font-size: var(--text-2xs);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--ash-grey);
            margin-bottom: var(--space-2xs);
        }

        .output-slot.active .output-type {
            color: var(--carbon);
        }

        .output-type.ecom { color: #2563eb; }
        .output-type.closeup { color: #7c3aed; }
        .output-type.campaign { color: #dc2626; }

        .output-icon {
            font-size: 24px;
            margin-bottom: var(--space-2xs);
        }

        .output-count {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-top: var(--space-2xs);
        }

        .output-count button {
            width: 20px;
            height: 20px;
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-xs);
            background: var(--white);
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .output-count button:hover {
            border-color: var(--jet);
        }

        .output-count span {
            font-size: var(--text-sm);
            font-weight: 600;
            min-width: 20px;
            text-align: center;
        }

        .output-count-display {
            font-size: var(--text-lg);
            font-weight: 600;
            color: var(--carbon);
        }

        /* Actions */
        .actions-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--space-md);
            background: var(--white);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-md);
            margin-bottom: var(--space-md);
            flex-wrap: wrap;
            gap: var(--space-sm);
        }

        .settings-row {
            display: flex;
            align-items: center;
            gap: var(--space-lg);
            flex-wrap: wrap;
        }

        .setting-group {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }

        .setting-label {
            font-size: var(--text-xs);
            color: var(--slate);
            font-weight: 500;
        }

        .calc-display {
            font-size: var(--text-sm);
            color: var(--slate);
        }

        .action-buttons {
            display: flex;
            gap: var(--space-sm);
        }

        .action-btn {
            padding: 12px 24px;
            font-size: 14px;
            min-width: 180px;
            text-align: center;
        }

        .btn-cost {
            opacity: 0.7;
            margin-left: 6px;
            font-weight: 400;
        }

        .btn.analyzed {
            background: #22c55e;
            border-color: #22c55e;
            color: var(--white);
        }

        .btn.analyzed:hover {
            background: #16a34a;
            border-color: #16a34a;
        }

        /* Analysis Box */
        .analysis-box {
            background: var(--off-white);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-sm);
            padding: var(--space-sm);
            margin-top: var(--space-sm);
            font-size: var(--text-sm);
            color: var(--slate);
            line-height: 1.5;
            display: none;
        }

        .analysis-box.visible {
            display: block;
        }

        /* Results section - full width */
        .results-section {
            margin-left: calc(-50vw + 50%);
            margin-right: calc(-50vw + 50%);
            padding-left: var(--space-lg);
            padding-right: var(--space-lg);
            max-width: 100vw;
        }

        /* Results Grid - 3 columns, full width */
        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: var(--space-md);
            max-width: 1400px;
            margin: 0 auto;
        }

        @media (min-width: 900px) {
            .results-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        .result-image {
            aspect-ratio: 3/4;
        }

        .result-card {
            cursor: pointer;
            border-radius: var(--radius-md);
            overflow: hidden;
            transition: transform var(--transition-fast);
        }

        .result-card:hover {
            transform: scale(1.02);
        }

        .result-card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* Output slot with slider underneath */
        .output-slot-wrapper {
            display: flex;
            flex-direction: column;
            gap: 6px;
            padding: 0 2px 8px;
        }

        .output-slider {
            width: 100%;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--gainsboro);
            border-radius: 2px;
            outline: none;
            margin-top: 2px;
        }

        .output-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: var(--jet);
            border-radius: 50%;
            cursor: pointer;
        }

        .output-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: var(--jet);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        input[type="file"] {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="hero">
            <h1>Campaign Generator</h1>
            <p class="hero-subtitle">Create campaign imagery from talent, mood boards, and products</p>
        </div>

        <!-- Section 1: Talent Selection -->
        <div class="section">
            <div class="section-header">
                <span class="section-title">1. Select Talent</span>
                <span class="section-badge required">Required</span>
            </div>
            <div class="talent-grid" id="talent-grid"></div>
            <p class="section-hint" style="margin-top: var(--space-xs); font-size: var(--text-xs); color: var(--ash-grey);">
                Select up to 4 models. Selected: <span id="talent-count">0</span>/4
            </p>
        </div>

        <!-- Section 2: Mood Board -->
        <div class="section">
            <div class="section-header">
                <span class="section-title">2. Mood Board</span>
                <span class="section-badge required">Required</span>
                <button class="btn btn--sm" id="clear-moodboard" style="margin-left: auto; font-size: 11px; padding: 4px 10px;">Clear All</button>
            </div>
            <div class="moodboard-grid" id="moodboard-grid"></div>
            <input type="file" id="moodboard-input" accept="image/*" multiple>
        </div>

        <!-- Section 3: Product Images (Optional) -->
        <div class="section">
            <div class="section-header">
                <span class="section-title">3. Product Images</span>
                <span class="section-badge">Optional</span>
            </div>
            <div class="product-grid" id="product-grid"></div>
            <input type="file" id="product-input" accept="image/*" multiple>
        </div>

        <!-- Section 4: Output Configuration -->
        <div class="section">
            <div class="section-header">
                <span class="section-title">4. Output Configuration</span>
                <span class="section-badge required">Required</span>
            </div>
            <div class="output-tabs">
                <button class="output-tab active" data-mode="people">People</button>
                <button class="output-tab" data-mode="product">Product</button>
            </div>
            <p id="output-hint" style="font-size: var(--text-xs); color: var(--ash-grey); margin-bottom: var(--space-sm);">
                Click to cycle type. Drag slider to set people count (0-4).
            </p>
            <div class="output-grid" id="output-grid"></div>
        </div>

        <!-- Inline Loader -->
        <div class="inline-loader" id="inline-loader">
            <div class="loader-message" id="loader-message">Setting up the Studio...</div>
            <div class="loader-progress" id="loader-progress">Preparing...</div>
        </div>

        <!-- Settings & Actions -->
        <div class="actions-row">
            <div class="settings-row">
                <div class="setting-group">
                    <div class="aspect-buttons" id="aspect-buttons">
                        <button class="aspect-btn active" data-ratio="3:4">3:4</button>
                        <button class="aspect-btn" data-ratio="4:3">4:3</button>
                        <button class="aspect-btn" data-ratio="1:1">1:1</button>
                        <button class="aspect-btn" data-ratio="9:16">9:16</button>
                        <button class="aspect-btn" data-ratio="16:9">16:9</button>
                    </div>
                </div>
            </div>
            <div class="action-buttons">
                <button class="btn action-btn" id="analyze-btn" disabled>Analyze Mood Board</button>
                <button class="btn btn--primary action-btn" id="generate-btn" disabled>
                    <span id="generate-btn-text">Generate 0 images</span>
                </button>
            </div>
        </div>

        <!-- Progress -->
        <div class="progress-section" id="progress-section">
            <div class="progress-header">
                <span class="progress-title">Generating</span>
                <span class="progress-count" id="progress-count">0 / 0</span>
            </div>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
        </div>

        <!-- Results -->
        <div class="results-section" id="results-section">
            <div class="results-header">
                <h2>Results</h2>
            </div>
            <div class="results-grid" id="results-grid"></div>
        </div>
    </div>

    <!-- Lightbox -->
    <div class="lightbox" id="lightbox">
        <div class="lightbox-content">
            <button class="lightbox-close" id="lightbox-close">&times;</button>
            <div class="lightbox-left">
                <img src="" alt="" class="lightbox-image" id="lightbox-image">
            </div>
            <div class="lightbox-right">
                <div class="lightbox-section">
                    <h3 class="lightbox-section-title">Type</h3>
                    <p class="lightbox-model-text" id="lightbox-type"></p>
                </div>
                <div class="lightbox-section">
                    <h3 class="lightbox-section-title">Prompt</h3>
                    <p class="lightbox-prompt-text" id="lightbox-prompt"></p>
                </div>
                <button class="lightbox-download" id="lightbox-download">Download Image</button>
            </div>
        </div>
    </div>


    <!-- Shared JS -->
    <script src="/shared/js/utils.js"></script>
    <script src="/shared/js/api.js"></script>

    <script>
        // Setset Talent Library
        const TALENT = [
            { id: 'james', name: 'James Wilson', image: '/shared/images/talent/talent-01_JamesWilson.png' },
            { id: 'maya', name: 'Maya Johnson', image: '/shared/images/talent/talent-02_MayaJohnson.png' },
            { id: 'river', name: 'River Blake', image: '/shared/images/talent/talent-03_RiverBlake.png' },
            { id: 'emma', name: 'Emma Sullivan', image: '/shared/images/talent/talent-04_EmmaSullivan.png' },
            { id: 'marcus', name: 'Marcus Brown', image: '/shared/images/talent/talent-05_MarcusBrown.png' },
            { id: 'zara', name: 'Zara Mitchell', image: '/shared/images/talent/talent-06_ZaraMitchell.png' },
            { id: 'sophia', name: 'Sophia Anderson', image: '/shared/images/talent/talent-07_SophiaAnderson.png' },
            { id: 'liam', name: 'Liam Garcia', image: '/shared/images/talent/talent-08_LiamGarcia.png' },
            { id: 'nina', name: 'Nina Davis', image: '/shared/images/talent/talent-09_NinaDavis.png' },
            { id: 'ava', name: 'Ava Martinez', image: '/shared/images/talent/talent-10_AvaMartinez.png' },
            { id: 'luna', name: 'Luna Park', image: '/shared/images/talent/talent-11_LunaPark.png' },
            { id: 'noah', name: 'Noah Chen', image: '/shared/images/talent/talent-12_NoahChen.png' },
            { id: 'kai', name: 'Kai Thompson', image: '/shared/images/talent/talent-13_KaiThompson.png' },
            { id: 'riley', name: 'Riley Morgan', image: '/shared/images/talent/talent-14_RileyMorgan.png' },
            { id: 'jordan', name: 'Jordan Lee', image: '/shared/images/talent/talent-15_JordanLee.png' },
            { id: 'isabella', name: 'Isabella Rodriguez', image: '/shared/images/talent/talent-16_IsabellaRodriguez.png' },
            { id: 'quinn', name: 'Quinn Santos', image: '/shared/images/talent/talent-17_QuinnSantos.png' },
            { id: 'casey', name: 'Casey White', image: '/shared/images/talent/talent-18_CaseyWhite.png' },
            { id: 'sam', name: 'Sam Wilson', image: '/shared/images/talent/talent-19_SamWilson.png' },
            { id: 'drew', name: 'Drew Martinez', image: '/shared/images/talent/talent-20_DrewMartinez.png' },
            { id: 'avery', name: 'Avery Taylor', image: '/shared/images/talent/talent-21_AveryTaylor.png' },
            { id: 'parker', name: 'Parker Miller', image: '/shared/images/talent/talent-22_ParkerMiller.png' },
            { id: 'morgan', name: 'Morgan Kim', image: '/shared/images/talent/talent-23_MorganKim.png' },
            { id: 'andre', name: 'Andre Jackson', image: '/shared/images/talent/talent-24_AndreJackson.png' }
        ];

        // Output types cycle - different for people vs product mode
        const OUTPUT_TYPES_PEOPLE = ['none', 'ecom', 'closeup', 'campaign'];
        const OUTPUT_TYPES_PRODUCT = ['none', 'ecom', 'campaign']; // No close-up for product
        const OUTPUT_LABELS = {
            none: 'None',
            ecom: 'E-Commerce',
            closeup: 'Close-Up',
            campaign: 'Campaign'
        };
        const OUTPUT_ICONS = {
            none: 'â—‹',
            ecom: 'ðŸª',
            closeup: 'ðŸ‘¤',
            campaign: 'ðŸ“¸'
        };

        // State
        const state = {
            selectedTalent: [],       // Array of talent IDs
            moodboardImages: new Array(24).fill(null),  // 12x2 grid
            productImages: new Array(12).fill(null),    // 12x1 grid
            outputs: new Array(12).fill(null).map(() => ({ type: 'none', count: 1, productCount: 1 })),
            outputMode: 'people',     // 'people' or 'product'
            aspectRatio: '3:4',
            analysis: null,           // Raw analysis text
            parsedAnalysis: null,     // Parsed structured analysis with arrays
            productAnalysis: null,    // Product descriptions (what the products are)
            results: [],
            lightboxIndex: 0
        };

        // Parse structured analysis into arrays for variety
        function parseAnalysis(text) {
            const parsed = {
                lighting: [],
                colors: '',
                environments: [],
                clothing: [],
                textures: [],
                poses: [],
                expressions: [],
                focalLength: [],
                mood: ''
            };

            try {
                // Extract LIGHTING
                const lightingMatch = text.match(/LIGHTING:\s*\[?([^\]\n]+)/i);
                if (lightingMatch) {
                    parsed.lighting = lightingMatch[1].split(',').map(s => s.trim()).filter(Boolean);
                }

                // Extract COLORS
                const colorsMatch = text.match(/COLORS:\s*\[?([^\]\n]+)/i);
                if (colorsMatch) {
                    parsed.colors = colorsMatch[1].trim();
                }

                // Extract ENVIRONMENTS
                const envMatch = text.match(/ENVIRONMENTS:\s*\[?([^\]\n]+)/i);
                if (envMatch) {
                    parsed.environments = envMatch[1].split(',').map(s => s.trim()).filter(Boolean);
                }

                // Extract CLOTHING_STYLES
                const clothingMatch = text.match(/CLOTHING_STYLES:\s*\[?([^\]\n]+)/i);
                if (clothingMatch) {
                    parsed.clothing = clothingMatch[1].split(',').map(s => s.trim()).filter(Boolean);
                }

                // Extract TEXTURES
                const texturesMatch = text.match(/TEXTURES:\s*\[?([^\]\n]+)/i);
                if (texturesMatch) {
                    parsed.textures = texturesMatch[1].split(',').map(s => s.trim()).filter(Boolean);
                }

                // Extract POSES
                const posesMatch = text.match(/POSES:\s*\[?([^\]\n]+)/i);
                if (posesMatch) {
                    parsed.poses = posesMatch[1].split(',').map(s => s.trim()).filter(Boolean);
                }

                // Extract EXPRESSIONS
                const expressionsMatch = text.match(/EXPRESSIONS:\s*\[?([^\]\n]+)/i);
                if (expressionsMatch) {
                    parsed.expressions = expressionsMatch[1].split(',').map(s => s.trim()).filter(Boolean);
                }

                // Extract FOCAL_LENGTH
                const focalMatch = text.match(/FOCAL_LENGTH:\s*\[?([^\]\n]+)/i);
                if (focalMatch) {
                    parsed.focalLength = focalMatch[1].split(',').map(s => s.trim()).filter(Boolean);
                }

                // Extract MOOD
                const moodMatch = text.match(/MOOD:\s*\[?([^\]\n]+)/i);
                if (moodMatch) {
                    parsed.mood = moodMatch[1].trim();
                }
            } catch (e) {
                console.error('Error parsing analysis:', e);
            }

            return parsed;
        }

        // DOM Elements
        const elements = {
            talentGrid: document.getElementById('talent-grid'),
            talentCount: document.getElementById('talent-count'),
            moodboardGrid: document.getElementById('moodboard-grid'),
            moodboardInput: document.getElementById('moodboard-input'),
            clearMoodboard: document.getElementById('clear-moodboard'),
            productGrid: document.getElementById('product-grid'),
            productInput: document.getElementById('product-input'),
            outputGrid: document.getElementById('output-grid'),
            outputHint: document.getElementById('output-hint'),
            aspectButtons: document.getElementById('aspect-buttons'),
            analyzeBtn: document.getElementById('analyze-btn'),
            generateBtn: document.getElementById('generate-btn'),
            generateBtnText: document.getElementById('generate-btn-text'),
            inlineLoader: document.getElementById('inline-loader'),
            loaderMessage: document.getElementById('loader-message'),
            loaderProgress: document.getElementById('loader-progress'),
            progressSection: document.getElementById('progress-section'),
            progressCount: document.getElementById('progress-count'),
            progressBar: document.getElementById('progress-bar'),
            resultsSection: document.getElementById('results-section'),
            resultsGrid: document.getElementById('results-grid'),
            lightbox: document.getElementById('lightbox'),
            lightboxImage: document.getElementById('lightbox-image'),
            lightboxType: document.getElementById('lightbox-type'),
            lightboxPrompt: document.getElementById('lightbox-prompt')
        };

        // Studio messages for the loader (like old campaign gen)
        const STUDIO_MESSAGES = [
            "Setting up the Studio...",
            "Adjusting the Key Light...",
            "Loading the Film...",
            "Warming up the Strobes...",
            "Preparing the Backdrop...",
            "Adjusting the Fill Light...",
            "Checking the Framing...",
            "Setting the Aperture...",
            "Loading Color Profiles...",
            "Positioning the C-Stand...",
            "Focusing...",
            "Checking Tethering...",
            "Rolling...",
            "Adjusting the Umbrella...",
            "Metering...",
            "Standby...",
            "Loading the Presets...",
            "Quiet on Set...",
            "Final Touches...",
            "Almost There..."
        ];
        let loadingInterval = null;
        let lastMessageIndex = -1;

        // Initialize
        function init() {
            renderTalentGrid();
            renderMoodboardGrid();
            renderProductGrid();
            renderOutputGrid();
            setupEventListeners();
            updateUI();
        }

        // Render Talent Grid
        function renderTalentGrid() {
            elements.talentGrid.innerHTML = TALENT.map(talent => {
                const isSelected = state.selectedTalent.includes(talent.id);
                const isDisabled = !isSelected && state.selectedTalent.length >= 4;
                return `
                    <div class="talent-card ${isSelected ? 'selected' : ''} ${isDisabled ? 'disabled' : ''}"
                         data-id="${talent.id}" title="${talent.name}">
                        <img src="${talent.image}" alt="${talent.name}">
                    </div>
                `;
            }).join('');

            elements.talentGrid.querySelectorAll('.talent-card').forEach(card => {
                card.addEventListener('click', () => {
                    const id = card.dataset.id;
                    if (card.classList.contains('disabled')) return;

                    if (state.selectedTalent.includes(id)) {
                        state.selectedTalent = state.selectedTalent.filter(t => t !== id);
                    } else if (state.selectedTalent.length < 4) {
                        state.selectedTalent.push(id);
                    }
                    renderTalentGrid();
                    updateUI();
                });
            });

            elements.talentCount.textContent = state.selectedTalent.length;
        }

        // Render Moodboard Grid
        function renderMoodboardGrid() {
            elements.moodboardGrid.innerHTML = state.moodboardImages.map((img, i) => {
                if (img) {
                    return `
                        <div class="upload-slot filled ${img.selected === false ? 'deselected' : ''}" data-index="${i}">
                            <img src="${img.url}" alt="Moodboard ${i + 1}">
                            <button class="remove-btn" data-action="remove">&times;</button>
                        </div>
                    `;
                }
                return `
                    <div class="upload-slot" data-index="${i}">
                        <span class="plus">+</span>
                    </div>
                `;
            }).join('');

            setupGridListeners(elements.moodboardGrid, 'moodboard');
        }

        // Render Product Grid
        function renderProductGrid() {
            elements.productGrid.innerHTML = state.productImages.map((img, i) => {
                if (img) {
                    return `
                        <div class="upload-slot filled ${img.selected === false ? 'deselected' : ''}" data-index="${i}">
                            <img src="${img.url}" alt="Product ${i + 1}">
                            <button class="remove-btn" data-action="remove">&times;</button>
                        </div>
                    `;
                }
                return `
                    <div class="upload-slot" data-index="${i}">
                        <span class="plus">+</span>
                    </div>
                `;
            }).join('');

            setupGridListeners(elements.productGrid, 'product');
        }

        // Render Output Grid
        function renderOutputGrid() {
            const isPeopleMode = state.outputMode === 'people';
            const outputTypes = isPeopleMode ? OUTPUT_TYPES_PEOPLE : OUTPUT_TYPES_PRODUCT;
            const maxProducts = state.productImages.filter(img => img && img.selected !== false).length;

            // Update hint text based on mode
            if (isPeopleMode) {
                elements.outputHint.textContent = 'Click to cycle: None â†’ E-commerce â†’ Close-up â†’ Campaign. Use slider to set number of people (0-4).';
            } else {
                elements.outputHint.textContent = 'Click to cycle: None â†’ E-commerce â†’ Campaign. Use slider to set number of products per shot.';
            }

            elements.outputGrid.innerHTML = state.outputs.map((output, i) => {
                const isActive = output.type !== 'none';
                const sliderValue = isPeopleMode ? output.count : output.productCount;
                const sliderMax = isPeopleMode ? 4 : Math.max(1, maxProducts);
                return `
                    <div class="output-slot-wrapper">
                        <div class="output-slot ${isActive ? 'active' : ''}" data-index="${i}">
                            <div class="output-icon">${OUTPUT_ICONS[output.type]}</div>
                            <div class="output-type ${output.type}">${OUTPUT_LABELS[output.type]}</div>
                            ${isActive ? `<div class="output-count-display">${sliderValue}</div>` : ''}
                        </div>
                        ${isActive ? `
                            <input type="range" class="output-slider" data-index="${i}" min="${isPeopleMode ? 0 : 1}" max="${sliderMax}" value="${sliderValue}">
                        ` : ''}
                    </div>
                `;
            }).join('');

            elements.outputGrid.querySelectorAll('.output-slot').forEach(slot => {
                const index = parseInt(slot.dataset.index);

                // Click to cycle type
                slot.addEventListener('click', () => {
                    const currentType = state.outputs[index].type;
                    const currentIdx = outputTypes.indexOf(currentType);
                    const nextIdx = (currentIdx + 1) % outputTypes.length;
                    state.outputs[index].type = outputTypes[nextIdx];
                    renderOutputGrid();
                    updateUI();
                });
            });

            // Slider events for count (works for both people and product modes)
            elements.outputGrid.querySelectorAll('.output-slider').forEach(slider => {
                slider.addEventListener('input', (e) => {
                    e.stopPropagation();
                    const index = parseInt(slider.dataset.index);
                    if (isPeopleMode) {
                        state.outputs[index].count = parseInt(slider.value);
                    } else {
                        state.outputs[index].productCount = parseInt(slider.value);
                    }
                    // Update display without full re-render
                    const wrapper = slider.closest('.output-slot-wrapper');
                    const display = wrapper.querySelector('.output-count-display');
                    if (display) display.textContent = slider.value;
                    updateUI();
                });
                slider.addEventListener('click', (e) => e.stopPropagation());
            });
        }

        // Setup grid listeners for upload slots
        function setupGridListeners(grid, type) {
            const images = type === 'moodboard' ? state.moodboardImages : state.productImages;
            const input = type === 'moodboard' ? elements.moodboardInput : elements.productInput;
            const maxSlots = type === 'moodboard' ? 24 : 12;

            grid.querySelectorAll('.upload-slot').forEach(slot => {
                const index = parseInt(slot.dataset.index);

                slot.addEventListener('click', (e) => {
                    if (e.target.dataset.action === 'remove') {
                        // Remove image and collapse/shift remaining images to the left
                        images[index] = null;
                        const filled = images.filter(img => img);
                        for (let i = 0; i < maxSlots; i++) {
                            images[i] = filled[i] || null;
                        }
                        if (type === 'moodboard') renderMoodboardGrid();
                        else renderProductGrid();
                        updateUI();
                        return;
                    }

                    if (images[index]) {
                        // Toggle selection
                        images[index].selected = images[index].selected === false ? true : false;
                        if (type === 'moodboard') renderMoodboardGrid();
                        else renderProductGrid();
                        updateUI();
                    } else {
                        // Open file picker
                        input.dataset.startIndex = index;
                        input.click();
                    }
                });
            });

            // Drag and drop
            grid.addEventListener('dragover', (e) => e.preventDefault());
            grid.addEventListener('drop', (e) => {
                e.preventDefault();
                const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
                handleFileUpload(files, type, null);
            });
        }

        // Setup event listeners
        function setupEventListeners() {
            // File inputs
            elements.moodboardInput.addEventListener('change', (e) => {
                const startIndex = e.target.dataset.startIndex ? parseInt(e.target.dataset.startIndex) : null;
                handleFileUpload(Array.from(e.target.files), 'moodboard', startIndex);
                e.target.value = '';
            });

            elements.productInput.addEventListener('change', (e) => {
                const startIndex = e.target.dataset.startIndex ? parseInt(e.target.dataset.startIndex) : null;
                handleFileUpload(Array.from(e.target.files), 'product', startIndex);
                e.target.value = '';
            });

            // Clear all moodboard button
            elements.clearMoodboard.addEventListener('click', () => {
                state.moodboardImages = new Array(24).fill(null);
                state.analysis = null;
                state.parsedAnalysis = null;
                state.productAnalysis = null;
                elements.analyzeBtn.textContent = 'Analyze Mood Board';
                elements.analyzeBtn.classList.remove('analyzed');
                renderMoodboardGrid();
                updateUI();
            });

            // Output mode tabs
            document.querySelectorAll('.output-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    const newMode = tab.dataset.mode;
                    if (newMode === state.outputMode) return;

                    state.outputMode = newMode;
                    // Reset any closeup outputs when switching to product mode
                    if (newMode === 'product') {
                        state.outputs.forEach(output => {
                            if (output.type === 'closeup') output.type = 'none';
                            output.count = 0; // Product mode has no people
                        });
                    }

                    // Update tab styling
                    document.querySelectorAll('.output-tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');

                    renderOutputGrid();
                    updateUI();
                });
            });

            // Aspect ratio buttons
            elements.aspectButtons.querySelectorAll('.aspect-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    elements.aspectButtons.querySelectorAll('.aspect-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.aspectRatio = btn.dataset.ratio;
                });
            });

            // Drag hover events for moodboard
            elements.moodboardGrid.addEventListener('dragenter', () => {
                elements.moodboardGrid.classList.add('drag-over');
            });
            elements.moodboardGrid.addEventListener('dragleave', (e) => {
                if (!elements.moodboardGrid.contains(e.relatedTarget)) {
                    elements.moodboardGrid.classList.remove('drag-over');
                }
            });
            elements.moodboardGrid.addEventListener('drop', () => {
                elements.moodboardGrid.classList.remove('drag-over');
            });

            // Drag hover events for product grid
            elements.productGrid.addEventListener('dragenter', () => {
                elements.productGrid.classList.add('drag-over');
            });
            elements.productGrid.addEventListener('dragleave', (e) => {
                if (!elements.productGrid.contains(e.relatedTarget)) {
                    elements.productGrid.classList.remove('drag-over');
                }
            });
            elements.productGrid.addEventListener('drop', () => {
                elements.productGrid.classList.remove('drag-over');
            });

            // Buttons
            elements.analyzeBtn.addEventListener('click', handleAnalyze);
            elements.generateBtn.addEventListener('click', handleGenerate);

            // Lightbox
            document.getElementById('lightbox-close').addEventListener('click', closeLightbox);
            elements.lightbox.addEventListener('click', (e) => {
                if (e.target === elements.lightbox) closeLightbox();
            });

            document.getElementById('lightbox-download').addEventListener('click', () => {
                const result = state.results[state.lightboxIndex];
                const now = new Date();
                const yy = String(now.getFullYear()).slice(-2);
                const mm = String(now.getMonth() + 1).padStart(2, '0');
                const dd = String(now.getDate()).padStart(2, '0');
                const hh = String(now.getHours()).padStart(2, '0');
                const min = String(now.getMinutes()).padStart(2, '0');
                const num = String(state.lightboxIndex + 1).padStart(2, '0');
                downloadFile(result.url, `Setset_Campaign_${yy}${mm}${dd}_${hh}${min}_${num}.png`);
            });

            // Keyboard
            document.addEventListener('keydown', (e) => {
                if (!elements.lightbox.classList.contains('visible')) return;
                if (e.key === 'Escape') closeLightbox();
                if (e.key === 'ArrowLeft' && state.lightboxIndex > 0) {
                    state.lightboxIndex--;
                    updateLightboxContent();
                }
                if (e.key === 'ArrowRight' && state.lightboxIndex < state.results.length - 1) {
                    state.lightboxIndex++;
                    updateLightboxContent();
                }
            });
        }

        // Handle file upload
        function handleFileUpload(files, type, startIndex) {
            const images = type === 'moodboard' ? state.moodboardImages : state.productImages;
            const maxSlots = type === 'moodboard' ? 24 : 12;

            // Pre-calculate all target indices to avoid async race conditions
            const targetIndices = [];
            if (startIndex !== null) {
                // Starting from a specific slot, fill sequentially
                for (let i = 0; i < files.length; i++) {
                    const idx = startIndex + i;
                    if (idx < maxSlots) targetIndices.push(idx);
                }
            } else {
                // Find all empty slots first
                for (let i = 0; i < files.length; i++) {
                    const emptyIdx = images.findIndex((img, idx) => !img && !targetIndices.includes(idx));
                    if (emptyIdx !== -1 && emptyIdx < maxSlots) {
                        targetIndices.push(emptyIdx);
                    }
                }
            }

            // Now read files and place them in pre-calculated slots
            files.forEach((file, i) => {
                if (i >= targetIndices.length) return;
                const targetIndex = targetIndices[i];

                const reader = new FileReader();
                reader.onload = (e) => {
                    images[targetIndex] = { file, url: e.target.result, selected: true };
                    if (type === 'moodboard') renderMoodboardGrid();
                    else renderProductGrid();
                    updateUI();
                };
                reader.readAsDataURL(file);
            });
        }

        // Update UI state
        function updateUI() {
            const hasTalent = state.selectedTalent.length > 0;
            const hasProducts = state.productImages.some(img => img && img.selected !== false);
            const hasMoodboard = state.moodboardImages.some(img => img && img.selected !== false);
            const activeOutputs = state.outputs.filter(o => o.type !== 'none');
            const hasOutputs = activeOutputs.length > 0;
            const isPeopleMode = state.outputMode === 'people';

            // Check if any output requires people (count > 0) - only relevant in people mode
            const needsPeople = isPeopleMode && activeOutputs.some(o => o.count > 0);

            // Calculate total images
            let totalImages = activeOutputs.length;

            // Enable/disable buttons
            elements.analyzeBtn.disabled = !hasMoodboard;

            // Generate requires: mood board + outputs + analysis
            // In people mode: if any output has count > 0, we need talent selected
            // In product mode: we need products (no talent needed)
            let canGenerate = hasMoodboard && hasOutputs && state.analysis;
            if (isPeopleMode) {
                canGenerate = canGenerate && (!needsPeople || hasTalent);
            } else {
                canGenerate = canGenerate && hasProducts;
            }
            elements.generateBtn.disabled = !canGenerate;

            // Update generate button text with context
            let btnText = `Generate ${totalImages} image${totalImages !== 1 ? 's' : ''}`;
            if (totalImages > 0) {
                if (isPeopleMode) {
                    const talentCount = state.selectedTalent.length;
                    if (talentCount > 0) {
                        btnText += ` with ${talentCount} model${talentCount !== 1 ? 's' : ''}`;
                    }
                } else {
                    const availableProducts = state.productImages.filter(img => img && img.selected !== false).length;
                    if (availableProducts > 0) {
                        btnText += ` with ${availableProducts} product${availableProducts !== 1 ? 's' : ''}`;
                    }
                }
            }
            elements.generateBtnText.textContent = btnText;
        }

        // Loading animation helpers - studio style
        function startLoadingAnimation(progressText = 'Preparing...') {
            elements.inlineLoader.classList.add('visible');
            elements.loaderProgress.textContent = progressText;

            // Set initial message
            const initialIdx = Math.floor(Math.random() * STUDIO_MESSAGES.length);
            elements.loaderMessage.textContent = STUDIO_MESSAGES[initialIdx];
            lastMessageIndex = initialIdx;

            // Rotate messages every 2 seconds with fade effect
            loadingInterval = setInterval(() => {
                // Pick a random message different from the last one
                let idx;
                do {
                    idx = Math.floor(Math.random() * STUDIO_MESSAGES.length);
                } while (idx === lastMessageIndex && STUDIO_MESSAGES.length > 1);
                lastMessageIndex = idx;

                // Fade out
                elements.loaderMessage.classList.add('fade-out');
                elements.loaderMessage.classList.remove('fade-in');

                setTimeout(() => {
                    elements.loaderMessage.textContent = STUDIO_MESSAGES[idx];
                    elements.loaderMessage.classList.remove('fade-out');
                    elements.loaderMessage.classList.add('fade-in');
                }, 250);
            }, 2000);
        }

        function updateLoadingProgress(text) {
            elements.loaderProgress.textContent = text;
        }

        function stopLoadingAnimation() {
            if (loadingInterval) {
                clearInterval(loadingInterval);
                loadingInterval = null;
            }
            elements.inlineLoader.classList.remove('visible');
        }

        // Handle Analyze
        async function handleAnalyze() {
            const moodImages = state.moodboardImages.filter(img => img && img.selected !== false);
            if (moodImages.length === 0) return;

            // Also get selected talent images for clothing analysis
            const talentImages = state.selectedTalent.map(id => {
                const talent = TALENT.find(t => t.id === id);
                return talent ? talent.image : null;
            }).filter(Boolean);

            // Get product images for product identification
            const productImages = state.productImages.filter(img => img && img.selected !== false);

            startLoadingAnimation(`Analyzing ${moodImages.length} moodboard image${moodImages.length > 1 ? 's' : ''}...`);

            try {
                // Upload moodboard images
                const uploadPromises = moodImages.map(img => api.uploadBase64(img.url));
                const uploadResults = await Promise.all(uploadPromises);
                const moodboardUrls = uploadResults.map(r => r.url);

                // Upload talent images for clothing analysis
                const talentUploadPromises = talentImages.map(async (url) => {
                    const response = await fetch(url);
                    const blob = await response.blob();
                    const file = new File([blob], 'talent.png', { type: blob.type });
                    return api.uploadImage(file);
                });
                const talentUploadResults = await Promise.all(talentUploadPromises);
                const talentUrls = talentUploadResults.map(r => r.url);

                // Upload product images for identification
                const productUploadPromises = productImages.map(img => api.uploadBase64(img.url));
                const productUploadResults = await Promise.all(productUploadPromises);
                const productUrls = productUploadResults.map(r => r.url);

                // Combine moodboard and talent for style analysis
                const styleImageUrls = [...moodboardUrls, ...talentUrls];

                // Enhanced analysis prompt - extracts variety from moodboard as structured lists
                // Key: ask for SPECIFIC DESCRIPTIVE environments, not generic labels
                const analysisPrompt = `Analyze these mood board images and extract the following as a structured guide. For each category, list MULTIPLE specific options seen across the images.

Return your response in this EXACT format:

LIGHTING: [list 3-5 SPECIFIC lighting setups, e.g. "soft diffused light through sheer curtains, warm afternoon sun casting long shadows, overcast day with even soft light, dramatic single window light from the left"]

COLORS: [describe the color palette with specifics, e.g. "warm terracotta and sand tones, deep forest green accents, soft cream whites, weathered wood browns"]

ENVIRONMENTS: [list 4-6 SPECIFIC DETAILED locations - be descriptive like a set designer, e.g. "sunlit Scandinavian living room with oak furniture and linen curtains, weathered Mediterranean terrace with terracotta tiles and olive trees, modern concrete gallery space with large windows, cozy cafe corner with velvet seating and brass fixtures, airy beach house with whitewashed walls and natural textures"]

CLOTHING_STYLES: [list 4-6 outfit descriptions, e.g. "relaxed tailored linen suit, chunky cable-knit sweater with wide trousers, crisp white oxford shirt with raw denim, draped midi dress in natural fabric"]

TEXTURES: [list 3-5 fabric/material textures, e.g. "nubby boucle wool, washed linen, soft brushed cotton, smooth aged leather, raw silk"]

POSES: [list 4-6 specific poses with context, e.g. "walking through a doorway mid-stride, seated on floor leaning against wall, standing by window looking out, reclining on sofa reading, perched on stool at counter"]

EXPRESSIONS: [list 3-5 expressions, e.g. "genuine mid-laugh, thoughtful gaze into distance, serene closed-eye moment, curious glance over shoulder, relaxed half-smile"]

FOCAL_LENGTH: [list 2-4 lens looks, e.g. "wide environmental 28mm showing full room, classic portrait 85mm with soft background, intimate close 135mm with shallow depth"]

MOOD: [1-2 sentences capturing the emotional quality and atmosphere]

IMPORTANT:
- Do NOT mention any brand names
- Be SPECIFIC and DESCRIPTIVE - not generic labels
- Think like a location scout and set designer
- Environments should be complete scene descriptions that could guide a photographer`;

                const result = await api.analyzeImages(styleImageUrls, analysisPrompt);

                if (result.content) {
                    state.analysis = result.content;
                    state.parsedAnalysis = parseAnalysis(result.content);
                    console.log('Style analysis stored:', state.analysis);
                    console.log('Parsed analysis:', state.parsedAnalysis);
                }

                // Analyze products separately if there are any
                if (productUrls.length > 0) {
                    updateLoadingProgress(`Identifying ${productUrls.length} product${productUrls.length > 1 ? 's' : ''}...`);

                    const productPrompt = `Identify each product in these images. For each product, provide a brief description of what it is (e.g., "white cotton t-shirt", "wooden dining chair", "leather handbag", "ceramic vase").

Format your response as a simple numbered list like:
1. [description of first product]
2. [description of second product]
etc.

Be specific about material, color, and type. Do NOT mention brand names.`;

                    const productResult = await api.analyzeImages(productUrls, productPrompt);

                    if (productResult.content) {
                        state.productAnalysis = productResult.content;
                        console.log('Product analysis stored:', state.productAnalysis);
                    }
                }

                // Update button to show analysis is complete
                elements.analyzeBtn.textContent = 'Re-analyze';
                elements.analyzeBtn.classList.add('analyzed');

                updateUI();
            } catch (error) {
                console.error('Analysis error:', error);
                alert('Failed to analyze mood board: ' + error.message);
            } finally {
                stopLoadingAnimation();
            }
        }

        // Handle Generate
        async function handleGenerate() {
            if (!state.analysis) {
                alert('Please analyze the mood board first');
                return;
            }

            const activeOutputs = state.outputs.filter(o => o.type !== 'none');
            if (activeOutputs.length === 0) return;

            state.results = [];
            elements.resultsGrid.innerHTML = '';
            elements.progressSection.classList.add('visible');
            startLoadingAnimation(`Generating ${activeOutputs.length} campaign images...`);

            let completed = 0;
            const total = activeOutputs.length;
            elements.progressCount.textContent = `0 / ${total}`;
            elements.progressBar.style.width = '0%';

            const isPeopleMode = state.outputMode === 'people';

            // Get all talent data available (only used in people mode)
            const allTalentData = state.selectedTalent.map(id => {
                const talent = TALENT.find(t => t.id === id);
                return talent ? { id: talent.id, name: talent.name, image: talent.image } : null;
            }).filter(Boolean);

            // Helper to shuffle and pick random talent
            function getRandomTalent(count) {
                const shuffled = [...allTalentData].sort(() => Math.random() - 0.5);
                return shuffled.slice(0, Math.min(count, shuffled.length));
            }

            // Get all product images
            const allProductImages = state.productImages
                .filter(img => img && img.selected !== false)
                .map(img => img.url);

            // Helper to shuffle and pick random products
            function getRandomProducts(count) {
                const shuffled = [...allProductImages].sort(() => Math.random() - 0.5);
                return shuffled.slice(0, Math.min(count, shuffled.length));
            }

            // Generate for each active output
            const promises = activeOutputs.map(async (output, index) => {
                try {
                    let refImages = [];
                    let numTalent = 0;
                    let numProducts = 0;

                    if (isPeopleMode) {
                        // People mode: Select RANDOM talent for each output
                        const randomTalent = getRandomTalent(output.count);
                        const talentForThisOutput = randomTalent.map(t => t.image);
                        numTalent = talentForThisOutput.length;

                        // Collect reference images - talent first, then products
                        refImages = [...talentForThisOutput];
                        if (allProductImages.length > 0) {
                            refImages.push(...allProductImages);
                            numProducts = allProductImages.length;
                        }
                    } else {
                        // Product mode: Select products based on per-slot productCount
                        const productsForThisOutput = getRandomProducts(output.productCount);
                        refImages = [...productsForThisOutput];
                        numProducts = productsForThisOutput.length;
                        numTalent = 0;
                    }

                    // Build prompt based on output type and count
                    const prompt = buildPrompt(output, numTalent, numProducts, isPeopleMode);

                    // If no reference images at all, skip
                    if (refImages.length === 0) {
                        console.log('No reference images for output, skipping...');
                        return;
                    }

                    // Upload reference images - handle base64, local paths, and hosted URLs
                    const uploadPromises = refImages.map(async (url) => {
                        if (url.startsWith('data:')) {
                            // Base64 data URL - upload directly
                            return api.uploadBase64(url);
                        } else if (url.startsWith('/') || url.startsWith('./')) {
                            // Local path - fetch and upload
                            const response = await fetch(url);
                            const blob = await response.blob();
                            const file = new File([blob], 'image.png', { type: blob.type });
                            return api.uploadImage(file);
                        } else {
                            // Already a hosted URL
                            return { url };
                        }
                    });
                    const uploadResults = await Promise.all(uploadPromises);
                    const imageUrls = uploadResults.map(r => r.url);

                    // Generate with settings
                    const params = {
                        prompt,
                        image_urls: imageUrls,
                        num_images: 1,
                        aspect_ratio: state.aspectRatio,
                        output_format: 'png'
                    };

                    const data = await api.remixImage('nano-pro', params);

                    if (data.images && data.images.length > 0) {
                        state.results.push({
                            url: data.images[0].url,
                            prompt,
                            type: OUTPUT_LABELS[output.type],
                            count: output.count
                        });
                        renderResults();
                    }
                } catch (error) {
                    console.error('Generation error:', error);
                }

                completed++;
                elements.progressCount.textContent = `${completed} / ${total}`;
                elements.progressBar.style.width = `${(completed / total) * 100}%`;
            });

            await Promise.all(promises);
            stopLoadingAnimation();
            elements.progressSection.classList.remove('visible');
        }

        // Pose and composition variety pools
        const SOLO_POSES = [
            'standing confidently with hands in pockets',
            'walking mid-stride',
            'leaning against a wall casually',
            'sitting on a stool',
            'turning to look over shoulder',
            'adjusting jacket or sleeve',
            'standing with arms crossed',
            'candid laugh or smile',
            'looking down thoughtfully',
            'standing with weight on one leg',
            'hands on hips',
            'running fingers through hair'
        ];

        const DUO_POSES = [
            'standing side by side looking at camera',
            'one person slightly behind the other',
            'walking together in conversation',
            'sitting next to each other',
            'back to back',
            'one seated, one standing',
            'looking at each other',
            'casual interaction, laughing together',
            'shoulder to shoulder facing forward',
            'one leaning on the other casually'
        ];

        const GROUP_POSES = [
            'arranged in a staggered formation',
            'walking together as a group',
            'sitting and standing mixed',
            'in a casual huddle',
            'spread out across the frame',
            'lined up but with varied poses',
            'interacting naturally with each other',
            'some facing camera, some in profile'
        ];

        const OUTFIT_VARIETY = [
            'casual streetwear',
            'relaxed tailored pieces',
            'layered textures',
            'bold color accent piece',
            'minimal monochrome',
            'mixed formal and casual',
            'oversized silhouettes',
            'fitted contemporary style'
        ];

        // Helper to pick random item from array with fallback
        function pickRandom(arr, fallback = '') {
            if (!arr || arr.length === 0) return fallback;
            return arr[Math.floor(Math.random() * arr.length)];
        }

        // Build prompt based on output type
        function buildPrompt(output, numTalent, numProducts, isPeopleMode = true) {
            const subjectCount = isPeopleMode ? output.count : 0;
            const hasProducts = numProducts > 0;
            const parsed = state.parsedAnalysis || {};

            // Sanitize product description from brand names
            let productDesc = state.productAnalysis || '';
            const brandBlacklist = [
                'Gucci', 'Louis Vuitton', 'LV', 'Prada', 'Chanel', 'Dior', 'HermÃ¨s', 'Hermes',
                'Burberry', 'Balenciaga', 'Versace', 'Fendi', 'Givenchy', 'Saint Laurent', 'YSL',
                'Bottega Veneta', 'Valentino', 'Alexander McQueen', 'Celine', 'Loewe', 'Moncler',
                'Off-White', 'Supreme', 'Nike', 'Adidas', 'Zara', 'H&M', 'Uniqlo', 'Reformation',
                'Rolex', 'Cartier', 'Tiffany', 'Bulgari', 'Van Cleef', 'Armani', 'Dolce & Gabbana',
                'Tom Ford', 'Marc Jacobs', 'Coach', 'Michael Kors', 'Kate Spade', 'Ralph Lauren',
                'Calvin Klein', 'Tommy Hilfiger', 'Hugo Boss', 'Stella McCartney', 'Acne Studios'
            ];
            brandBlacklist.forEach(brand => {
                const regex = new RegExp(`\\b${brand}\\b`, 'gi');
                productDesc = productDesc.replace(regex, '');
            });
            productDesc = productDesc.replace(/\s{2,}/g, ' ').trim();

            // Build product description for prompts
            const productInfo = hasProducts && productDesc
                ? `Products: ${productDesc}.`
                : '';

            // Pick random elements from parsed analysis for variety
            // Use moodboard-derived options first, fallback to defaults
            const randomLighting = pickRandom(parsed.lighting, 'soft natural light');
            const randomEnv = pickRandom(parsed.environments, 'minimalist studio');
            const colorPalette = parsed.colors || 'neutral tones';
            const mood = parsed.mood || 'sophisticated and elegant';
            const randomTexture = pickRandom(parsed.textures, '');
            const randomExpression = pickRandom(parsed.expressions, 'natural expression');
            const randomFocal = pickRandom(parsed.focalLength, '');

            // Pick random pose - prefer moodboard-derived, fallback to hardcoded
            let randomPose;
            if (parsed.poses && parsed.poses.length > 0) {
                randomPose = pickRandom(parsed.poses);
            } else {
                randomPose = subjectCount === 1
                    ? SOLO_POSES[Math.floor(Math.random() * SOLO_POSES.length)]
                    : subjectCount === 2
                        ? DUO_POSES[Math.floor(Math.random() * DUO_POSES.length)]
                        : GROUP_POSES[Math.floor(Math.random() * GROUP_POSES.length)];
            }

            // Pick random outfit - prefer moodboard-derived, fallback to hardcoded
            // Combine clothing style with texture if available
            let randomOutfit = parsed.clothing && parsed.clothing.length > 0
                ? pickRandom(parsed.clothing)
                : OUTFIT_VARIETY[Math.floor(Math.random() * OUTFIT_VARIETY.length)];
            if (randomTexture) {
                randomOutfit = `${randomOutfit} in ${randomTexture}`;
            }

            let prompt = '';

            // Build a style descriptor from the parsed elements
            const styleDesc = `${randomLighting}, ${colorPalette}, ${mood}`;
            const focalDesc = randomFocal ? `, shot on ${randomFocal}` : '';

            if (!isPeopleMode || subjectCount === 0) {
                // Product mode OR no people - product/environment only
                const productCountText = numProducts === 1
                    ? 'ONLY this exact product from the reference image'
                    : `ONLY these exact ${numProducts} products from the reference images`;
                const scaleNote = 'Maintain realistic product scale and proportions. Products should look natural in their environment.';
                const noExtraItems = 'Do NOT add any extra items, objects, or products that are not in the reference images.';

                if (output.type === 'ecom') {
                    prompt = hasProducts
                        ? `Place ${productCountText} on a clean white studio background. ${productInfo} Professional e-commerce product photography. ${scaleNote} ${noExtraItems} ${styleDesc}${focalDesc}.`
                        : `Product photography on white studio background. ${styleDesc}. Clean, professional e-commerce style${focalDesc}.`;
                } else if (output.type === 'closeup') {
                    prompt = hasProducts
                        ? `Close-up detail shot of ${productCountText}. ${productInfo} ${styleDesc}. Soft studio lighting, shallow depth of field, focus on texture and details${focalDesc}. ${scaleNote} ${noExtraItems}`
                        : `Close-up product detail shot. ${styleDesc}. Soft studio lighting, shallow depth of field${focalDesc}.`;
                } else if (output.type === 'campaign') {
                    prompt = hasProducts
                        ? `Place ${productCountText} in ${randomEnv}. ${productInfo} ${styleDesc}. Lifestyle product photography, natural placement. ${scaleNote} ${noExtraItems}${focalDesc}.`
                        : `Editorial campaign photo in ${randomEnv}. ${styleDesc}. Creative composition, luxury aesthetic${focalDesc}.`;
                }
            } else {
                // People mode with people
                const peopleText = subjectCount === 1 ? 'this exact person' : `these exact ${subjectCount} people together in the same shot`;
                const productText = hasProducts && productInfo
                    ? ` Feature ONLY the exact product from the reference image prominently. ${productInfo} Do NOT add extra items.`
                    : '';

                if (output.type === 'ecom') {
                    prompt = `Place ${peopleText} in a white studio, ${randomPose}, ${randomExpression}. Full-body e-commerce fashion photo. Wearing ${randomOutfit}. ${styleDesc}. Clean white background, professional studio lighting${focalDesc}.${productText}`;
                } else if (output.type === 'closeup') {
                    prompt = `Close-up portrait of ${peopleText}, ${randomExpression}. Wearing ${randomOutfit}. ${randomLighting}, ${colorPalette}. Editorial beauty shot, focus on face and expression, chest-up framing${focalDesc}.${productText}`;
                } else if (output.type === 'campaign') {
                    prompt = `Place ${peopleText} in ${randomEnv}, ${randomPose}, ${randomExpression}. Wearing ${randomOutfit}. ${styleDesc}. Fashion editorial style, creative composition${focalDesc}.${productText}`;
                }
            }

            return prompt;
        }

        // Render results
        function renderResults() {
            if (state.results.length === 0) {
                elements.resultsSection.classList.remove('visible');
                return;
            }

            elements.resultsSection.classList.add('visible');
            elements.resultsGrid.innerHTML = state.results.map((result, index) => `
                <div class="result-card" onclick="openLightbox(${index})">
                    <img src="${result.url}" alt="Result ${index + 1}" class="result-image">
                </div>
            `).join('');
        }

        // Lightbox
        window.openLightbox = function(index) {
            state.lightboxIndex = index;
            updateLightboxContent();
            elements.lightbox.classList.add('visible');
        };

        function updateLightboxContent() {
            const result = state.results[state.lightboxIndex];
            elements.lightboxImage.src = result.url;
            elements.lightboxType.textContent = result.type;
            elements.lightboxPrompt.textContent = result.prompt;
        }

        function closeLightbox() {
            elements.lightbox.classList.remove('visible');
        }

        // Initialize
        init();
    </script>
</body>
</html>
