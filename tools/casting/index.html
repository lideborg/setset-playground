<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LockGroup v001</title>
    <link rel="stylesheet" href="/shared/css/tokens.css">
    <link rel="stylesheet" href="/shared/css/base.css">
    <link rel="stylesheet" href="/shared/css/components.css">
    <style>
        .container {
            max-width: 1200px;
        }

        /* Step Sections */
        .step-section {
            margin-bottom: var(--space-lg);
            padding-bottom: var(--space-lg);
            border-bottom: 1px solid var(--gainsboro);
        }

        .step-header {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            margin-bottom: var(--space-md);
        }

        .step-number {
            width: 28px;
            height: 28px;
            background: var(--jet);
            color: var(--white);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: var(--text-sm);
            font-weight: 600;
        }

        .step-title {
            font-size: var(--text-lg);
            font-weight: 600;
            color: var(--jet);
        }

        /* Model Upload */
        .model-upload-area {
            display: flex;
            gap: var(--space-md);
            align-items: flex-start;
        }

        .model-upload-slot {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--space-xs);
        }

        .model-slot-label {
            font-size: var(--text-xs);
            color: var(--slate);
        }

        .model-preview {
            width: 200px;
            aspect-ratio: 3/4;
            border: 2px dashed var(--gainsboro);
            border-radius: var(--radius-md);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            overflow: hidden;
            transition: all var(--transition-fast);
            background: var(--off-white);
        }

        .model-preview:hover {
            border-color: var(--jet);
        }

        .model-preview.has-image {
            border-style: solid;
            border-color: var(--jet);
        }

        .model-preview img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .model-preview-placeholder {
            text-align: center;
            color: var(--ash-grey);
            padding: var(--space-md);
        }

        .model-preview-placeholder svg {
            width: 48px;
            height: 48px;
            margin-bottom: var(--space-xs);
            opacity: 0.5;
        }

        /* Poses Grid */
        .poses-container {
            display: flex;
            flex-direction: column;
            gap: var(--space-md);
        }

        .pose-category {
            margin-bottom: var(--space-sm);
        }

        .pose-category-title {
            font-size: var(--text-sm);
            font-weight: 600;
            color: var(--slate);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: var(--space-xs);
        }

        .poses-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: var(--space-2xs);
        }

        .pose-card {
            display: flex;
            flex-direction: column;
            border-radius: var(--radius-md);
            overflow: hidden;
            border: 2px solid var(--gainsboro);
            transition: all var(--transition-fast);
            background: var(--white);
        }

        .pose-card.active {
            border-color: var(--jet);
        }

        .pose-card-image {
            aspect-ratio: 3/4;
            position: relative;
            cursor: pointer;
            overflow: hidden;
        }

        .pose-card-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .pose-card .pose-name {
            font-size: 9px;
            padding: 3px 2px;
            text-align: center;
            background: var(--off-white);
            color: var(--slate);
            border-top: 1px solid var(--gainsboro);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .pose-card .pose-count {
            position: absolute;
            top: 3px;
            right: 3px;
            min-width: 14px;
            height: 14px;
            background: var(--jet);
            color: var(--white);
            border-radius: 7px;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            font-weight: 600;
            padding: 0 3px;
        }

        .pose-card.active .pose-count {
            display: flex;
        }

        .pose-slider-row {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px 4px;
            background: var(--off-white);
        }

        .pose-slider {
            width: 95%;
            -webkit-appearance: none;
            height: 2px;
            background: var(--gainsboro);
            border-radius: 1px;
            outline: none;
            margin: 0;
        }

        .pose-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: var(--jet);
            border-radius: 50%;
            cursor: pointer;
        }

        .pose-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: var(--jet);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }


        /* Products Upload */
        .products-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-md);
        }

        .products-column {
            flex: 1;
        }

        .products-column-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-xs);
        }

        .products-column-title {
            font-size: var(--text-sm);
            font-weight: 600;
            color: var(--slate);
        }

        .products-column-actions {
            display: flex;
            gap: var(--space-2xs);
        }

        .btn-mini {
            font-size: var(--text-2xs);
            padding: 2px 6px;
            background: var(--white);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-sm);
            color: var(--slate);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .btn-mini:hover {
            background: var(--off-white);
            border-color: var(--ash-grey);
            color: var(--jet);
        }

        .folder-drop-zone {
            min-height: 200px;
            border: 2px dashed var(--gainsboro);
            border-radius: var(--radius-md);
            padding: var(--space-md);
            transition: all var(--transition-fast);
            background: var(--off-white);
        }

        .folder-drop-zone.drag-over {
            border-color: var(--jet);
            background: var(--white);
        }

        .folder-drop-zone.has-images {
            border-style: solid;
            border-color: var(--gainsboro);
        }

        .drop-placeholder {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 150px;
            color: var(--ash-grey);
            text-align: center;
        }

        .drop-placeholder svg {
            width: 48px;
            height: 48px;
            margin-bottom: var(--space-xs);
            opacity: 0.5;
        }

        .products-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: var(--space-xs);
        }

        .product-thumb {
            aspect-ratio: 3/4;
            width: 100%;
            border-radius: var(--radius-sm);
            overflow: hidden;
            position: relative;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all var(--transition-fast);
        }

        .product-thumb:hover {
            border-color: var(--ash-grey);
        }

        .product-thumb.selected {
            border-color: var(--jet);
        }

        .product-thumb.deselected {
            opacity: 0.4;
        }

        .product-thumb img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .product-thumb .product-check {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 16px;
            height: 16px;
            background: var(--jet);
            color: var(--white);
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 10px;
        }

        .product-thumb.selected .product-check {
            display: flex;
        }

        /* Analysis Section */
        .analysis-section {
            background: var(--off-white);
            border-radius: var(--radius-md);
            padding: var(--space-md);
        }

        .analysis-results {
            display: none;
        }

        .analysis-results.visible {
            display: block;
        }

        .analysis-item {
            display: flex;
            gap: var(--space-sm);
            padding: var(--space-sm) 0;
            border-bottom: 1px solid var(--gainsboro);
        }

        .analysis-item:last-child {
            border-bottom: none;
        }

        .analysis-thumb {
            width: 60px;
            height: 60px;
            border-radius: var(--radius-sm);
            object-fit: cover;
        }

        .analysis-content {
            flex: 1;
        }

        .analysis-category {
            font-size: var(--text-xs);
            color: var(--slate);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .analysis-description {
            font-size: var(--text-sm);
            color: var(--jet);
            margin-top: var(--space-2xs);
        }

        .analysis-group {
            margin-bottom: var(--space-md);
        }

        .analysis-group-title {
            font-size: var(--text-xs);
            font-weight: 600;
            color: var(--slate);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: var(--space-xs);
            padding-bottom: var(--space-2xs);
            border-bottom: 1px solid var(--gainsboro);
        }

        .analysis-item.styling-ref {
            background: #f0fdf4;
            border-radius: var(--radius-sm);
            padding: var(--space-xs);
        }

        .outfit-summary {
            margin-top: var(--space-md);
            padding: var(--space-md);
            background: var(--white);
            border-radius: var(--radius-md);
            border: 1px solid var(--gainsboro);
        }

        .outfit-summary-title {
            font-size: var(--text-xs);
            font-weight: 600;
            color: var(--jet);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: var(--space-xs);
        }

        .outfit-summary-text {
            font-size: var(--text-sm);
            color: var(--slate);
            line-height: 1.5;
        }

        /* Generate Section */
        .generate-section {
            background: var(--off-white);
            border-radius: var(--radius-md);
            padding: var(--space-md);
        }

        .calc-display {
            font-size: var(--text-sm);
            color: var(--slate);
            margin-bottom: var(--space-sm);
            text-align: center;
        }

        /* Results */
        .results-section {
            margin-top: var(--space-lg);
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: var(--space-md);
        }

        .result-card {
            position: relative;
            border-radius: var(--radius-md);
            overflow: hidden;
            cursor: pointer;
            background: var(--off-white);
        }

        .result-card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .result-card .model-tag {
            position: absolute;
            bottom: var(--space-xs);
            left: var(--space-xs);
            background: rgba(0,0,0,0.7);
            color: var(--white);
            padding: 2px 8px;
            border-radius: var(--radius-sm);
            font-size: var(--text-2xs);
        }

        /* Error */
        .error {
            display: none;
            background: #fef2f2;
            border: 1px solid #fecaca;
            padding: var(--space-sm);
            color: #991b1b;
            margin-bottom: var(--space-md);
            font-size: var(--text-base);
            text-align: center;
            border-radius: var(--radius-md);
        }

        .error.show {
            display: block;
        }

        input[type="file"] {
            display: none;
        }

        .notes-input {
            width: 100%;
            min-height: 60px;
            padding: var(--space-sm);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-md);
            font-family: var(--font-sans);
            font-size: var(--text-sm);
            resize: vertical;
            background: var(--white);
        }

        .notes-input:focus {
            outline: none;
            border-color: var(--jet);
        }

        .notes-input::placeholder {
            color: var(--ash-grey);
        }

        /* Lightbox nav overrides */
        .lightbox-nav {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255,255,255,0.1);
            border: none;
            width: 48px;
            height: 48px;
            font-size: 24px;
            cursor: pointer;
            color: var(--white);
            z-index: 10;
            border-radius: 50%;
            transition: background var(--transition-fast);
        }

        .lightbox-nav:hover {
            background: rgba(255,255,255,0.2);
        }

        .lightbox-nav.prev {
            left: var(--space-md);
        }

        .lightbox-nav.next {
            right: calc(33.33% + var(--space-md));
        }

        .lightbox-nav:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .lightbox-counter {
            font-size: var(--text-sm);
            color: var(--slate);
            margin-bottom: var(--space-sm);
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="hero">
            <h1>LockGroup</h1>
            <p class="hero-subtitle">Create styled looks from product folders</p>
        </div>

        <div class="error" id="error"></div>

        <!-- Step 1: Model -->
        <div class="step-section">
            <div class="step-header">
                <span class="step-number">1</span>
                <span class="step-title">Upload Model Reference</span>
            </div>
            <div class="model-upload-area">
                <div class="model-upload-slot">
                    <div class="model-preview" id="modelPreview" data-type="fullbody">
                        <div class="model-preview-placeholder">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                            </svg>
                            <div>Full Body</div>
                        </div>
                    </div>
                    <div class="model-slot-label">Full Body</div>
                </div>
                <div class="model-upload-slot">
                    <div class="model-preview" id="modelPreviewPortrait" data-type="portrait">
                        <div class="model-preview-placeholder">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                            </svg>
                            <div>Portrait</div>
                        </div>
                    </div>
                    <div class="model-slot-label">Portrait (optional)</div>
                </div>
                <input type="file" id="modelInput" accept="image/*">
                <input type="file" id="modelInputPortrait" accept="image/*">
            </div>
        </div>

        <!-- Step 2: Poses -->
        <div class="step-section">
            <div class="step-header">
                <span class="step-number">2</span>
                <span class="step-title">Select Poses</span>
            </div>
            <div class="poses-container" id="posesContainer"></div>
        </div>

        <!-- Step 3: Products -->
        <div class="step-section">
            <div class="step-header">
                <span class="step-number">3</span>
                <span class="step-title">Upload Product Folder</span>
            </div>
            <p style="font-size: var(--text-sm); color: var(--slate); margin-bottom: var(--space-md);">
                Drop a folder with <strong>Hero_Product</strong> and <strong>Looks</strong> subfolders, or drop images directly into each box.
            </p>
            <div class="products-row">
                <div class="products-column">
                    <div class="products-column-header">
                        <div class="products-column-title">Hero Product</div>
                        <div class="products-column-actions" id="heroActions" style="display: none;">
                            <button class="btn-mini" onclick="selectAll('hero')">Select All</button>
                            <button class="btn-mini" onclick="deselectAll('hero')">Deselect All</button>
                        </div>
                    </div>
                    <div class="folder-drop-zone" id="heroDropZone" data-type="hero">
                        <div class="drop-placeholder" id="heroPlaceholder">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                            </svg>
                            <div>Drop hero product images<br>or folder here</div>
                        </div>
                        <div class="products-grid" id="heroGrid"></div>
                    </div>
                    <input type="file" id="heroInput" accept="image/*" multiple webkitdirectory>
                </div>
                <div class="products-column">
                    <div class="products-column-header">
                        <div class="products-column-title">Looks (Accessories)</div>
                        <div class="products-column-actions" id="looksActions" style="display: none;">
                            <button class="btn-mini" onclick="selectAll('looks')">Select All</button>
                            <button class="btn-mini" onclick="deselectAll('looks')">Deselect All</button>
                        </div>
                    </div>
                    <div class="folder-drop-zone" id="looksDropZone" data-type="looks">
                        <div class="drop-placeholder" id="looksPlaceholder">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" />
                            </svg>
                            <div>Drop accessory images<br>or folder here</div>
                        </div>
                        <div class="products-grid" id="looksGrid"></div>
                    </div>
                    <input type="file" id="looksInput" accept="image/*" multiple webkitdirectory>
                </div>
            </div>
        </div>

        <!-- Step 4: Notes -->
        <div class="step-section">
            <div class="step-header">
                <span class="step-number">4</span>
                <span class="step-title">Styling Notes (Optional)</span>
            </div>
            <textarea class="notes-input" id="stylingNotes" placeholder="Add any styling notes or exclusions, e.g., 'no sunglasses', 'casual vibe', 'model should not wear the black bag'..."></textarea>
        </div>

        <!-- Step 5: Analyze -->
        <div class="step-section">
            <div class="step-header">
                <span class="step-number">5</span>
                <span class="step-title">Analyze Products</span>
            </div>
            <div class="analysis-section">
                <button class="btn btn--primary" id="analyzeBtn" disabled>Analyze Selected Products</button>
                <div class="analysis-results" id="analysisResults">
                    <h4 style="margin: var(--space-md) 0 var(--space-sm);">Analysis Results</h4>
                    <div id="analysisContent"></div>
                </div>
            </div>
        </div>

        <!-- Step 6: Generate -->
        <div class="step-section" style="border-bottom: none;">
            <div class="step-header">
                <span class="step-number">6</span>
                <span class="step-title">Generate Images</span>
            </div>
            <div class="generate-section">
                <!-- Settings Row -->
                <div class="settings-row" style="margin-bottom: var(--space-md);">
                    <div class="setting-group">
                        <label class="setting-label">Model</label>
                        <div class="btn-group" id="model-buttons">
                            <button class="btn btn--toggle active" data-model="nanobanana">Nano Banana</button>
                        </div>
                    </div>
                    <div class="setting-group">
                        <label class="setting-label">Aspect Ratio</label>
                        <div class="btn-group" id="aspect-buttons">
                            <button class="btn btn--toggle active" data-value="3:4">3:4</button>
                            <button class="btn btn--toggle" data-value="1:1">1:1</button>
                            <button class="btn btn--toggle" data-value="4:3">4:3</button>
                        </div>
                    </div>
                    <div class="setting-group">
                        <label class="setting-label">Resolution</label>
                        <div class="btn-group" id="resolution-buttons">
                            <button class="btn btn--toggle active" data-value="1K">1K</button>
                            <button class="btn btn--toggle" data-value="2K">2K</button>
                        </div>
                    </div>
                </div>

                <div class="calc-display" id="calc-display">Select model, poses, and products to generate</div>
                <button class="btn btn--primary btn--lg btn--block" id="generateBtn" disabled>
                    Generate Images <span class="btn-cost" id="cost-value">$0.00</span>
                </button>
            </div>
        </div>

        <!-- Progress -->
        <div class="progress-section" id="progress-section">
            <div class="progress-header">
                <span class="progress-title">Generating</span>
                <span class="progress-count" id="progress-count">0 / 0</span>
            </div>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
        </div>

        <!-- Results -->
        <div class="results-section" id="results-section">
            <div class="results-header">
                <h2>Results</h2>
                <p class="results-subtitle">Click to view details</p>
            </div>
            <div class="results-grid" id="results-grid"></div>
        </div>
    </div>

    <!-- Lightbox -->
    <div class="lightbox" id="lightbox">
        <div class="lightbox-content">
            <button class="lightbox-close" id="lightbox-close">&times;</button>
            <button class="lightbox-nav prev" id="lightbox-prev">&larr;</button>
            <button class="lightbox-nav next" id="lightbox-next">&rarr;</button>
            <div class="lightbox-left">
                <img src="" alt="" class="lightbox-image" id="lightbox-image">
            </div>
            <div class="lightbox-right">
                <div class="lightbox-counter" id="lightbox-counter">1 / 1</div>
                <div class="lightbox-section">
                    <h3 class="lightbox-section-title">Pose</h3>
                    <p class="lightbox-model-text" id="lightbox-pose"></p>
                </div>
                <div class="lightbox-section">
                    <h3 class="lightbox-section-title">Prompt</h3>
                    <p class="lightbox-prompt-text" id="lightbox-prompt"></p>
                </div>
                <button class="lightbox-download" id="lightbox-download">Download Image</button>
            </div>
        </div>
    </div>

    <!-- Loading -->
    <div class="loading-overlay" id="loading">
        <div class="spinner"></div>
        <p class="loading-text" id="loading-text">Analyzing...</p>
    </div>

    <!-- Scripts -->
    <script src="poses.js"></script>
    <script src="/shared/js/utils.js"></script>
    <script src="/shared/js/api.js"></script>

    <script>
        // State
        const state = {
            modelImage: null,
            modelImagePortrait: null,
            poseCounts: {}, // { poseId: count } - how many images per pose
            heroImages: [],
            looksImages: [],
            analysisResults: [],
            aspectRatio: '3:4',
            resolution: '1K',
            results: [],
            lightboxIndex: 0
        };

        // DOM Elements
        const elements = {
            modelPreview: document.getElementById('modelPreview'),
            modelPreviewPortrait: document.getElementById('modelPreviewPortrait'),
            modelInput: document.getElementById('modelInput'),
            modelInputPortrait: document.getElementById('modelInputPortrait'),
            posesContainer: document.getElementById('posesContainer'),
            heroDropZone: document.getElementById('heroDropZone'),
            looksDropZone: document.getElementById('looksDropZone'),
            heroGrid: document.getElementById('heroGrid'),
            looksGrid: document.getElementById('looksGrid'),
            heroPlaceholder: document.getElementById('heroPlaceholder'),
            looksPlaceholder: document.getElementById('looksPlaceholder'),
            heroInput: document.getElementById('heroInput'),
            looksInput: document.getElementById('looksInput'),
            analyzeBtn: document.getElementById('analyzeBtn'),
            analysisResults: document.getElementById('analysisResults'),
            analysisContent: document.getElementById('analysisContent'),
            generateBtn: document.getElementById('generateBtn'),
            calcDisplay: document.getElementById('calc-display'),
            costValue: document.getElementById('cost-value'),
            resolutionButtons: document.getElementById('resolution-buttons'),
            progressSection: document.getElementById('progress-section'),
            progressCount: document.getElementById('progress-count'),
            progressBar: document.getElementById('progress-bar'),
            resultsSection: document.getElementById('results-section'),
            resultsGrid: document.getElementById('results-grid'),
            errorDiv: document.getElementById('error'),
            lightbox: document.getElementById('lightbox'),
            lightboxImage: document.getElementById('lightbox-image'),
            lightboxPose: document.getElementById('lightbox-pose'),
            lightboxPrompt: document.getElementById('lightbox-prompt'),
            loading: document.getElementById('loading'),
            loadingText: document.getElementById('loading-text')
        };

        // Initialize poses grid
        function initializePoses() {
            const pdpPoses = POSES.filter(p => p.category === 'pdp' || p.category === 'detail');
            const lifestylePoses = POSES.filter(p => p.category === 'lifestyle');

            const pdpHtml = `
                <div class="pose-category">
                    <div class="pose-category-title">PDP / E-Commerce</div>
                    <div class="poses-grid">
                        ${pdpPoses.map(pose => createPoseCard(pose)).join('')}
                    </div>
                </div>
            `;

            const lifestyleHtml = `
                <div class="pose-category">
                    <div class="pose-category-title">Lifestyle / Editorial</div>
                    <div class="poses-grid">
                        ${lifestylePoses.map(pose => createPoseCard(pose)).join('')}
                    </div>
                </div>
            `;

            elements.posesContainer.innerHTML = pdpHtml + lifestyleHtml;

            // Add slider handlers
            elements.posesContainer.querySelectorAll('.pose-slider').forEach(slider => {
                slider.addEventListener('input', (e) => {
                    const poseId = e.target.dataset.pose;
                    const count = parseInt(e.target.value);
                    updatePoseCount(poseId, count);
                });
            });

            // Build pose lookup map for fast access (avoid .find() on every hover)
            const poseMap = {};
            POSES.forEach(p => poseMap[p.id] = p);

            // Add hover handlers for image preview
            elements.posesContainer.querySelectorAll('.pose-card-image').forEach(imageContainer => {
                const card = imageContainer.closest('.pose-card');
                const poseId = card.dataset.id;
                const pose = poseMap[poseId];
                const img = imageContainer.querySelector('img');

                if (pose && pose.hoverImage) {
                    imageContainer.addEventListener('mouseenter', () => {
                        img.src = pose.hoverImage;
                    });
                    imageContainer.addEventListener('mouseleave', () => {
                        img.src = pose.defaultImage;
                    });
                }

                // Click on image sets slider to 1 (or 0 if already active)
                imageContainer.addEventListener('click', () => {
                    const currentCount = state.poseCounts[poseId] || 0;
                    const newCount = currentCount > 0 ? 0 : 1;
                    const slider = card.querySelector('.pose-slider');
                    slider.value = newCount;
                    updatePoseCount(poseId, newCount);
                });
            });
        }

        function createPoseCard(pose) {
            // Initialize pose count to 0
            state.poseCounts[pose.id] = 0;
            return `
                <div class="pose-card" data-id="${pose.id}">
                    <div class="pose-card-image">
                        <img src="${pose.defaultImage}" alt="${pose.name}">
                        <span class="pose-count" data-count="${pose.id}">0</span>
                    </div>
                    <div class="pose-name">${pose.name}</div>
                    <div class="pose-slider-row">
                        <input type="range" class="pose-slider" data-pose="${pose.id}" min="0" max="4" value="0">
                    </div>
                </div>
            `;
        }

        function updatePoseCount(poseId, count) {
            state.poseCounts[poseId] = count;
            const card = elements.posesContainer.querySelector(`[data-id="${poseId}"]`);
            const countBadge = card.querySelector(`[data-count="${poseId}"]`);

            countBadge.textContent = count;

            if (count > 0) {
                card.classList.add('active');
            } else {
                card.classList.remove('active');
            }

            updateCalculator();
        }

        // Model upload - Full Body
        elements.modelPreview.addEventListener('click', () => elements.modelInput.click());
        elements.modelInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleModelUpload(e.target.files[0], 'fullbody');
            }
        });

        // Model upload - Portrait
        elements.modelPreviewPortrait.addEventListener('click', () => elements.modelInputPortrait.click());
        elements.modelInputPortrait.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleModelUpload(e.target.files[0], 'portrait');
            }
        });

        function handleModelUpload(file, type = 'fullbody') {
            const reader = new FileReader();
            reader.onload = (e) => {
                if (type === 'fullbody') {
                    state.modelImage = { file, url: e.target.result };
                    elements.modelPreview.innerHTML = `<img src="${e.target.result}" alt="Model Full Body">`;
                    elements.modelPreview.classList.add('has-image');
                } else {
                    state.modelImagePortrait = { file, url: e.target.result };
                    elements.modelPreviewPortrait.innerHTML = `<img src="${e.target.result}" alt="Model Portrait">`;
                    elements.modelPreviewPortrait.classList.add('has-image');
                }
                updateCalculator();
            };
            reader.readAsDataURL(file);
        }

        // Drag and drop for model - Full Body
        elements.modelPreview.addEventListener('dragover', (e) => {
            e.preventDefault();
            elements.modelPreview.style.borderColor = 'var(--jet)';
        });
        elements.modelPreview.addEventListener('dragleave', () => {
            elements.modelPreview.style.borderColor = '';
        });
        elements.modelPreview.addEventListener('drop', (e) => {
            e.preventDefault();
            elements.modelPreview.style.borderColor = '';
            const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
            if (files.length > 0) {
                handleModelUpload(files[0], 'fullbody');
            }
        });

        // Drag and drop for model - Portrait
        elements.modelPreviewPortrait.addEventListener('dragover', (e) => {
            e.preventDefault();
            elements.modelPreviewPortrait.style.borderColor = 'var(--jet)';
        });
        elements.modelPreviewPortrait.addEventListener('dragleave', () => {
            elements.modelPreviewPortrait.style.borderColor = '';
        });
        elements.modelPreviewPortrait.addEventListener('drop', (e) => {
            e.preventDefault();
            elements.modelPreviewPortrait.style.borderColor = '';
            const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
            if (files.length > 0) {
                handleModelUpload(files[0], 'portrait');
            }
        });

        // Products drag and drop
        function setupDropZone(dropZone, grid, placeholder, type) {
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('drag-over');
            });
            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('drag-over');
            });
            dropZone.addEventListener('drop', async (e) => {
                e.preventDefault();
                dropZone.classList.remove('drag-over');

                const items = e.dataTransfer.items;
                const files = [];

                // Handle folder drops
                for (const item of items) {
                    if (item.webkitGetAsEntry) {
                        const entry = item.webkitGetAsEntry();
                        if (entry) {
                            await traverseFileTree(entry, files, type);
                        }
                    }
                }

                // If no folder entries, use regular files
                if (files.length === 0) {
                    const droppedFiles = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
                    files.push(...droppedFiles);
                }

                if (files.length > 0) {
                    handleProductFiles(files, type);
                }
            });

            dropZone.addEventListener('click', (e) => {
                if (e.target === dropZone || e.target === placeholder || placeholder.contains(e.target)) {
                    const input = type === 'hero' ? elements.heroInput : elements.looksInput;
                    input.click();
                }
            });
        }

        async function traverseFileTree(entry, files, expectedType) {
            if (entry.isFile) {
                const file = await new Promise(resolve => entry.file(resolve));
                if (file.type.startsWith('image/')) {
                    files.push(file);
                }
            } else if (entry.isDirectory) {
                const dirName = entry.name.toLowerCase();
                const reader = entry.createReader();
                const entries = await new Promise(resolve => reader.readEntries(resolve));

                // Check if this is a Hero_Product or Looks folder
                if (dirName.includes('hero') && expectedType === 'hero') {
                    for (const childEntry of entries) {
                        await traverseFileTree(childEntry, files, expectedType);
                    }
                } else if (dirName.includes('look') && expectedType === 'looks') {
                    for (const childEntry of entries) {
                        await traverseFileTree(childEntry, files, expectedType);
                    }
                } else {
                    // For other directories, check children
                    for (const childEntry of entries) {
                        await traverseFileTree(childEntry, files, expectedType);
                    }
                }
            }
        }

        function handleProductFiles(files, type) {
            const images = type === 'hero' ? state.heroImages : state.looksImages;
            const grid = type === 'hero' ? elements.heroGrid : elements.looksGrid;
            const placeholder = type === 'hero' ? elements.heroPlaceholder : elements.looksPlaceholder;
            const dropZone = type === 'hero' ? elements.heroDropZone : elements.looksDropZone;

            files.forEach(file => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const imageData = { file, url: e.target.result, selected: false, name: file.name };
                    images.push(imageData);
                    renderProductGrid(type);
                    updateCalculator();
                };
                reader.readAsDataURL(file);
            });

            placeholder.style.display = 'none';
            dropZone.classList.add('has-images');

            // Show select/deselect buttons
            const actionsEl = document.getElementById(`${type}Actions`);
            if (actionsEl) actionsEl.style.display = 'flex';
        }

        // Select/Deselect all functions
        window.selectAll = function(type) {
            const images = type === 'hero' ? state.heroImages : state.looksImages;
            images.forEach(img => img.selected = true);
            renderProductGrid(type, false); // Fast update, just classes
            updateCalculator();
        };

        window.deselectAll = function(type) {
            const images = type === 'hero' ? state.heroImages : state.looksImages;
            images.forEach(img => img.selected = false);
            renderProductGrid(type, false); // Fast update, just classes
            updateCalculator();
        };

        function renderProductGrid(type, fullRender = true) {
            const images = type === 'hero' ? state.heroImages : state.looksImages;
            const grid = type === 'hero' ? elements.heroGrid : elements.looksGrid;

            if (fullRender) {
                grid.innerHTML = images.map((img, idx) => `
                    <div class="product-thumb ${img.selected ? 'selected' : 'deselected'}" data-index="${idx}" data-type="${type}">
                        <img src="${img.url}" alt="${img.name}">
                        <span class="product-check">✓</span>
                    </div>
                `).join('');

                // Use event delegation on the grid instead of individual listeners
                grid.onclick = (e) => {
                    const thumb = e.target.closest('.product-thumb');
                    if (!thumb) return;
                    const idx = parseInt(thumb.dataset.index);
                    const t = thumb.dataset.type;
                    const imgs = t === 'hero' ? state.heroImages : state.looksImages;
                    imgs[idx].selected = !imgs[idx].selected;
                    // Just toggle classes, don't re-render
                    thumb.classList.toggle('selected', imgs[idx].selected);
                    thumb.classList.toggle('deselected', !imgs[idx].selected);
                    updateCalculator();
                };
            } else {
                // Just update classes without re-rendering
                grid.querySelectorAll('.product-thumb').forEach((thumb, idx) => {
                    thumb.classList.toggle('selected', images[idx].selected);
                    thumb.classList.toggle('deselected', !images[idx].selected);
                });
            }
        }

        // File inputs
        elements.heroInput.addEventListener('change', (e) => {
            const files = Array.from(e.target.files).filter(f => f.type.startsWith('image/'));
            if (files.length > 0) handleProductFiles(files, 'hero');
            e.target.value = '';
        });

        elements.looksInput.addEventListener('change', (e) => {
            const files = Array.from(e.target.files).filter(f => f.type.startsWith('image/'));
            if (files.length > 0) handleProductFiles(files, 'looks');
            e.target.value = '';
        });

        setupDropZone(elements.heroDropZone, elements.heroGrid, elements.heroPlaceholder, 'hero');
        setupDropZone(elements.looksDropZone, elements.looksGrid, elements.looksPlaceholder, 'looks');

        // Aspect ratio buttons
        document.getElementById('aspect-buttons').addEventListener('click', (e) => {
            if (e.target.classList.contains('btn--toggle')) {
                document.getElementById('aspect-buttons').querySelectorAll('.btn--toggle').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                state.aspectRatio = e.target.dataset.value;
            }
        });

        // Resolution buttons
        elements.resolutionButtons.addEventListener('click', (e) => {
            if (e.target.classList.contains('btn--toggle')) {
                elements.resolutionButtons.querySelectorAll('.btn--toggle').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                state.resolution = e.target.dataset.value;
                updateCalculator();
            }
        });

        // Calculator - total images = sum of all pose counts
        function updateCalculator() {
            const hasModel = state.modelImage !== null;
            const selectedHero = state.heroImages.filter(i => i.selected);
            const selectedLooks = state.looksImages.filter(i => i.selected);
            const numHero = selectedHero.length;
            const numLooks = selectedLooks.length;

            // Enable analyze button if we have at least one hero product
            elements.analyzeBtn.disabled = numHero === 0;

            // Calculate total images: sum of all pose counts
            const totalImages = Object.values(state.poseCounts).reduce((sum, count) => sum + count, 0);
            const activePoses = Object.entries(state.poseCounts).filter(([_, count]) => count > 0);

            // Calculate cost (Nano Banana = $0.15 per image, 2K = double)
            let costPerImage = 0.15;
            if (state.resolution === '2K') costPerImage *= 2;
            const totalCost = totalImages * costPerImage;

            // Build display text
            let displayText = `${totalImages} images`;
            if (activePoses.length > 0) {
                const poseBreakdown = activePoses.map(([poseId, count]) => {
                    const pose = POSES.find(p => p.id === poseId);
                    return `${count}× ${pose?.name || poseId}`;
                }).join(', ');
                displayText = `${totalImages} images (${poseBreakdown})`;
            }
            elements.calcDisplay.textContent = displayText;
            elements.costValue.textContent = formatCost(totalCost);

            // Need model, at least one image to generate, at least one hero product, and analysis done
            elements.generateBtn.disabled = !hasModel || totalImages === 0 || numHero === 0 || state.analysisResults.length === 0;
        }

        // Analyze products
        elements.analyzeBtn.addEventListener('click', analyzeProducts);

        async function analyzeProducts() {
            const selectedHero = state.heroImages.filter(i => i.selected);
            const selectedLooks = state.looksImages.filter(i => i.selected);

            if (selectedHero.length === 0) {
                showError('Please select at least one hero product');
                return;
            }

            elements.loading.classList.add('visible');
            state.analysisResults = [];

            try {
                // Analyze hero products first
                for (let i = 0; i < selectedHero.length; i++) {
                    elements.loadingText.textContent = `Analyzing hero product ${i + 1}/${selectedHero.length}...`;
                    const analysis = await analyzeImage(selectedHero[i], true);
                    state.analysisResults.push({
                        image: selectedHero[i],
                        source: 'hero',
                        ...analysis
                    });
                }

                // Then analyze looks/accessories
                for (let i = 0; i < selectedLooks.length; i++) {
                    elements.loadingText.textContent = `Analyzing accessory ${i + 1}/${selectedLooks.length}...`;
                    const analysis = await analyzeImage(selectedLooks[i], false);
                    state.analysisResults.push({
                        image: selectedLooks[i],
                        source: 'looks',
                        ...analysis
                    });
                }

                // Display results
                renderAnalysisResults();
                elements.analysisResults.classList.add('visible');
                updateCalculator();

            } catch (error) {
                console.error('Analysis error:', error);
                showError('Failed to analyze products: ' + error.message);
            } finally {
                elements.loading.classList.remove('visible');
            }
        }

        async function analyzeImage(img, isHero = false) {
            try {
                const response = await fetch('/api/analyze', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        image: img.url,
                        prompt: `Analyze this fashion product image carefully. Determine:

1. IMAGE TYPE - Is this:
   - "product_only": Just the product (on hanger, flat lay, mannequin, or product shot)
   - "styling_reference": A full outfit/look on a model showing how items should be styled together
   - "accessory": A single accessory item (bag, shoes, sunglasses, jewelry, etc.)

2. PRODUCT CATEGORY: coat, jacket, dress, pants, skirt, bag, shoes, boots, sunglasses, jewelry, scarf, hat, etc.

3. DETAILED DESCRIPTION for AI image generation. CRITICAL - Include ALL of these details:
   - Color and material (e.g., "charcoal wool", "black leather")
   - FIT: oversized, relaxed, slim, fitted, boxy, cropped, etc.
   - LENGTH: extra long, floor-length, ankle-length, cropped, midi, etc.
   - SILHOUETTE: wide-leg, straight-leg, tapered, A-line, etc.
   - For PANTS especially: note if they pool at ankles, have break, are hemmed short
   - Key construction details (pleats, seams, pockets, closures)

4. PROMPT FRAGMENT: A concise but SPECIFIC description for dressing a model.
   IMPORTANT: Always include fit and length. Examples:
   - "oversized charcoal wool trousers with extra-long wide legs pooling at the ankles"
   - "relaxed-fit cream linen pants with soft pleats and straight leg"
   - "slim black tailored trousers cropped above the ankle"

Respond ONLY with valid JSON:
{
    "imageType": "product_only" | "styling_reference" | "accessory",
    "category": "string",
    "description": "string",
    "promptFragment": "string",
    "stylingNotes": "string (only if imageType is styling_reference - describe the overall styling aesthetic)",
    "background": "string (only if styling_reference - describe the background/setting: studio color, environment, props)",
    "lighting": "string (only if styling_reference - describe lighting: soft, harsh, directional, natural, studio flash, shadows)"
}`
                    })
                });

                if (!response.ok) throw new Error('Analysis API error');

                const data = await response.json();
                // Try to extract JSON from the response
                let content = data.content;
                const jsonMatch = content.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    content = jsonMatch[0];
                }
                return JSON.parse(content);
            } catch (error) {
                console.error('Image analysis error:', error);
                // Fallback analysis
                return {
                    imageType: isHero ? 'product_only' : 'accessory',
                    category: 'unknown',
                    description: 'Fashion product',
                    promptFragment: 'fashion item',
                    stylingNotes: null
                };
            }
        }

        function renderAnalysisResults() {
            // Group by type
            const heroProducts = state.analysisResults.filter(r => r.source === 'hero' && r.imageType !== 'styling_reference');
            const accessories = state.analysisResults.filter(r => r.source === 'looks' && r.imageType !== 'styling_reference');
            const stylingRefs = state.analysisResults.filter(r => r.imageType === 'styling_reference');

            let html = '';

            if (heroProducts.length > 0) {
                html += `<div class="analysis-group"><div class="analysis-group-title">Hero Product</div>`;
                html += heroProducts.map(result => createAnalysisItem(result)).join('');
                html += `</div>`;
            }

            if (accessories.length > 0) {
                html += `<div class="analysis-group"><div class="analysis-group-title">Accessories</div>`;
                html += accessories.map(result => createAnalysisItem(result)).join('');
                html += `</div>`;
            }

            if (stylingRefs.length > 0) {
                html += `<div class="analysis-group"><div class="analysis-group-title">Styling Reference (Background & Lighting)</div>`;
                html += stylingRefs.map(result => `
                    <div class="analysis-item styling-ref">
                        <img src="${result.image.url}" alt="" class="analysis-thumb">
                        <div class="analysis-content">
                            <div class="analysis-category">STYLING REFERENCE</div>
                            <div class="analysis-description">${result.stylingNotes || result.description}</div>
                            ${result.background ? `<div class="analysis-description" style="margin-top: 4px;"><strong>Background:</strong> ${result.background}</div>` : ''}
                            ${result.lighting ? `<div class="analysis-description" style="margin-top: 2px;"><strong>Lighting:</strong> ${result.lighting}</div>` : ''}
                        </div>
                    </div>
                `).join('');
                html += `</div>`;
            }

            // Show combined outfit description
            const outfitDesc = buildOutfitDescription();
            if (outfitDesc) {
                html += `
                    <div class="outfit-summary">
                        <div class="outfit-summary-title">Combined Outfit</div>
                        <div class="outfit-summary-text">${outfitDesc}</div>
                    </div>
                `;
            }

            elements.analysisContent.innerHTML = html;
        }

        function createAnalysisItem(result) {
            const typeLabel = result.imageType === 'accessory' ? result.category.toUpperCase() : result.category.toUpperCase();
            return `
                <div class="analysis-item">
                    <img src="${result.image.url}" alt="" class="analysis-thumb">
                    <div class="analysis-content">
                        <div class="analysis-category">${typeLabel}</div>
                        <div class="analysis-description">${result.promptFragment}</div>
                    </div>
                </div>
            `;
        }

        // Build outfit description from analysis results
        function buildOutfitDescription() {
            const heroProducts = state.analysisResults.filter(r => r.source === 'hero' && r.imageType !== 'styling_reference');
            const accessories = state.analysisResults.filter(r => r.source === 'looks' && r.imageType !== 'styling_reference');
            const stylingRefs = state.analysisResults.filter(r => r.imageType === 'styling_reference');

            const parts = [];

            // Hero product - use FIRST one only (multiple images are just for reference angles)
            if (heroProducts.length > 0) {
                parts.push(`wearing ${heroProducts[0].promptFragment}`);
            }

            // Accessories - organized by category (use first of each type)
            const bagItems = accessories.filter(a => ['bag', 'handbag', 'tote', 'purse', 'clutch'].some(c => a.category.toLowerCase().includes(c)));
            const shoeItems = accessories.filter(a => ['shoes', 'boots', 'heels', 'sneakers', 'sandals', 'loafers'].some(c => a.category.toLowerCase().includes(c)));
            const eyewearItems = accessories.filter(a => ['sunglasses', 'glasses', 'eyewear'].some(c => a.category.toLowerCase().includes(c)));
            const otherAccessories = accessories.filter(a =>
                !bagItems.includes(a) && !shoeItems.includes(a) && !eyewearItems.includes(a)
            );

            if (bagItems.length > 0) {
                parts.push(`holding ${bagItems[0].promptFragment}`);
            }
            if (shoeItems.length > 0) {
                parts.push(`with ${shoeItems[0].promptFragment}`);
            }
            if (eyewearItems.length > 0) {
                parts.push(`wearing ${eyewearItems[0].promptFragment}`);
            }
            if (otherAccessories.length > 0) {
                parts.push(`accessorized with ${otherAccessories.map(o => o.promptFragment).join(', ')}`);
            }

            // Add user's custom styling notes
            const userNotes = document.getElementById('stylingNotes').value.trim();
            if (userNotes) {
                parts.push(userNotes);
            }

            return parts.join(', ');
        }

        // Get environment description from styling reference
        function getEnvironmentFromStylingRef() {
            const stylingRefs = state.analysisResults.filter(r => r.imageType === 'styling_reference');
            if (stylingRefs.length === 0) {
                return null;
            }
            const ref = stylingRefs[0];
            const envParts = [];
            if (ref.background) {
                envParts.push(ref.background);
            }
            if (ref.lighting) {
                envParts.push(ref.lighting);
            }
            return envParts.length > 0 ? envParts.join('. ') : null;
        }

        // Generate images
        elements.generateBtn.addEventListener('click', generateImages);

        async function generateImages() {
            console.log('🚀 [Generate] Starting generation...');
            const totalImages = Object.values(state.poseCounts).reduce((sum, count) => sum + count, 0);
            console.log('📊 [Generate] Total images to generate:', totalImages);
            console.log('📊 [Generate] Model image:', state.modelImage ? 'YES' : 'NO');
            console.log('📊 [Generate] Analysis results:', state.analysisResults.length);

            if (!state.modelImage || totalImages === 0 || state.analysisResults.length === 0) {
                console.warn('⚠️ [Generate] Blocked - missing requirements');
                return;
            }

            elements.errorDiv.classList.remove('show');
            state.results = [];
            elements.resultsGrid.innerHTML = '';

            // Build the combined outfit description (ONE for all poses)
            const outfitDescription = buildOutfitDescription();

            // Get environment from styling reference (if available)
            const environment = getEnvironmentFromStylingRef();

            // Build all generation tasks - based on pose counts
            const tasks = [];

            for (const [poseId, count] of Object.entries(state.poseCounts)) {
                if (count === 0) continue;

                const pose = POSES.find(p => p.id === poseId);
                const prompts = POSE_PROMPTS[poseId] || POSE_PROMPTS['pose-pdp-front'] || [];

                if (prompts.length === 0) {
                    console.warn(`No prompts found for pose: ${poseId}`);
                    continue;
                }

                // Create 'count' number of tasks for this pose
                for (let i = 0; i < count; i++) {
                    // Get a random prompt variation and inject the outfit
                    const promptTemplate = prompts[Math.floor(Math.random() * prompts.length)];
                    let prompt = promptTemplate.replace('[PRODUCT_DESCRIPTION]', outfitDescription);

                    // If we have environment from styling ref, append it to override default lighting
                    if (environment) {
                        prompt += ` Environment and lighting from reference: ${environment}`;
                    }

                    tasks.push({
                        poseId,
                        poseName: pose.name,
                        prompt,
                        imageIndex: i + 1
                    });
                }
            }

            const totalTasks = tasks.length;
            let completed = 0;

            console.log('📋 [Generate] Tasks created:', totalTasks);
            console.log('📋 [Generate] Tasks:', tasks.map(t => `${t.poseName} #${t.imageIndex}`));

            elements.progressSection.classList.add('visible');
            elements.progressCount.textContent = `0 / ${totalTasks}`;
            elements.progressBar.style.width = '0%';
            elements.generateBtn.disabled = true;

            // Collect product image URLs (hero products + accessories, NOT styling refs)
            const productImages = state.analysisResults
                .filter(r => r.imageType !== 'styling_reference')
                .map(r => r.image.url);

            console.log('🖼️ [Generate] Product images:', productImages.length);

            // Upload all images to fal.ai storage first (convert data URLs to hosted URLs)
            console.log('📤 [Generate] Uploading images to fal.ai storage...');
            elements.loadingText && (elements.loadingText.textContent = 'Uploading images...');

            const allDataUrls = [];
            allDataUrls.push(state.modelImage.url);
            if (state.modelImagePortrait) {
                allDataUrls.push(state.modelImagePortrait.url);
            }
            allDataUrls.push(...productImages);

            // Upload all images in parallel, but only if they're data URLs
            const uploadedUrls = await Promise.all(allDataUrls.map(async (url, idx) => {
                if (url.startsWith('data:')) {
                    console.log(`📤 [Upload ${idx + 1}/${allDataUrls.length}] Uploading data URL...`);
                    try {
                        const result = await api.uploadBase64(url);
                        console.log(`✅ [Upload ${idx + 1}] Got URL:`, result.url);
                        return result.url;
                    } catch (err) {
                        console.error(`❌ [Upload ${idx + 1}] Failed:`, err);
                        return null;
                    }
                } else {
                    // Already a hosted URL
                    console.log(`✅ [Upload ${idx + 1}] Already hosted:`, url.substring(0, 50));
                    return url;
                }
            }));

            // Filter out failed uploads
            const validUrls = uploadedUrls.filter(url => url !== null);
            console.log(`📦 [Generate] ${validUrls.length}/${allDataUrls.length} images uploaded successfully`);

            if (validUrls.length === 0) {
                showError('Failed to upload images');
                elements.generateBtn.disabled = false;
                elements.progressSection.classList.remove('visible');
                return;
            }

            // Execute all tasks
            await Promise.all(tasks.map(async (task, taskIndex) => {
                console.log(`🔄 [Task ${taskIndex + 1}/${totalTasks}] Starting: ${task.poseName}`);
                try {
                    // Use the uploaded URLs
                    const imageUrls = validUrls;

                    const params = {
                        prompt: task.prompt,
                        image_urls: imageUrls,
                        num_images: 1,
                        aspect_ratio: state.aspectRatio,
                        resolution: state.resolution,
                        output_format: 'png'
                    };

                    console.log(`📤 [Task ${taskIndex + 1}] Calling API with ${imageUrls.length} images`);
                    const data = await api.remixImage('nanobanana-edit', params);
                    console.log(`📥 [Task ${taskIndex + 1}] API Response:`, data);

                    if (data.images && data.images.length > 0) {
                        console.log(`✅ [Task ${taskIndex + 1}] Got ${data.images.length} images`);
                        data.images.forEach(img => {
                            state.results.push({
                                url: img.url,
                                prompt: task.prompt,
                                poseName: task.poseName,
                                poseId: task.poseId,
                                outfit: outfitDescription,
                                aspectRatio: state.aspectRatio
                            });
                        });
                        console.log(`🎨 [Task ${taskIndex + 1}] Total results now:`, state.results.length);
                        renderResults();
                    } else {
                        console.warn(`⚠️ [Task ${taskIndex + 1}] No images in response:`, data);
                    }
                } catch (error) {
                    console.error(`❌ [Task ${taskIndex + 1}] Generation error:`, error);
                }

                completed++;
                elements.progressCount.textContent = `${completed} / ${totalTasks}`;
                elements.progressBar.style.width = `${(completed / totalTasks) * 100}%`;
            }));

            console.log('🏁 [Generate] All tasks complete. Total results:', state.results.length);
            elements.progressSection.classList.remove('visible');
            elements.resultsSection.classList.add('visible');
            updateCalculator();
        }

        function renderResults() {
            // Convert aspect ratio to CSS aspect-ratio
            const getAspectCSS = (ar) => {
                if (ar === '3:4') return '3/4';
                if (ar === '4:3') return '4/3';
                if (ar === '1:1') return '1/1';
                return '3/4';
            };

            elements.resultsGrid.innerHTML = state.results.map((result, idx) => `
                <div class="result-card" onclick="openLightbox(${idx})" style="aspect-ratio: ${getAspectCSS(result.aspectRatio || '3:4')};">
                    <img src="${result.url}" alt="Result ${idx + 1}" class="result-image">
                    <span class="model-tag">${result.poseName}</span>
                </div>
            `).join('');
        }

        // Lightbox
        window.openLightbox = function(index) {
            state.lightboxIndex = index;
            updateLightboxContent();
            elements.lightbox.classList.add('visible');
            document.body.style.overflow = 'hidden';
        };

        function updateLightboxContent() {
            const result = state.results[state.lightboxIndex];
            const total = state.results.length;
            const current = state.lightboxIndex + 1;

            elements.lightboxImage.src = result.url;
            elements.lightboxPose.textContent = result.poseName;
            elements.lightboxPrompt.textContent = result.prompt;
            document.getElementById('lightbox-counter').textContent = `${current} / ${total}`;

            // Update nav button states (disable at boundaries)
            document.getElementById('lightbox-prev').disabled = state.lightboxIndex === 0;
            document.getElementById('lightbox-next').disabled = state.lightboxIndex === total - 1;
        }

        document.getElementById('lightbox-close').addEventListener('click', closeLightbox);
        elements.lightbox.addEventListener('click', (e) => { if (e.target === elements.lightbox) closeLightbox(); });

        document.getElementById('lightbox-prev').addEventListener('click', () => {
            if (state.lightboxIndex > 0) {
                state.lightboxIndex--;
                updateLightboxContent();
            }
        });

        document.getElementById('lightbox-next').addEventListener('click', () => {
            if (state.lightboxIndex < state.results.length - 1) {
                state.lightboxIndex++;
                updateLightboxContent();
            }
        });

        document.getElementById('lightbox-download').addEventListener('click', async () => {
            const result = state.results[state.lightboxIndex];
            downloadFile(result.url, `casting-${result.poseName}-${Date.now()}.png`);
        });

        document.addEventListener('keydown', (e) => {
            if (!elements.lightbox.classList.contains('visible')) return;
            if (e.key === 'Escape') closeLightbox();
            else if (e.key === 'ArrowLeft' && state.lightboxIndex > 0) {
                state.lightboxIndex--;
                updateLightboxContent();
            }
            else if (e.key === 'ArrowRight' && state.lightboxIndex < state.results.length - 1) {
                state.lightboxIndex++;
                updateLightboxContent();
            }
        });

        function closeLightbox() {
            elements.lightbox.classList.remove('visible');
            document.body.style.overflow = '';
        }

        function showError(message) {
            elements.errorDiv.textContent = message;
            elements.errorDiv.classList.add('show');
        }

        // Load default model images
        async function loadDefaultModels() {
            // Full body default
            const fullBodyUrl = '/shared/images/models/default-fullbody.jpg';
            const portraitUrl = '/shared/images/models/default-portrait.jpg';

            try {
                // Load full body
                const fullBodyImg = new Image();
                fullBodyImg.onload = () => {
                    state.modelImage = { url: fullBodyUrl, file: null };
                    elements.modelPreview.innerHTML = `<img src="${fullBodyUrl}" alt="Model Full Body">`;
                    elements.modelPreview.classList.add('has-image');
                    updateCalculator();
                };
                fullBodyImg.src = fullBodyUrl;

                // Load portrait
                const portraitImg = new Image();
                portraitImg.onload = () => {
                    state.modelImagePortrait = { url: portraitUrl, file: null };
                    elements.modelPreviewPortrait.innerHTML = `<img src="${portraitUrl}" alt="Model Portrait">`;
                    elements.modelPreviewPortrait.classList.add('has-image');
                    updateCalculator();
                };
                portraitImg.src = portraitUrl;
            } catch (e) {
                console.log('Default model images not found, using placeholders');
            }
        }

        // Initialize
        initializePoses();
        loadDefaultModels();
        updateCalculator();
    </script>
</body>
</html>
