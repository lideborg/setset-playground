<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ron Dorff E-Commerce - Fearless Summer SS26</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ˜Ž</text></svg>">
    <link rel="stylesheet" href="/shared/css/tokens.css">
    <link rel="stylesheet" href="/shared/css/base.css">
    <link rel="stylesheet" href="/shared/css/components.css">
    <script src="/shared/js/loader.js"></script>
    <script src="/shared/js/lightbox.js"></script>
    <style>
        .container {
            max-width: 1400px;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 0;
            margin-bottom: var(--space-md);
            border-bottom: 1px solid var(--jet);
        }

        .tab {
            padding: 8px 16px;
            font-size: var(--text-sm);
            font-weight: 500;
            color: var(--slate);
            background: none;
            border: none;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            margin-bottom: -1px;
        }

        .tab:hover {
            color: var(--jet);
        }

        .tab.active {
            color: var(--jet);
            border-bottom-color: var(--jet);
        }

        .tab-panel {
            display: none;
        }

        .tab-panel.active {
            display: block;
        }

        /* Header */
        .header-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--space-sm);
        }

        .header-row h1 {
            font-size: var(--text-lg);
            margin: 0;
        }

        .header-subtitle {
            font-size: var(--text-sm);
            color: var(--slate);
        }

        /* Stats bar */
        .stats-bar {
            display: flex;
            gap: var(--space-lg);
            margin-bottom: var(--space-md);
            padding: var(--space-sm) var(--space-md);
            background: var(--off-white);
            border: 1px solid var(--jet);
        }

        .stat-item {
            display: flex;
            align-items: baseline;
            gap: var(--space-2xs);
        }

        .stat-value {
            font-size: var(--text-lg);
            font-weight: 600;
        }

        .stat-label {
            font-size: var(--text-xs);
            color: var(--slate);
        }

        /* Category section - Overview */
        .category-section {
            margin-bottom: var(--space-lg);
        }

        .category-header {
            font-size: var(--text-2xs);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--slate);
            margin-bottom: var(--space-sm);
            padding-bottom: var(--space-2xs);
            border-bottom: 1px solid var(--jet);
        }

        /* Product card - Overview */
        .product-card {
            background: var(--white);
            border: 1px solid var(--jet);
            padding: var(--space-sm);
            margin-bottom: var(--space-sm);
        }

        .product-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: var(--space-xs);
        }

        .product-info {
            flex: 1;
        }

        .product-name {
            font-weight: 600;
            font-size: var(--text-sm);
            margin-bottom: 2px;
        }

        .product-sku {
            font-size: var(--text-2xs);
            font-family: monospace;
            color: var(--slate);
        }

        .product-meta {
            text-align: right;
        }

        .product-color {
            font-size: var(--text-xs);
            color: var(--slate);
        }

        .product-material {
            font-size: var(--text-2xs);
            color: var(--ash-grey);
        }

        /* Image grid - Overview */
        .image-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
            gap: 4px;
            margin-bottom: var(--space-xs);
        }

        .image-slot {
            position: relative;
        }

        .image-thumb {
            width: 100%;
            aspect-ratio: 1;
            object-fit: cover;
            border: 1px solid var(--jet);
            cursor: pointer;
            background: var(--white);
        }

        .image-thumb:hover {
            opacity: 0.8;
        }

        .image-label {
            font-size: 8px;
            text-transform: uppercase;
            color: var(--ash-grey);
            text-align: center;
            margin-top: 2px;
        }

        /* Requirements tags */
        .requirements-row {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .req-tag {
            font-size: 9px;
            padding: 2px 6px;
            background: var(--white);
            color: var(--slate);
            border: 1px solid var(--jet);
        }

        .req-tag.has {
            background: #d1fae5;
            color: #065f46;
            border-color: #065f46;
        }

        .req-tag.needed {
            background: #fef3c7;
            color: #92400e;
            border-color: #92400e;
        }

        .req-tag.video {
            background: #dbeafe;
            color: #1e40af;
            border-color: #1e40af;
        }

        /* ========== E-COMMERCE TAB STYLES ========== */

        /* Settings compact - matching batch-remix-gemini */
        .settings-compact {
            display: flex;
            gap: var(--space-sm);
            padding: var(--space-sm);
            background: var(--white);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-md);
            margin-bottom: var(--space-sm);
            align-items: center;
            flex-wrap: wrap;
        }

        .setting-item {
            display: flex;
            align-items: center;
            gap: var(--space-2xs);
        }

        .setting-item label {
            font-size: var(--text-xs);
            color: var(--slate);
        }

        .btn-group-compact {
            display: flex;
            gap: 2px;
        }

        .btn-group-compact button {
            padding: 4px 8px;
            font-size: var(--text-2xs);
            font-weight: 500;
            border: 1px solid var(--gainsboro);
            background: var(--white);
            color: var(--slate);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .btn-group-compact button:first-child {
            border-radius: var(--radius-xs) 0 0 var(--radius-xs);
        }

        .btn-group-compact button:last-child {
            border-radius: 0 var(--radius-xs) var(--radius-xs) 0;
        }

        .btn-group-compact button.active {
            background: var(--jet);
            border-color: var(--jet);
            color: var(--white);
        }

        /* View mode toggle */
        .view-mode-toggle {
            display: flex;
            gap: 0;
            margin-bottom: var(--space-sm);
        }
        .view-mode-toggle button {
            flex: 1;
            padding: 8px 16px;
            border: 1px solid var(--jet);
            background: var(--white);
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            margin-left: -1px;
            box-sizing: border-box;
        }
        .view-mode-toggle button:first-child {
            margin-left: 0;
        }
        .view-mode-toggle button.active {
            background: var(--jet);
            color: var(--white);
            position: relative;
            z-index: 1;
        }

        /* Pose selector */
        .pose-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            padding: var(--space-sm);
            background: var(--white);
            border: 1px solid var(--jet);
            margin-bottom: var(--space-sm);
        }
        .pose-tab {
            padding: 6px 12px;
            border: 1px solid var(--gainsboro);
            background: var(--white);
            cursor: pointer;
            font-size: 11px;
            text-transform: uppercase;
        }
        .pose-tab:hover {
            border-color: var(--jet);
        }
        .pose-tab.selected {
            background: var(--jet);
            color: var(--white);
            border-color: var(--jet);
        }
        .pose-tab .count {
            font-size: 9px;
            opacity: 0.7;
            margin-left: 4px;
        }

        /* Pose view product card */
        .pose-product-card {
            background: var(--white);
            border: 1px solid var(--gainsboro);
            margin-bottom: var(--space-sm);
        }
        .pose-product-card.selected {
            border-color: var(--jet);
        }
        .pose-product-header {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            padding: var(--space-sm);
            border-bottom: 1px solid var(--gainsboro);
            cursor: pointer;
        }
        .pose-product-header:hover {
            background: #f9f9f9;
        }
        .pose-product-thumb {
            width: 50px;
            height: 66px;
            object-fit: cover;
            border: 1px solid var(--gainsboro);
        }
        .pose-product-info {
            flex: 1;
            min-width: 0;
        }
        .pose-product-name {
            font-weight: 500;
            font-size: 12px;
        }
        .pose-product-sku {
            font-size: 10px;
            color: #666;
        }
        .pose-product-images {
            padding: var(--space-sm);
            display: none;
        }
        .pose-product-card.expanded .pose-product-images {
            display: block;
        }
        .pose-product-images-row {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }
        .pose-image-option {
            width: 60px;
            height: 80px;
            border: 2px solid var(--gainsboro);
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }
        .pose-image-option:hover {
            border-color: var(--jet);
        }
        .pose-image-option.selected {
            border-color: var(--jet);
            background: var(--jet);
        }
        .pose-image-option.selected .check {
            display: flex;
        }
        .pose-image-option img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .pose-image-option .check {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 16px;
            height: 16px;
            background: var(--jet);
            color: white;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 10px;
        }
        .pose-product-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .pose-product-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .pose-product-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        /* Product selector */
        .product-selector {
            display: grid;
            grid-template-columns: repeat(14, 1fr);
            gap: 4px;
            padding: var(--space-sm);
            background: var(--white);
            border: 1px solid var(--jet);
            margin-bottom: var(--space-sm);
        }

        .product-thumb {
            cursor: pointer;
            border: 1px solid var(--gainsboro);
            overflow: hidden;
        }

        .product-thumb:hover {
            border-color: var(--jet);
        }

        .product-thumb.selected {
            border: 1px solid var(--jet);
            outline: 1px solid var(--jet);
            outline-offset: -2px;
        }

        .product-thumb img {
            width: 100%;
            aspect-ratio: 3/4;
            object-fit: cover;
            display: block;
        }

        .product-thumb-label {
            font-size: 7px;
            text-align: center;
            padding: 2px;
            background: var(--white);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Selected product header */
        .selected-product-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-sm);
            background: var(--jet);
            color: var(--white);
            margin-bottom: var(--space-sm);
        }

        .selected-product-title {
            font-weight: 600;
            font-size: var(--text-sm);
        }

        .selected-product-sku {
            font-size: var(--text-2xs);
            opacity: 0.7;
        }

        .header-actions {
            display: flex;
            gap: var(--space-xs);
        }

        .header-btn {
            padding: 4px 10px;
            font-size: var(--text-2xs);
            background: var(--white);
            color: var(--jet);
            border: none;
            cursor: pointer;
        }

        .header-btn:disabled {
            opacity: 0.5;
        }

        .header-btn.analyzing {
            background: var(--off-white);
        }

        /* Image selection rows - for input/guide selection */
        .image-selection-section {
            margin-bottom: var(--space-md);
        }

        .image-selection-label {
            font-size: var(--text-xs);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--slate);
            margin-bottom: var(--space-xs);
        }

        .image-selection-row {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: var(--space-xs);
        }

        .selection-image {
            position: relative;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all var(--transition-fast);
            opacity: 0.7;
        }

        .selection-image:hover {
            opacity: 0.9;
        }

        .selection-image.selected {
            opacity: 1;
            border-color: var(--jet);
            box-shadow: 0 0 0 2px var(--jet);
        }

        .selection-image img {
            width: 100%;
            aspect-ratio: 3/4;
            object-fit: cover;
            display: block;
        }

        .selection-image-label {
            font-size: var(--text-2xs);
            text-align: center;
            padding: 2px;
            background: var(--white);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .generate-section {
            display: flex;
            gap: var(--space-sm);
            align-items: center;
            padding: var(--space-sm);
            background: var(--off-white);
            border: 1px solid var(--gainsboro);
            margin-top: var(--space-md);
        }

        .generate-section .btn--primary {
            flex-shrink: 0;
        }

        .selection-summary {
            font-size: var(--text-xs);
            color: var(--slate);
        }

        /* Category rows - 2 per row */
        .category-rows {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: var(--space-sm);
        }

        @media (max-width: 900px) {
            .category-rows {
                grid-template-columns: 1fr;
            }
        }

        .category-row {
            background: var(--white);
            border: 1px solid var(--jet);
            padding: var(--space-sm);
        }

        .category-row-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-xs);
            padding-bottom: var(--space-2xs);
            border-bottom: 1px solid var(--gainsboro);
        }

        .category-row-title {
            font-size: var(--text-sm);
            font-weight: 600;
            text-transform: capitalize;
        }

        .category-row-actions {
            display: flex;
            gap: 4px;
            align-items: center;
        }

        .select-btn {
            padding: 2px 6px;
            font-size: 9px;
            background: var(--white);
            border: 1px solid var(--gainsboro);
            cursor: pointer;
        }

        .select-btn:hover {
            border-color: var(--jet);
        }

        .pose-mode-toggle {
            display: flex;
            gap: 0;
            margin-right: 8px;
        }

        .pose-mode-btn {
            padding: 2px 8px;
            font-size: 9px;
            background: var(--white);
            border: 1px solid var(--gainsboro);
            cursor: pointer;
            color: var(--slate);
        }

        .pose-mode-btn:first-child {
            border-radius: 3px 0 0 3px;
        }

        .pose-mode-btn:last-child {
            border-radius: 0 3px 3px 0;
            border-left: none;
        }

        .pose-mode-btn:hover {
            border-color: var(--jet);
        }

        .pose-mode-btn.active {
            background: var(--jet);
            color: var(--white);
            border-color: var(--jet);
        }

        .category-row-status {
            font-size: var(--text-2xs);
            color: var(--slate);
        }

        /* Guide and inputs section */
        .inputs-guides-section {
            margin-bottom: var(--space-xs);
        }

        .section-label {
            font-size: 9px;
            color: var(--ash-grey);
            text-transform: uppercase;
            margin-bottom: 4px;
            font-weight: 500;
        }

        /* Input images - 9 per row */
        .images-row {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 6px;
            margin-bottom: var(--space-sm);
        }

        /* Guide images - larger, 6 per row */
        .guides-row {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
            margin-bottom: var(--space-sm);
        }

        .image-option {
            aspect-ratio: 3/4;
            border: 1px solid var(--gainsboro);
            cursor: pointer;
            overflow: hidden;
            opacity: 0.5;
            transition: all var(--transition-fast);
        }

        .image-option:hover {
            opacity: 0.8;
            border-color: var(--jet);
        }

        .image-option.selected {
            opacity: 1;
            border-color: var(--jet);
        }

        .image-option img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .image-option .check {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 14px;
            height: 14px;
            background: var(--jet);
            color: var(--white);
            font-size: 9px;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .image-option.selected .check {
            display: flex;
        }

        /* Guide images need background to be visible */
        .guide-image-option {
            background: #f5f5f5;
            border: 1px solid #ddd;
        }

        .guide-image-option.selected {
            background: white;
            border-color: var(--jet);
        }

        /* Legacy guide slot styles */
        .guide-slot {
            flex-shrink: 0;
            width: 60px;
        }

        .guide-slot-label {
            font-size: 8px;
            color: var(--ash-grey);
            text-transform: uppercase;
            margin-bottom: 2px;
        }

        .guide-slot-box {
            width: 60px;
            aspect-ratio: 3/4;
            border: 1px dashed var(--gainsboro);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            color: var(--ash-grey);
            background: var(--off-white);
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .guide-slot-box:hover {
            border-color: var(--jet);
        }

        .guide-slot-box.filled {
            border-style: solid;
            border-color: var(--jet);
        }

        .guide-slot-box img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* Input images */
        .input-images {
            flex: 1;
        }

        .input-images-label {
            font-size: 8px;
            color: var(--ash-grey);
            text-transform: uppercase;
            margin-bottom: 2px;
        }

        .input-images-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
            gap: 3px;
        }

        .input-image-slot {
            aspect-ratio: 3/4;
            border: 1px solid var(--gainsboro);
            overflow: hidden;
            cursor: pointer;
            position: relative;
            opacity: 0.4;
        }

        .input-image-slot:hover {
            opacity: 0.7;
        }

        .input-image-slot.selected {
            border: 1px solid var(--jet);
            outline: 1px solid var(--jet);
            outline-offset: -2px;
            opacity: 1;
        }

        .input-image-slot img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .input-image-slot .check {
            position: absolute;
            top: 1px;
            right: 1px;
            width: 12px;
            height: 12px;
            background: var(--jet);
            color: var(--white);
            font-size: 8px;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .input-image-slot.selected .check {
            display: flex;
        }

        .input-image-slot .model-badge {
            position: absolute;
            bottom: 1px;
            left: 1px;
            width: 12px;
            height: 12px;
            background: #3b82f6;
            color: var(--white);
            font-size: 7px;
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Generate button for category */
        .category-generate-btn {
            width: 100%;
            padding: 6px;
            font-size: var(--text-2xs);
            font-weight: 500;
            background: var(--jet);
            color: var(--white);
            border: none;
            cursor: pointer;
        }

        .category-generate-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .category-generate-btn:hover:not(:disabled) {
            background: var(--slate);
        }

        /* Results area */
        .category-results {
            margin-top: var(--space-xs);
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 4px;
        }

        .category-result {
            aspect-ratio: 3/4;
            overflow: hidden;
            cursor: pointer;
            border: 1px solid var(--jet);
        }

        .category-result img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* Lightbox */
        /* Lightbox styles handled by shared/js/lightbox.js */

        /* No product selected state */
        .no-product-selected {
            text-align: center;
            padding: var(--space-xl);
            color: var(--slate);
            border: 1px dashed var(--gainsboro);
        }

        /* Analysis status */
        .analysis-status {
            font-size: var(--text-2xs);
            color: var(--slate);
            padding: 4px 8px;
            background: var(--off-white);
            border: 1px solid var(--gainsboro);
        }

        .analysis-status.complete {
            background: #d1fae5;
            border-color: #065f46;
            color: #065f46;
        }

        /* Results Tab Styles */
        .results-product {
            background: var(--white);
            border: 1px solid var(--jet);
            padding: var(--space-sm);
            margin-bottom: var(--space-md);
        }

        .results-product.no-results {
            opacity: 0.5;
        }

        .results-product-header {
            display: flex;
            align-items: baseline;
            gap: var(--space-sm);
            margin-bottom: var(--space-sm);
            padding-bottom: var(--space-xs);
            border-bottom: 1px solid var(--off-white);
        }

        .results-product-name {
            font-weight: 600;
            font-size: var(--text-sm);
        }

        .results-product-sku {
            font-size: var(--text-2xs);
            font-family: monospace;
            color: var(--slate);
        }

        .results-product-color {
            font-size: var(--text-xs);
            color: var(--slate);
        }

        .results-video-badge {
            margin-left: auto;
            font-size: var(--text-2xs);
            font-weight: 600;
            padding: 2px 8px;
            border-radius: 4px;
            background: var(--blue);
            color: white;
        }

        .results-video-badge.no-video {
            background: transparent;
            color: var(--slate);
            opacity: 0.3;
        }

        .results-shots {
            display: flex;
            flex-direction: column;
            gap: var(--space-sm);
        }

        .results-shot-group {
            display: flex;
            gap: var(--space-sm);
            align-items: flex-start;
        }

        .results-shot-group.missing {
            opacity: 0.4;
        }

        .results-shot-label {
            min-width: 80px;
            font-size: var(--text-xs);
            font-weight: 500;
            text-transform: uppercase;
            color: var(--slate);
            padding-top: 4px;
            display: flex;
            align-items: center;
            gap: var(--space-xs);
        }

        .results-shot-count {
            font-size: var(--text-2xs);
            color: var(--ash-grey);
            font-weight: normal;
        }

        .results-shot-images {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            flex: 1;
        }

        .results-thumb {
            position: relative;
            cursor: pointer;
            border: 1px solid var(--jet);
            background: var(--off-white);
            width: 168px;
        }

        .results-thumb:hover {
            border-color: var(--black);
        }

        .results-thumb img {
            width: 168px;
            height: 224px;
            object-fit: cover;
            display: block;
        }

        .results-thumb-info {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(0,0,0,0.7);
            padding: 2px 4px;
        }

        .results-thumb-filename {
            color: white;
            font-size: 8px;
            font-family: monospace;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
        }

        .results-thumb-dl {
            background: white;
            color: black;
            border: 1px solid #333;
            padding: 3px 8px;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            margin-left: 6px;
            flex-shrink: 0;
            border-radius: 2px;
        }

        .results-thumb-dl:hover {
            background: #ddd;
        }

        .results-missing-placeholder {
            width: 80px;
            height: 80px;
            background: var(--off-white);
            border: 2px dashed var(--gainsboro);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 10px;
            color: var(--ash-grey);
            padding: 8px;
            line-height: 1.2;
        }

        /* Copy Tab Styles */
        .copy-section {
            padding: var(--space-sm) 0;
        }

        .copy-header {
            margin-bottom: var(--space-md);
        }

        .copy-header h3 {
            font-size: var(--text-md);
            margin: 0 0 var(--space-2xs);
        }

        .copy-header p {
            font-size: var(--text-sm);
            color: var(--slate);
            margin: 0;
        }

        .copy-grid-section {
            margin-bottom: var(--space-md);
        }

        .copy-grid-label {
            font-size: var(--text-xs);
            font-weight: 600;
            text-transform: uppercase;
            color: var(--slate);
            margin-bottom: var(--space-xs);
        }

        .copy-upload-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: var(--space-xs);
            min-height: 120px;
            border: 1px dashed var(--gainsboro);
            padding: var(--space-sm);
        }

        .copy-upload-grid.drag-over {
            border-color: var(--jet);
            background: var(--off-white);
        }

        .copy-slot {
            aspect-ratio: 3/4;
            border: 1px solid var(--gainsboro);
            background: var(--white);
            position: relative;
            cursor: pointer;
        }

        .copy-slot.filled {
            border-color: var(--jet);
        }

        .copy-slot.selected {
            outline: 2px solid var(--jet);
            outline-offset: 2px;
        }

        .copy-slot img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .copy-slot .remove-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 18px;
            height: 18px;
            background: var(--jet);
            color: var(--white);
            border: none;
            border-radius: 50%;
            font-size: 12px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .copy-slot.filled:hover .remove-btn {
            display: flex;
        }

        .copy-slot.empty {
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--gainsboro);
            font-size: 24px;
        }

        .copy-actions {
            display: flex;
            gap: var(--space-sm);
            margin-bottom: var(--space-md);
        }

        .copy-analysis-box {
            background: var(--off-white);
            border: 1px solid var(--gainsboro);
            padding: var(--space-sm);
            margin-top: var(--space-sm);
            font-size: var(--text-xs);
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 150px;
            overflow-y: auto;
            display: none;
        }

        .copy-analysis-box.visible {
            display: block;
        }

        .copy-prompt-preview {
            background: var(--white);
            border: 1px solid var(--jet);
            padding: var(--space-sm);
            margin-top: var(--space-md);
            font-size: var(--text-xs);
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }

        .copy-prompt-preview.visible {
            display: block;
        }

        .copy-prompt-preview h4 {
            margin: 0 0 var(--space-xs);
            font-size: var(--text-sm);
        }

        .copy-results {
            margin-top: var(--space-md);
        }

        /* Video Tab Styles */
        .video-section {
            padding: var(--space-sm) 0;
        }

        .video-header {
            margin-bottom: var(--space-md);
        }

        .video-header h3 {
            font-size: var(--text-md);
            margin: 0 0 var(--space-2xs);
        }

        .video-header p {
            font-size: var(--text-sm);
            color: var(--slate);
            margin: 0;
        }

        /* Video products grid - 2-3 per row */
        #video-products-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: var(--space-md);
        }

        .video-product-card {
            background: var(--off-white);
            border: 1px solid var(--gainsboro);
            padding: var(--space-sm);
        }

        .video-product-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-xs);
        }

        .video-product-title {
            font-size: var(--text-xs);
            font-weight: 600;
        }

        .video-product-sku {
            font-size: 10px;
            color: var(--slate);
        }

        /* Combined upload drop zone */
        .video-upload-zone {
            border: 2px dashed var(--gainsboro);
            background: var(--white);
            padding: var(--space-xs);
            cursor: pointer;
            transition: all 0.2s ease;
            margin-bottom: var(--space-xs);
        }

        .video-upload-zone:hover {
            border-color: var(--slate);
        }

        .video-upload-zone.drag-over {
            border-color: var(--jet);
            background: var(--off-white);
        }

        .video-upload-zone-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: var(--space-sm);
            color: var(--slate);
            font-size: var(--text-xs);
        }

        .video-upload-zone-empty .slot-icon {
            font-size: 24px;
            color: var(--gainsboro);
            margin-bottom: 4px;
        }

        .video-upload-zone-grid {
            display: flex;
            gap: var(--space-xs);
        }

        .video-upload-slot {
            width: 80px;
            height: 100px;
            position: relative;
            flex-shrink: 0;
        }

        .video-upload-slot img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border: 1px solid var(--gainsboro);
        }

        .video-upload-slot .slot-label {
            font-size: 9px;
            color: var(--slate);
            text-align: center;
            margin-top: 2px;
        }

        .video-upload-slot .remove-btn {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 16px;
            height: 16px;
            background: var(--jet);
            color: var(--white);
            border: none;
            border-radius: 50%;
            font-size: 10px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .video-upload-slot:hover .remove-btn {
            display: flex;
        }

        .video-back-images {
            margin-top: var(--space-sm);
        }

        .video-back-images-label {
            font-size: var(--text-xs);
            font-weight: 600;
            text-transform: uppercase;
            color: var(--slate);
            margin-bottom: var(--space-xs);
        }

        .video-back-images-grid {
            display: flex;
            gap: var(--space-xs);
            flex-wrap: wrap;
        }

        .video-back-thumb {
            width: 60px;
            height: 80px;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .video-back-thumb:hover {
            border-color: var(--slate);
        }

        .video-back-thumb.selected {
            border-color: var(--jet);
        }

        .video-back-thumb img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .video-product-note {
            width: 100%;
            padding: 6px 8px;
            font-size: 11px;
            border: 1px dashed var(--gainsboro);
            background: #fffef5;
            font-family: inherit;
            margin-top: var(--space-sm);
        }

        .video-product-note:focus {
            outline: none;
            border-color: var(--jet);
            border-style: solid;
        }

        .video-product-note::placeholder {
            color: #999;
            font-style: italic;
        }

        .video-pose-toggle {
            display: flex;
            gap: 2px;
            margin-top: var(--space-sm);
        }

        .video-pose-btn {
            padding: 6px 12px;
            font-size: var(--text-xs);
            border: 1px solid var(--gainsboro);
            background: var(--white);
            cursor: pointer;
        }

        .video-pose-btn.active {
            background: var(--jet);
            color: var(--white);
            border-color: var(--jet);
        }

        .video-generate-btn {
            margin-top: var(--space-sm);
            padding: 8px 16px;
            font-size: var(--text-sm);
            background: var(--jet);
            color: var(--white);
            border: none;
            cursor: pointer;
        }

        .video-generate-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .video-results {
            margin-top: var(--space-md);
        }

        .video-results-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: var(--space-sm);
        }

        .video-result-item {
            position: relative;
        }

        .video-result-item img {
            width: 100%;
            cursor: pointer;
        }

        /* Video Output Tab Styles */
        .video-output-section {
            padding: var(--space-sm) 0;
        }

        .video-output-header {
            margin-bottom: var(--space-md);
        }

        .video-output-header h3 {
            font-size: var(--text-md);
            margin: 0 0 var(--space-2xs);
        }

        .video-output-header p {
            font-size: var(--text-sm);
            color: var(--slate);
            margin: 0;
        }

        /* Duration slider - styled to match btn-group-compact */
        .vo-duration-slider-group {
            display: flex;
            align-items: center;
            gap: 6px;
            background: var(--off-white);
            border: 1px solid var(--gainsboro);
            padding: 4px 10px;
            border-radius: 2px;
        }
        .vo-duration-slider {
            width: 80px;
            height: 4px;
            cursor: pointer;
            -webkit-appearance: none;
            appearance: none;
            background: var(--gainsboro);
            border-radius: 2px;
        }
        .vo-duration-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: var(--jet);
            border-radius: 50%;
            cursor: pointer;
        }
        .vo-duration-value {
            font-size: var(--text-xs);
            color: var(--jet);
            min-width: 20px;
            font-weight: 500;
        }

        /* Pair selection checkbox */
        .vo-pair-checkbox {
            position: absolute;
            top: 6px;
            left: 6px;
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: var(--jet);
        }
        .vo-pair-card {
            position: relative;
        }
        .vo-pair-card.deselected {
            opacity: 0.4;
        }
        .vo-pair-card.deselected .vo-pair-images {
            filter: grayscale(0.5);
        }

        .vo-drop-zone {
            border: 2px dashed var(--gainsboro);
            background: var(--white);
            padding: var(--space-lg);
            cursor: pointer;
            transition: all 0.2s ease;
            margin-bottom: var(--space-md);
            text-align: center;
        }

        .vo-drop-zone:hover {
            border-color: var(--slate);
        }

        .vo-drop-zone.drag-over {
            border-color: var(--jet);
            background: var(--off-white);
        }

        .vo-drop-zone-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--space-xs);
            color: var(--slate);
        }

        .vo-drop-icon {
            font-size: 32px;
        }

        .vo-drop-hint {
            font-size: var(--text-xs);
            opacity: 0.7;
        }

        /* Pairs grid - 5 columns */
        .vo-pairs-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: var(--space-md);
        }

        .vo-pair-card {
            background: var(--off-white);
            border: 1px solid var(--gainsboro);
            padding: var(--space-sm);
            display: flex;
            flex-direction: column;
            gap: var(--space-xs);
        }

        .vo-pair-card.selected {
            border-color: var(--jet);
        }

        .vo-pair-images {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .vo-pair-image {
            position: relative;
            aspect-ratio: 3/4;
            overflow: hidden;
        }

        .vo-pair-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .vo-pair-image .vo-image-label {
            position: absolute;
            bottom: 4px;
            left: 4px;
            background: rgba(0,0,0,0.7);
            color: white;
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 2px;
        }

        .vo-pair-name {
            font-size: 10px;
            color: var(--slate);
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
        }

        .vo-pair-note {
            width: 100%;
            padding: 4px 6px;
            font-size: 10px;
            border: 1px dashed var(--gainsboro);
            background: #fffef5;
            font-family: inherit;
        }

        .vo-pair-note:focus {
            outline: none;
            border-color: var(--jet);
            border-style: solid;
        }

        .vo-pair-note::placeholder {
            color: #999;
            font-style: italic;
        }

        .vo-pair-prompt {
            width: 100%;
            min-height: 60px;
            padding: var(--space-xs);
            font-size: 10px;
            border: 1px solid var(--gainsboro);
            resize: vertical;
            font-family: inherit;
        }

        .vo-pair-prompt:focus {
            outline: none;
            border-color: var(--jet);
        }

        .vo-pair-status {
            font-size: 10px;
            color: var(--slate);
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .vo-pair-status.analyzing {
            color: #2196F3;
        }

        .vo-pair-status.ready {
            color: #4CAF50;
        }

        .vo-pair-status.generating {
            color: #FF9800;
        }

        .vo-pair-status.done {
            color: #4CAF50;
        }

        .vo-results {
            margin-top: var(--space-md);
        }

        .vo-results-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: var(--space-sm);
        }

        .vo-result-item {
            position: relative;
        }

        .vo-result-item video {
            width: 100%;
            cursor: pointer;
        }

        /* Canny Tab Styles */
        .canny-section {
            padding: var(--space-sm) 0;
        }

        .canny-header {
            margin-bottom: var(--space-md);
        }

        .canny-header h3 {
            font-size: var(--text-md);
            margin: 0 0 var(--space-2xs);
        }

        .canny-header p {
            font-size: var(--text-sm);
            color: var(--slate);
            margin: 0;
        }

        .canny-upload-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: var(--space-xs);
            margin-bottom: var(--space-md);
            min-height: 200px;
            border: 1px dashed var(--gainsboro);
            padding: var(--space-sm);
        }

        .canny-upload-grid.drag-over {
            border-color: var(--jet);
            background: var(--off-white);
        }

        .canny-slot {
            aspect-ratio: 3/4;
            border: 1px solid var(--gainsboro);
            background: var(--white);
            position: relative;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .canny-slot:hover {
            border-color: var(--jet);
        }

        .canny-slot.filled {
            border-color: var(--jet);
        }

        .canny-slot img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .canny-slot .remove-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 20px;
            height: 20px;
            background: var(--jet);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 12px;
            line-height: 1;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .canny-slot.filled:hover .remove-btn {
            opacity: 1;
        }

        .canny-slot .slot-label {
            position: absolute;
            bottom: 4px;
            left: 4px;
            right: 4px;
            font-size: var(--text-2xs);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 2px 4px;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .canny-slot.filled:not(.selected) {
            opacity: 0.4;
        }

        .canny-slot.filled:not(.selected) img {
            filter: grayscale(100%);
        }

        .canny-slot.selected {
            border-color: var(--jet);
            box-shadow: inset 0 0 0 2px var(--jet);
        }

        .canny-slot.processing::after {
            content: '';
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.5);
        }

        .canny-slot.processing::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 24px;
            height: 24px;
            border: 2px solid white;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            z-index: 1;
        }

        @keyframes spin {
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }

        .canny-actions {
            display: flex;
            gap: var(--space-sm);
            margin-bottom: var(--space-md);
        }

        .canny-results {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: var(--space-sm);
        }

        .canny-result {
            border: 1px solid var(--jet);
            background: white;
        }

        .canny-result img {
            width: 100%;
            display: block;
        }

        .canny-result-info {
            padding: var(--space-xs);
            font-size: var(--text-2xs);
            color: var(--slate);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .canny-result-actions {
            display: flex;
            gap: 4px;
        }

        .canny-result-actions button {
            padding: 2px 6px;
            font-size: var(--text-2xs);
        }

        /* Inline Loader */
        .inline-loader {
            display: none;
            text-align: center;
            padding: var(--space-lg);
            margin-bottom: var(--space-md);
        }

        .inline-loader.visible {
            display: block;
        }

        .loader-message {
            font-size: var(--text-md);
            color: #3b82f6;
            font-weight: 500;
            margin-bottom: var(--space-xs);
            transition: opacity 0.25s ease;
        }

        .loader-message.fade-out {
            opacity: 0;
        }

        .loader-message.fade-in {
            opacity: 1;
        }

        .loader-progress {
            font-size: var(--text-sm);
            color: var(--slate);
        }

        /* Global Results Section */
        .global-results-section {
            margin-top: var(--space-lg);
            padding-top: var(--space-md);
            border-top: 2px solid var(--jet);
            display: none;
        }

        .global-results-section.has-results {
            display: block;
        }

        .global-results-header {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            margin-bottom: var(--space-sm);
        }

        .global-results-title {
            font-size: var(--text-md);
            font-weight: 600;
        }

        .global-results-count {
            font-size: var(--text-sm);
            color: var(--slate);
        }

        .global-results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: var(--space-sm);
        }

        .global-result-item {
            border: 1px solid var(--jet);
            background: white;
            cursor: pointer;
        }

        .global-result-item img {
            width: 100%;
            aspect-ratio: 3/4;
            object-fit: cover;
            display: block;
            cursor: pointer;
        }

        .global-result-info {
            padding: 6px 8px;
            font-size: var(--text-2xs);
            border-top: 1px solid var(--gainsboro);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .global-result-label {
            font-weight: 500;
            color: var(--jet);
        }

        .global-result-meta {
            color: var(--slate);
        }

        .global-result-actions {
            display: flex;
            gap: 4px;
        }

        .global-result-actions button {
            padding: 2px 6px;
            font-size: 9px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header-row">
            <div>
                <h1>Ron Dorff E-Commerce</h1>
                <div class="header-subtitle">Fearless Summer SS26</div>
            </div>
        </div>

        <!-- Tabs -->
        <div class="tabs">
            <button class="tab active" data-tab="ecommerce">E-Commerce</button>
            <button class="tab" data-tab="copy">Copy</button>
            <button class="tab" data-tab="video">Video Input</button>
            <button class="tab" data-tab="video-output">Video Output</button>
            <button class="tab" data-tab="canny">Canny</button>
            <button class="tab" data-tab="overview">Overview</button>
            <button class="tab" data-tab="results">Results</button>
            <button class="tab" data-tab="finals">Finals</button>
            <button class="tab" data-tab="prompts">Prompts</button>
        </div>

        <!-- E-Commerce Tab -->
        <div class="tab-panel active" id="tab-ecommerce">
            <!-- View Mode Toggle -->
            <div class="view-mode-toggle">
                <button onclick="setViewMode('products')">Products V1</button>
                <button onclick="setViewMode('productsV2')">Products V2</button>
                <button class="active" onclick="setViewMode('productsV3')">Products V3</button>
                <button onclick="setViewMode('poses')">Poses</button>
            </div>

            <!-- Product View V1 (legacy) -->
            <div id="product-view" style="display: none;">
                <div class="product-selector" id="product-selector"></div>
            </div>

            <!-- Product View V2 (new - same layout as Poses) -->
            <div id="product-v2-view" style="display: none;">
                <div class="pose-selector" id="product-v2-selector"></div>
                <div id="product-v2-area"></div>
            </div>

            <!-- Product View V3 (with settings at top) -->
            <div id="product-v3-view">
                <!-- V3 Loader -->
                <div class="inline-loader" id="v3-loader">
                    <div class="loader-message" id="v3-loader-message">Generating...</div>
                    <div class="loader-progress" id="v3-loader-progress">0 / 0</div>
                </div>

                <!-- V3 Settings Bar - at top -->
                <div class="settings-compact" id="v3-settings-bar">
                    <div class="setting-item">
                        <label>Provider:</label>
                        <div class="btn-group-compact" id="v3-provider-buttons">
                            <button class="active" data-value="nano-pro">Nano Pro</button>
                            <button data-value="nano-pro-flash">Nano Pro Flash</button>
                            <button data-value="fal">FAL</button>
                        </div>
                    </div>
                    <div class="setting-item">
                        <label>Ratio:</label>
                        <div class="btn-group-compact" id="v3-aspect-buttons">
                            <button data-value="9:16">9:16</button>
                            <button data-value="2:3">2:3</button>
                            <button class="active" data-value="3:4">3:4</button>
                            <button data-value="4:5">4:5</button>
                            <button data-value="1:1">1:1</button>
                            <button data-value="4:3">4:3</button>
                        </div>
                    </div>
                    <div class="setting-item">
                        <label>Res:</label>
                        <div class="btn-group-compact" id="v3-resolution-buttons">
                            <button data-value="512">512px</button>
                            <button data-value="1K">1K</button>
                            <button class="active" data-value="2K">2K</button>
                            <button data-value="4K">4K</button>
                        </div>
                    </div>
                    <div class="setting-item">
                        <label>Seeds:</label>
                        <div class="btn-group-compact" id="v3-seeds-buttons">
                            <button class="active" data-value="1">1</button>
                            <button data-value="2">2</button>
                            <button data-value="3">3</button>
                            <button data-value="4">4</button>
                        </div>
                    </div>
                </div>
                <div class="pose-selector" id="product-v3-selector"></div>
                <div id="product-v3-area"></div>
            </div>

            <!-- Pose View (hidden by default) -->
            <div id="pose-view" style="display: none;">
                <div class="pose-selector" id="pose-selector"></div>
                <div id="pose-products-area"></div>
            </div>

            <!-- Settings Bar - matching batch-remix-gemini (for V1/V2 only) -->
            <div class="settings-compact" id="v1v2-settings-bar">
                <div class="setting-item">
                    <label>Provider:</label>
                    <div class="btn-group-compact" id="provider-buttons">
                        <button class="active" data-value="gemini">Gemini</button>
                        <button data-value="fal">FAL</button>
                    </div>
                </div>
                <div class="setting-item">
                    <label>Ratio:</label>
                    <div class="btn-group-compact" id="aspect-buttons">
                        <button data-value="9:16">9:16</button>
                        <button data-value="2:3">2:3</button>
                        <button class="active" data-value="3:4">3:4</button>
                        <button data-value="4:5">4:5</button>
                        <button data-value="1:1">1:1</button>
                        <button data-value="4:3">4:3</button>
                    </div>
                </div>
                <div class="setting-item">
                    <label>Res:</label>
                    <div class="btn-group-compact" id="resolution-buttons">
                        <button data-value="1K">1K</button>
                        <button class="active" data-value="2K">2K</button>
                        <button data-value="4K">4K</button>
                    </div>
                </div>
                <div class="setting-item">
                    <label>Seeds:</label>
                    <div class="btn-group-compact" id="seeds-buttons">
                        <button class="active" data-value="1">1</button>
                        <button data-value="2">2</button>
                        <button data-value="3">3</button>
                        <button data-value="4">4</button>
                    </div>
                </div>
            </div>

            <!-- Selected Product Area -->
            <div id="selected-product-area">
                <div class="no-product-selected">
                    Select a product above to start generating
                </div>
            </div>
        </div>

        <!-- Copy Tab -->
        <div class="tab-panel" id="tab-copy">
            <!-- Product Selector -->
            <div class="product-selector" id="copy-product-selector"></div>

            <!-- Settings Bar -->
            <div class="settings-compact">
                <div class="setting-item">
                    <label>Provider:</label>
                    <div class="btn-group-compact" id="copy-provider-buttons">
                        <button class="active" data-value="gemini">Gemini</button>
                        <button data-value="fal">FAL</button>
                    </div>
                </div>
                <div class="setting-item">
                    <label>Ratio:</label>
                    <div class="btn-group-compact" id="copy-aspect-buttons">
                        <button data-value="9:16">9:16</button>
                        <button data-value="2:3">2:3</button>
                        <button class="active" data-value="3:4">3:4</button>
                        <button data-value="4:5">4:5</button>
                        <button data-value="1:1">1:1</button>
                        <button data-value="4:3">4:3</button>
                    </div>
                </div>
                <div class="setting-item">
                    <label>Res:</label>
                    <div class="btn-group-compact" id="copy-resolution-buttons">
                        <button data-value="1K">1K</button>
                        <button class="active" data-value="2K">2K</button>
                        <button data-value="4K">4K</button>
                    </div>
                </div>
                <div class="setting-item">
                    <label>Seeds:</label>
                    <div class="btn-group-compact" id="copy-seeds-buttons">
                        <button class="active" data-value="1">1</button>
                        <button data-value="2">2</button>
                        <button data-value="3">3</button>
                        <button data-value="4">4</button>
                    </div>
                </div>
            </div>

            <!-- Selected Product Area -->
            <div id="copy-selected-product-area">
                <div class="no-product-selected">
                    Select a product above to start generating
                </div>
            </div>

            <!-- Inline Loader -->
            <div class="inline-loader" id="copy-loader">
                <div class="loader-message" id="copy-loader-message">Analyzing...</div>
                <div class="loader-progress" id="copy-loader-progress">Preparing...</div>
            </div>
        </div>

        <!-- Video Tab -->
        <div class="tab-panel" id="tab-video">
            <div class="video-section">
                <div class="video-header" style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <h3>Video Back Views</h3>
                        <p>Generate back views of models from front/3-4 images for video production</p>
                    </div>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <span id="video-cost-display" style="font-size: 11px; color: var(--slate);"></span>
                        <button class="btn" onclick="deselectAllVideoProducts()">Deselect All</button>
                        <button class="btn btn--primary" id="video-generate-all-btn" onclick="generateAllVideoProducts()">Generate All</button>
                    </div>
                </div>

                <!-- Settings Bar -->
                <div class="settings-compact">
                    <div class="setting-item">
                        <label>Provider:</label>
                        <div class="btn-group-compact" id="video-provider-buttons">
                            <button class="active" data-value="gemini">Gemini</button>
                            <button data-value="fal">FAL</button>
                        </div>
                    </div>
                    <div class="setting-item">
                        <label>Ratio:</label>
                        <div class="btn-group-compact" id="video-aspect-buttons">
                            <button data-value="9:16">9:16</button>
                            <button data-value="2:3">2:3</button>
                            <button class="active" data-value="3:4">3:4</button>
                            <button data-value="4:5">4:5</button>
                            <button data-value="1:1">1:1</button>
                            <button data-value="4:3">4:3</button>
                        </div>
                    </div>
                    <div class="setting-item">
                        <label>Res:</label>
                        <div class="btn-group-compact" id="video-resolution-buttons">
                            <button data-value="1K">1K</button>
                            <button class="active" data-value="2K">2K</button>
                            <button data-value="4K">4K</button>
                        </div>
                    </div>
                    <div class="setting-item">
                        <label>Seeds:</label>
                        <div class="btn-group-compact" id="video-seeds-buttons">
                            <button class="active" data-value="1">1</button>
                            <button data-value="2">2</button>
                            <button data-value="4">4</button>
                            <button data-value="6">6</button>
                            <button data-value="8">8</button>
                            <button data-value="10">10</button>
                        </div>
                    </div>
                </div>

                <!-- Video Products Grid -->
                <div id="video-products-grid"></div>

                <!-- Inline Loader -->
                <div class="inline-loader" id="video-loader">
                    <div class="loader-message" id="video-loader-message">Generating back views...</div>
                    <div class="loader-progress" id="video-loader-progress">Preparing...</div>
                </div>

                <!-- Video Results -->
                <div class="video-results" id="video-results"></div>
            </div>
        </div>

        <!-- Video Output Tab -->
        <div class="tab-panel" id="tab-video-output">
            <div class="video-output-section">
                <div class="video-output-header" style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <h3>Video Output - First/Last Frame</h3>
                        <p>Generate rotation videos from front/back image pairs using Kling</p>
                    </div>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <button class="btn" id="vo-analyze-btn" onclick="analyzeVideoOutputPairs()" disabled>Analyze</button>
                        <button class="btn btn--primary" id="vo-generate-btn" onclick="generateVideoOutputVideos()" disabled>Generate Videos</button>
                        <span id="vo-cost-info" style="font-size: var(--text-sm); color: var(--slate); margin-left: 8px;"></span>
                    </div>
                </div>

                <!-- Settings Bar -->
                <div class="settings-compact">
                    <div class="setting-item">
                        <label>Quality:</label>
                        <div class="btn-group-compact" id="vo-quality-buttons">
                            <button data-value="standard">Standard</button>
                            <button class="active" data-value="pro">Pro</button>
                        </div>
                    </div>
                    <div class="setting-item">
                        <label>Ratio:</label>
                        <div class="btn-group-compact" id="vo-aspect-buttons">
                            <button class="active" data-value="as-is">As-Is</button>
                            <button data-value="9:16">9:16</button>
                            <button data-value="1:1">1:1</button>
                            <button data-value="16:9">16:9</button>
                        </div>
                    </div>
                    <div class="setting-item">
                        <label>Duration:</label>
                        <div class="vo-duration-slider-group">
                            <input type="range" class="vo-duration-slider" id="vo-duration-slider" min="5" max="10" value="6" step="1">
                            <span class="vo-duration-value" id="vo-duration-value">6s</span>
                        </div>
                    </div>
                    <div class="setting-item">
                        <label>Select:</label>
                        <div class="btn-group-compact" id="vo-select-buttons">
                            <button onclick="voSelectAll()">All</button>
                            <button onclick="voDeselectAll()">None</button>
                        </div>
                    </div>
                </div>

                <!-- Drop Zone for folder -->
                <div class="vo-drop-zone" id="vo-drop-zone"
                     ondrop="handleVideoOutputDrop(event)"
                     ondragover="handleVideoOutputDragOver(event)"
                     ondragleave="handleVideoOutputDragLeave(event)">
                    <div class="vo-drop-zone-content">
                        <span class="vo-drop-icon">ðŸ“</span>
                        <span>Drop folder with front/back image pairs</span>
                        <span class="vo-drop-hint">Files should end with _front.png and _back.png</span>
                    </div>
                </div>

                <!-- Pairs Grid -->
                <div class="vo-pairs-grid" id="vo-pairs-grid"></div>

                <!-- Inline Loader -->
                <div class="inline-loader" id="vo-loader">
                    <div class="loader-message" id="vo-loader-message">Processing...</div>
                    <div class="loader-progress" id="vo-loader-progress">Preparing...</div>
                </div>

                <!-- Video Results -->
                <div class="vo-results" id="vo-results"></div>
            </div>
        </div>

        <!-- Canny Tab -->
        <div class="tab-panel" id="tab-canny">
            <div class="canny-section">
                <div class="canny-header">
                    <h3>Canny Guide Generator</h3>
                    <p>Upload product images to generate black & white line art guides for composition</p>
                </div>

                <!-- Settings Bar -->
                <div class="settings-compact">
                    <div class="setting-item">
                        <label>Ratio:</label>
                        <div class="btn-group-compact" id="canny-aspect-buttons">
                            <button data-value="9:16">9:16</button>
                            <button data-value="2:3">2:3</button>
                            <button class="active" data-value="3:4">3:4</button>
                            <button data-value="4:5">4:5</button>
                            <button data-value="1:1">1:1</button>
                            <button data-value="4:3">4:3</button>
                        </div>
                    </div>
                    <div class="setting-item">
                        <label>Res:</label>
                        <div class="btn-group-compact" id="canny-resolution-buttons">
                            <button data-value="1K">1K</button>
                            <button class="active" data-value="2K">2K</button>
                            <button data-value="4K">4K</button>
                        </div>
                    </div>
                    <div class="setting-item">
                        <label>Seeds:</label>
                        <div class="btn-group-compact" id="canny-seeds-buttons">
                            <button class="active" data-value="1">1</button>
                            <button data-value="2">2</button>
                            <button data-value="3">3</button>
                            <button data-value="4">4</button>
                        </div>
                    </div>
                </div>

                <div class="canny-upload-area">
                    <div class="canny-upload-grid" id="canny-upload-grid"></div>
                    <input type="file" id="canny-file-input" multiple accept="image/*" style="display: none;">
                </div>
                <div class="canny-actions">
                    <button class="btn btn--primary" id="canny-generate-btn" onclick="generateCanny()" disabled>Generate Canny Guides</button>
                    <button class="btn" onclick="clearCannyGrid()">Clear All</button>
                </div>
                <div class="inline-loader" id="canny-loader">
                    <div class="loader-message" id="canny-loader-message">Setting up the Studio...</div>
                    <div class="loader-progress" id="canny-loader-progress">Preparing...</div>
                </div>
                <div class="canny-results" id="canny-results"></div>
            </div>
        </div>

        <!-- Overview Tab -->
        <div class="tab-panel" id="tab-overview">
            <div class="stats-bar">
                <div class="stat-item">
                    <span class="stat-value">13</span>
                    <span class="stat-label">Products</span>
                </div>
                <div class="stat-item">
                    <span class="stat-value">73</span>
                    <span class="stat-label">Images</span>
                </div>
            </div>
            <div id="products-overview"></div>
        </div>

        <!-- Results Tab - View rendered outputs -->
        <div class="tab-panel" id="tab-results">
            <div class="stats-bar" id="results-stats">
                <div class="stat-item">
                    <span class="stat-value" id="results-total-count">0</span>
                    <span class="stat-label">Total Images</span>
                </div>
                <div class="stat-item">
                    <span class="stat-value" id="results-products-count">0</span>
                    <span class="stat-label">Products</span>
                </div>
                <div class="stat-item">
                    <span class="stat-value" id="results-missing-count">0</span>
                    <span class="stat-label">Missing</span>
                </div>
            </div>
            <div id="results-grid"></div>
        </div>

        <!-- Finals Tab - Final export-ready images -->
        <div class="tab-panel" id="tab-finals">
            <div class="stats-bar" id="finals-stats">
                <div class="stat-item">
                    <span class="stat-value" id="finals-total-count">0</span>
                    <span class="stat-label">Total Images</span>
                </div>
                <div class="stat-item">
                    <span class="stat-value" id="finals-products-count">0</span>
                    <span class="stat-label">Products</span>
                </div>
                <div class="stat-item">
                    <span class="stat-value" id="finals-missing-count">0</span>
                    <span class="stat-label">Missing</span>
                </div>
            </div>
            <div id="finals-grid"></div>
        </div>

        <!-- Prompts Tab -->
        <div class="tab-panel" id="tab-prompts">
            <div class="prompts-container" style="padding: 20px; max-width: 900px;">
                <h3 style="margin-bottom: 10px;">Model 1 Face Variation Prompts</h3>
                <p style="color: #666; margin-bottom: 20px; font-size: 14px;">Use these prompts with Gemini to create slight facial variations while keeping the same hair, facial structure, and clothing.</p>

                <div class="prompts-display" style="background: #f5f5f5; padding: 20px; border-radius: 8px; font-family: monospace; white-space: pre-wrap; line-height: 2.2;">
Take this exact model and adjust naturally: slightly larger more open eyes with warm brown color, softer rounded jawline, slightly wider nose bridge. Keep the same serious neutral expression, gaze, hair, skin tone, stubble, and clothing.

Take this exact model and adjust naturally: eyes with a grey-green color, thicker straighter eyebrows, slightly more angular jaw, nose with a subtle bump on the bridge. Keep the same serious neutral expression, gaze, hair, skin tone, stubble, and clothing.

Take this exact model and adjust naturally: slightly narrower almond-shaped eyes with dark brown color, thinner more arched brows, slightly longer nose, more pointed chin. Keep the same serious neutral expression, gaze, hair, skin tone, stubble, and clothing.

Take this exact model and adjust naturally: slightly bigger rounder eyes with olive green color, fuller thicker eyebrows, softer rounder face shape, slightly wider fuller lips. Keep the same serious neutral expression, gaze, hair, skin tone, stubble, and clothing.

Take this exact model and adjust naturally: deep-set eyes with amber-brown color, stronger brow bone, more prominent cheekbones, squarer more defined jaw. Keep the same serious neutral expression, gaze, hair, skin tone, stubble, and clothing.

Take this exact model and adjust naturally: eyes slightly wider apart with blue-grey color, slightly thinner refined nose, softer less angular jaw, thinner eyebrows. Keep the same serious neutral expression, gaze, hair, skin tone, stubble, and clothing.

Take this exact model and adjust naturally: slightly hooded eyes with warm hazel color, thicker darker eyebrows, broader nose, stronger more square chin. Keep the same serious neutral expression, gaze, hair, skin tone, stubble, and clothing.

Take this exact model and adjust naturally: rounder more open eyes with light brown color, higher more arched brows, slightly shorter nose with rounder tip, softer jawline. Keep the same serious neutral expression, gaze, hair, skin tone, stubble, and clothing.

Take this exact model and adjust naturally: narrower eyes with steel grey color, straighter heavier brows, longer face shape, more angular cheekbones, sharper jaw. Keep the same serious neutral expression, gaze, hair, skin tone, stubble, and clothing.

Take this exact model and adjust naturally: slightly larger eyes with honey-gold color, natural thick brows, slightly wider face, fuller cheeks, rounded chin. Keep the same serious neutral expression, gaze, hair, skin tone, stubble, and clothing.
                </div>

                <button class="btn btn--primary" style="margin-top: 15px;" onclick="navigator.clipboard.writeText(document.querySelector('.prompts-display').textContent.trim()); this.textContent='Copied!'; setTimeout(() => this.textContent='Copy All Prompts', 2000)">Copy All Prompts</button>
            </div>
        </div>

        <!-- Global Results Section (persists across tabs) -->
        <div class="global-results-section" id="global-results-section">
            <div class="global-results-header">
                <span class="global-results-title">Results</span>
                <span class="global-results-count" id="global-results-count">0 images</span>
                <button class="btn" onclick="clearGlobalResults()" style="margin-left: auto; padding: 4px 8px; font-size: 10px;">Clear All</button>
            </div>
            <div class="inline-loader" id="global-loader">
                <div class="loader-message" id="global-loader-message">Generating...</div>
                <div class="loader-progress" id="global-loader-progress">Preparing...</div>
            </div>
            <div class="global-results-grid" id="global-results-grid"></div>
        </div>
    </div>

    <!-- Lightbox is created by shared/js/lightbox.js -->

    <script>
        // ========== DATA ==========
        // Shot requirements from PDF: Setset for Fearless Summer - E-Commerce Shoot.pdf
        const PRODUCTS = [
            { category: 'Shirts', sku: '21TS1505.RW', name: 'Organic Cotton Crochet Knit Shirt', color: 'Natural', material: '100% organic cotton', shotTypes: ['flatlay', 'eyelet', 'collar', 'fabrics', 'sleeves', 'on-model'], video: true },
            { category: 'Urban Shorts', sku: '21SS20.RW', name: 'Crochet Knit Shorts', color: 'Natural', material: '100% organic cotton', shotTypes: ['flatlay', 'eyelet', 'belt', 'fabrics', 'on-model', 'back'], video: false },
            { category: 'Tank Tops', sku: '21TK189.RW', name: 'Organic Cotton Crochet Knit Tank Top', color: 'Natural', material: '100% organic cotton', shotTypes: ['flatlay', 'eyelet', 'collar', 'fabrics', 'on-model'], video: true },
            { category: 'T-Shirts', sku: '21TS1115DD.SO', name: 'Crew Neck T-Shirt Eyelet Edition', color: 'Sunset Orange', material: '100% gassed cotton', shotTypes: ['flatlay', 'eyelet', 'collar', 'on-model'], video: false },
            { category: 'Sweatshirts', sku: '21SW2019.SO', name: 'Light Organic Cotton Sleeveless Sweatshirt', color: 'Sunset Orange', material: '100% cotton', shotTypes: ['flatlay', 'eyelet', 'on-model'], video: false },
            { category: 'Sweatshirts', sku: '21TS1267.SO', name: 'Sleeveless T-Shirt "Sunset Boy"', color: 'Sunset Orange', material: '100% organic cotton', shotTypes: ['flatlay', 'print', 'on-model'], video: false },
            { category: 'Swim Briefs', sku: '21SR20DD.SO', name: 'Slim Swim Briefs', color: 'Sunset Orange', material: '80% polyamide, 20% elasthanne', shotTypes: ['flatlay', 'eyelet', 'on-model', 'back'], video: true },
            { category: 'Swim Briefs', sku: '21SR21B.S', name: 'Swim Briefs w. Waistband', color: 'Sand', material: '80% polyamide, 20% elasthanne', shotTypes: ['flatlay', 'eyelet', 'belt', 'on-model', 'back'], video: false },
            { category: 'Swim Shorts', sku: '21SR23DD.SO', name: 'Swim Shorts', color: 'Sunset Orange', material: '100% recycled polyester', shotTypes: ['flatlay', 'eyelet', 'on-model', 'back'], video: false },
            { category: 'Sports Shorts', sku: '21SS21.BE', name: 'Corduroy Tennis Shorts', color: 'Beige', material: '97% cotton, 3% spandex', shotTypes: ['flatlay', 'eyelet', 'belt', 'fabrics', 'on-model', 'back'], video: true },
            { category: 'Accessories', sku: '21CA653DD.SO', name: 'Coach Cap "Sunset Boy"', color: 'Sunset Orange', material: '100% cotton canvas', shotTypes: ['flatlay', 'eyelet', 'print', 'on-model'], video: false },
            { category: 'Accessories', sku: '21BG97.SO', name: 'Tote Bag "Fearless"', color: 'Sunset Orange', material: '100% cotton canvas', shotTypes: ['flatlay', 'eyelet', 'print', 'on-model'], video: false },
            { category: 'Y-Front Briefs', sku: '21UR42.W', name: 'RD Low-Rise Briefs', color: 'Black', material: '95% cotton, 5% elasthanne', shotTypes: ['flatlay', 'eyelet', 'belt', 'on-model'], video: false },
            { category: 'Swim Briefs', sku: '21UR30.W', name: 'Minimal Swim Briefs', color: 'Black', material: '80% polyamide, 20% elasthanne', shotTypes: ['flatlay', 'eyelet', 'belt', 'back', 'on-model'], video: true }
        ];

        // ========== PRODUCT-SPECIFIC PROMPTS (loaded from JSON files) ==========
        // Prompts are stored in /assets/brand/rondorff/prompts/{SKU}.json
        // Each file contains the product metadata and all shot type prompts
        let LOADED_PROMPTS = {};

        // Load all product prompts from JSON files
        async function loadProductPrompts() {
            const skus = PRODUCTS.map(p => p.sku);
            const promptsDir = '/assets/brand/rondorff/prompts';

            console.log('ðŸ“‚ Loading product prompts...');

            for (const sku of skus) {
                try {
                    const response = await fetch(`${promptsDir}/${sku}.json`);
                    if (!response.ok) {
                        console.warn(`âš ï¸ No prompt file for ${sku}`);
                        continue;
                    }
                    const data = await response.json();
                    LOADED_PROMPTS[sku] = data.prompts;
                    console.log(`âœ“ Loaded prompts for ${sku} (${Object.keys(data.prompts).length} shot types)`);
                } catch (err) {
                    console.error(`âŒ Failed to load prompts for ${sku}:`, err);
                }
            }

            console.log(`ðŸ“‚ Loaded prompts for ${Object.keys(LOADED_PROMPTS).length}/${skus.length} products`);
        }

        // Prompts are loaded from /assets/brand/rondorff/prompts/{SKU}.json
        // PRODUCT_PROMPT_OVERRIDES removed - all prompts now in JSON files

        // Get prompt from loaded JSON files - throws error if not found (no fallbacks)
        function getPromptOverride(sku, shotType, guideType) {
            const productPrompts = LOADED_PROMPTS[sku];
            if (!productPrompts) {
                throw new Error(`No prompts loaded for product ${sku}. Check /assets/brand/rondorff/prompts/${sku}.json`);
            }

            // Check for guide-specific prompt first (e.g., 'flatlay_canny')
            if (guideType) {
                const guideKey = `${shotType}_${guideType}`;
                if (productPrompts[guideKey]) return productPrompts[guideKey];
            }

            // Get shot type prompt - return null if not found (allows fallback to generic prompt)
            const prompt = productPrompts[shotType];
            if (!prompt) {
                console.log(`No prompt override for ${sku} / ${shotType}, using generic prompt`);
                return null;
            }

            return prompt;
        }

        // ========== PRODUCTS V2 PROMPTS (loaded from JSON files) ==========
        let LOADED_PROMPTS_V2 = {};

        // Load all V2 product prompts from JSON files
        async function loadProductPromptsV2() {
            const skus = PRODUCTS.map(p => p.sku);
            const promptsDir = '/assets/brand/rondorff/prompts-v2';

            console.log('ðŸ“‚ Loading V2 product prompts...');

            for (const sku of skus) {
                try {
                    const response = await fetch(`${promptsDir}/${sku}.json`);
                    if (!response.ok) {
                        // V2 prompts are optional - silently fall back to V1 if not found
                        continue;
                    }
                    // Check content type to avoid parsing HTML 404 pages
                    const contentType = response.headers.get('content-type');
                    if (!contentType || !contentType.includes('application/json')) {
                        continue;
                    }
                    const data = await response.json();
                    LOADED_PROMPTS_V2[sku] = data.prompts;
                    console.log(`âœ“ Loaded V2 prompts for ${sku} (${Object.keys(data.prompts).length} shot types)`);
                } catch (err) {
                    // Silently ignore - V2 prompts are optional
                }
            }

            console.log(`ðŸ“‚ Loaded V2 prompts for ${Object.keys(LOADED_PROMPTS_V2).length}/${skus.length} products`);
        }

        // Get V2 prompt - falls back to V1 if V2 not available
        function getPromptOverrideV2(sku, shotType, guideType) {
            // Try V2 first
            const v2Prompts = LOADED_PROMPTS_V2[sku];
            if (v2Prompts) {
                if (guideType) {
                    const guideKey = `${shotType}_${guideType}`;
                    if (v2Prompts[guideKey]) return v2Prompts[guideKey];
                }
                if (v2Prompts[shotType]) return v2Prompts[shotType];
            }

            // Fall back to V1
            return getPromptOverride(sku, shotType, guideType);
        }

        // Build V2 prompt with template variable replacement
        function buildPromptV2(shotType, product, selectedImages, guideInfo = null) {
            const sku = product.sku;
            const guideType = guideInfo?.isPhotoRef ? 'photo' : (guideInfo ? 'canny' : null);

            // Get prompt template
            let prompt = getPromptOverrideV2(sku, shotType, guideType);

            if (!prompt) {
                // Generic fallback for V2
                prompt = `E-commerce ${shotType} photograph.\n\nIMAGE ORDER:\n- Images 1+: Product photos - use for color and details\n${guideInfo ? '- LAST image: Composition reference - COPY THIS EXACTLY\n' : ''}\nPRODUCT: {{productColor}} {{shortProductName}}\n\nCRITICAL: Match product colors exactly from input images. Clean, crisp presentation.\n\nLIGHTING & BACKGROUND: Light gray studio backdrop. Bright, even lighting.`;
            }

            // Replace template variables
            const shortName = product.name.split(' ').slice(0, 3).join(' ');
            prompt = prompt
                .replace(/\{\{productColor\}\}/g, product.color)
                .replace(/\{\{shortProductName\}\}/g, shortName)
                .replace(/\{\{productName\}\}/g, product.name)
                .replace(/\{\{material\}\}/g, product.material)
                .replace(/\{\{sku\}\}/g, product.sku);

            // Add guide description if present
            if (guideInfo?.description) {
                prompt = prompt.replace(/\{\{guideDescription\}\}/g, guideInfo.description);
            }

            return prompt;
        }

        // Model portraits for face/3-4 shot types
        const MODEL_PORTRAITS = [
            { id: 'model-01', thumb: '/assets/brand/rondorff/models/thumbs/model-01.jpg', full: '/assets/brand/rondorff/models/model-01.jpg', name: 'Model 1', description: 'Caucasian male model EXACTLY as shown in image 1 - medium-length wavy brown hair, green eyes, stubble, athletic build, tan skin' },
            { id: 'model-02', thumb: '/assets/brand/rondorff/models/thumbs/model-02.jpg', full: '/assets/brand/rondorff/models/model-02.png', name: 'Model 2', description: 'Caucasian male model EXACTLY as shown in image 1 - short strawberry blonde hair, blue eyes, clean-shaven, athletic build, tan skin' }
        ];

        // Shot types that need model portraits
        const SHOT_TYPES_WITH_MODELS = ['on-model'];

        // Footwear options for bottoms on-model shots
        const FOOTWEAR = [
            { id: 'sneakers-white', thumb: '/assets/brand/rondorff/accessories/sneakers-white.png', full: '/assets/brand/rondorff/accessories/sneakers-white.png', name: 'White Sneakers', description: 'white leather sneakers with Ron Dorff eyelets' }
        ];

        // Categories that can use footwear for 3/4 shots (bottoms only)
        // No footwear for swimwear (Swim Briefs, Swim Shorts) per client feedback
        const CATEGORIES_WITH_FOOTWEAR = ['Urban Shorts', 'Sports Shorts', 'Y-Front Briefs', 'Accessories'];

        // Bottoms (pants/shorts) for tops - similar to footwear but for shirts/tank tops
        const BOTTOMS = [
            { id: 'shorts-white', thumb: '/assets/brand/rondorff/accessories/bottoms/thumbs/shorts-white.jpg', full: '/assets/brand/rondorff/accessories/bottoms/shorts-white.png', name: 'White Shorts', description: 'white tailored shorts with Ron Dorff eyelets' },
            { id: 'shorts-navy-model', thumb: '/assets/brand/rondorff/accessories/bottoms/thumbs/shorts-navy-model.jpg', full: '/assets/brand/rondorff/accessories/bottoms/shorts-navy-model.png', name: 'Navy Shorts (Model)', description: 'navy tailored shorts' },
            { id: 'shorts-navy-linen', thumb: '/assets/brand/rondorff/accessories/bottoms/thumbs/shorts-navy-linen.jpg', full: '/assets/brand/rondorff/accessories/bottoms/shorts-navy-linen.png', name: 'Navy Linen Shorts', description: 'navy linen shorts with Ron Dorff eyelets' },
            { id: 'pants-black', thumb: '/assets/brand/rondorff/accessories/bottoms/thumbs/pants-black.jpg', full: '/assets/brand/rondorff/accessories/bottoms/pants-black.png', name: 'Black Pants', description: 'black tailored pants with Ron Dorff eyelets' }
        ];

        // Categories that can use bottoms for face/3/4 shots (tops only)
        const CATEGORIES_WITH_BOTTOMS = ['Shirts', 'T-Shirts', 'Tank Tops', 'Polos', 'Knits', 'Sweatshirts', 'Accessories'];

        // Tops (t-shirts) for accessories - model wears this with the accessory
        const TOPS = [
            { id: 'tshirt-white', thumb: '/assets/brand/rondorff/accessories/tops/thumbs/tshirt-white.jpg', full: '/assets/brand/rondorff/accessories/tops/tshirt-white.png', name: 'White T-Shirt', description: 'plain white round-neck t-shirt' }
        ];

        // Categories that can use tops for on-model shots (accessories only)
        const CATEGORIES_WITH_TOPS = ['Accessories'];

        // Canny reference images (input photos used to create guides)
        const CANNY_INPUT_IMAGES = [
            { file: 'Setset_Canny_FlatLay_Polo.png', type: 'flatlay', label: 'FlatLay Polo' },
            { file: 'Setset_Canny_FlatLay_TankTop.png', type: 'flatlay', label: 'FlatLay Tank' },
            { file: 'Setset_Canny_FlatLay_TShirt.png', type: 'flatlay', label: 'FlatLay Tee' },
            { file: 'Setset_Canny_Collar_Polo.png', type: 'collar', label: 'Collar Polo' },
            { file: 'Setset_Canny_Collar_TankTop.png', type: 'collar', label: 'Collar Tank' },
            { file: 'Setset_Canny_Collar_TShirt.png', type: 'collar', label: 'Collar Tee' },
            { file: 'Setset_Canny_Eyelet_Minimal.png', type: 'eyelet', label: 'Eyelet Minimal' },
            { file: 'Setset_Canny_Eyelet_Knit.png', type: 'eyelet', label: 'Eyelet Knit' },
            { file: 'Setset_Canny_Eyelet_Shorts.png', type: 'eyelet', label: 'Eyelet Shorts' },
            { file: 'Setset_Canny_Belt_Shorts.png', type: 'belt', label: 'Belt Shorts' }
        ];

        // Canny guide images (black/white line drawings)
        const CANNY_GUIDE_IMAGES = [
            { file: 'Setset_Canny_FlatLay_Polo.png', type: 'flatlay', label: 'FlatLay Polo', isPhotoRef: false },
            { file: 'Setset_Canny_FlatLay_TankTop.png', type: 'flatlay', label: 'FlatLay Tank', isPhotoRef: false },
            { file: 'Setset_Canny_FlatLay_TShirt.png', type: 'flatlay', label: 'FlatLay Tee', isPhotoRef: false },
            { file: 'Setset_Canny_Collar_Polo.png', type: 'collar', label: 'Collar Polo', isPhotoRef: false },
            { file: 'Setset_Canny_Collar_TankTop.png', type: 'collar', label: 'Collar Tank', isPhotoRef: false },
            { file: 'Setset_Canny_Collar_TShirt.png', type: 'collar', label: 'Collar Tee', isPhotoRef: false },
            { file: 'Setset_Canny_Collar_TShirt_v2.png', type: 'collar', label: 'Collar Tee v2', isPhotoRef: false },
            { file: 'Setset_Canny_Collar_Polo_v2.png', type: 'collar', label: 'Collar Polo v2', isPhotoRef: false },
            { file: 'Setset_Canny_Collar_Shirt_Pocket.png', type: 'collar', label: 'Collar Shirt Pocket', isPhotoRef: false },
            { file: 'Setset_Canny_Eyelet_Minimal.png', type: 'eyelet', label: 'Eyelet Minimal', isPhotoRef: false },
            { file: 'Setset_Canny_Eyelet_Knit.png', type: 'eyelet', label: 'Eyelet Knit', isPhotoRef: false },
            { file: 'Setset_Canny_Eyelet_Shorts.png', type: 'eyelet', label: 'Eyelet Shorts', isPhotoRef: false },
            { file: 'Setset_Canny_Belt_Shorts.png', type: 'belt', label: 'Belt Shorts', isPhotoRef: false }
        ];

        // Photo reference images (actual photos to use as composition reference)
        // folder: subfolder within /assets/brand/rondorff/refs/ OR 'canny' for legacy /canny/refs/ path
        const PHOTO_REF_IMAGES = [
            // === EYELET DETAIL SHOTS (Original refs) ===
            { folder: 'canny', file: 'Setset_Canny_Eyelet_Knit.png', type: 'eyelet', label: 'Knit', isPhotoRef: true, description: 'knit garment laid flat at 45-degree angle, ribbed hem visible at bottom corner, fabric smooth and fills frame, two eyelets diagonal near hem' },
            { folder: 'canny', file: 'Setset_Canny_Eyelet_Minimal.png', type: 'eyelet', label: 'Minimal', isPhotoRef: true, description: 'garment fabric layered at diagonal angle showing two eyelets, clean minimal composition with fabric filling corner of frame' },
            { folder: 'canny', file: 'Setset_Canny_Eyelet_Shorts.png', type: 'eyelet', label: 'Shorts', isPhotoRef: true, description: 'shorts fabric laid flat at angle, hem edge visible at bottom, smooth fabric filling frame corner, two eyelets positioned diagonally' },
            { folder: 'canny', file: 'Setset_Canny_Eyelet_Red.png', type: 'eyelet', label: 'Red Knit', isPhotoRef: true, description: 'red/burgundy crochet knit fabric laid flat at diagonal angle, hem edge visible at bottom corner, two Ron Dorff branded eyelets positioned diagonally' },
            // === EYELET DETAIL SHOTS (New refs) ===
            { folder: 'detail', file: 'Eyelet_Shorts_Brown_01.png', type: 'eyelet', label: 'Brown Shorts', isPhotoRef: true, description: 'brown shorts fabric at diagonal angle, two Ron Dorff eyelets visible near hem' },
            { folder: 'detail', file: 'Eyelet_Shorts_Striped_01.png', type: 'eyelet', label: 'Striped', isPhotoRef: true, description: 'striped fabric shorts at angle, eyelets visible near bottom hem' },
            { folder: 'detail', file: 'Eyelet_Underwear_Olive_01.png', type: 'eyelet', label: 'Olive Underwear', isPhotoRef: true, description: 'olive green underwear waistband with eyelets detail' },

            // === SMALL EYELET DETAIL SHOTS (Swim Briefs style - smaller eyelets) ===
            { folder: 'eyelet-small', file: 'Eyelet_Small_Gray_01.webp', type: 'eyelet', label: 'Small Gray 1', isPhotoRef: true, smallEyelet: true, description: 'swim briefs corner detail with SMALLER RON DORFF eyelets, gray/anthracite fabric, diagonal angle showing hem with smaller eyelet size' },
            { folder: 'eyelet-small', file: 'Eyelet_Small_Gray_02.webp', type: 'eyelet', label: 'Small Gray 2', isPhotoRef: true, smallEyelet: true, description: 'swim briefs corner detail with SMALLER RON DORFF eyelets, gray/anthracite fabric, diagonal angle showing hem with smaller eyelet size' },
            { folder: 'eyelet-small', file: 'Eyelet_Small_Black.webp', type: 'eyelet', label: 'Small Black', isPhotoRef: true, smallEyelet: true, description: 'swim briefs corner detail with SMALLER RON DORFF eyelets, black fabric, diagonal angle showing hem with smaller eyelet size' },
            { folder: 'eyelet-small', file: 'Eyelet_Small_White.jpg', type: 'eyelet', label: 'Small White', isPhotoRef: true, smallEyelet: true, description: 'swim briefs corner detail with SMALLER RON DORFF eyelets, white fabric, diagonal angle showing hem with smaller eyelet size' },

            // === BELT/WAISTBAND DETAIL SHOTS ===
            { folder: 'detail', file: 'Belt_Shorts_Grey_01.png', type: 'belt', label: 'Grey Belt', isPhotoRef: true, description: '30-45 degree diagonal angle, waistband across top of frame, Ron Dorff label visible, garment laid flat on light gray background' },
            { folder: 'detail', file: 'Belt_Shorts_Navy_01.png', type: 'belt', label: 'Navy Belt 1', isPhotoRef: true, description: '30-45 degree diagonal angle, waistband across top of frame, belt loop detail visible, garment laid flat on light gray background' },
            { folder: 'detail', file: 'Belt_Shorts_Navy_02.png', type: 'belt', label: 'Navy Belt 2', isPhotoRef: true, description: '30-45 degree diagonal angle, waistband at top, drawstrings hanging straight down parallel to each other, garment laid flat on light gray background' },
            { folder: 'detail', file: 'Drawstring_Shorts_Turquoise_01.png', type: 'belt', label: 'Turquoise Draw', isPhotoRef: true, description: 'waistband at top edge, drawstrings tied in bow, close-up detail shot on light gray background' },
            { folder: 'detail', file: 'Pocket_Shorts_Olive_01.png', type: 'belt', label: 'Olive Pocket', isPhotoRef: true, description: '30-45 degree diagonal angle, waistband and pocket detail visible, garment laid flat on light gray background' },
            { folder: 'detail', file: 'Eyelet_Shorts_Pink_01.png', type: 'belt', label: 'Pink Shorts', isPhotoRef: true, description: '30-45 degree diagonal angle, waistband runs across top of frame diagonally, pocket edge visible, clean precise composition on light gray studio background' },

            // === COLLAR DETAIL SHOTS ===
            { folder: 'detail', file: 'Collar_Sweatshirt_Brown_01.png', type: 'collar', label: 'Brown Sweat', isPhotoRef: true, description: 'brown sweatshirt with slightly angled view of crew neck collar, Ron Dorff tag visible at neckline, ribbed collar detail' },
            { folder: 'detail', file: 'Collar_Tank_Olive_01.png', type: 'collar', label: 'Olive Tank', isPhotoRef: true, description: 'olive tank top with slightly angled view showing scoop neckline and Ron Dorff tag, garment laid flat with clean straight edges' },

            // === SLEEVE DETAIL SHOTS ===
            { folder: 'detail', file: 'Sleeve_Shorts_Pink_01.png', type: 'sleeves', label: 'Pink Hem', isPhotoRef: true, description: 'pink shorts leg hem and construction detail' },
            { folder: 'detail', file: 'Sleeve_Sweatshirt_Grey_01.png', type: 'sleeves', label: 'Grey Cuff', isPhotoRef: true, description: 'grey sweatshirt sleeve cuff ribbed detail' },

            // === PRINT/FABRIC DETAIL SHOTS ===
            { folder: 'detail', file: 'Print_Tshirt_DAD_Pink_01.png', type: 'fabrics', label: 'DAD Print', isPhotoRef: true, description: 'pink t-shirt DAD text print detail' },
            { folder: 'detail', file: 'ToteBag_Print_Black_01.png', type: 'fabrics', label: 'Bag Print', isPhotoRef: true, description: 'black tote bag Ron Dorff print detail' },

            // === PRINT COMPOSITION SHOTS ===
            { folder: 'detail', file: 'Print_Tshirt_Grey_01.png', type: 'print', label: 'Grey Print Tee', isPhotoRef: true, description: 'grey t-shirt top-down view showing collar, Ron Dorff label, and text print on chest area, garment laid flat' },

            // === FLAT LAY SHOTS ===
            { folder: 'flatlay', file: 'Sweatshirt_Grey_Sleeveless_01.png', type: 'flatlay', label: 'Grey Sleeveless', isPhotoRef: true, description: 'grey sleeveless t-shirt laid flat, crew neck with Ron Dorff label visible, clean armholes, professional e-commerce flat lay' },
            { folder: 'flatlay', file: 'Shorts_Pink_01.png', type: 'flatlay', label: 'Pink Shorts', isPhotoRef: true, description: 'pink shorts laid flat, drawstrings OUT and laid flat pointing down, elastic waistband, side pockets, eyelets near hem, professional e-commerce flat lay' },
            { folder: 'flatlay', file: 'Swimwear_Beige_01.png', type: 'flatlay', label: 'Swim Beige', isPhotoRef: true, description: 'beige swim briefs laid flat, drawstrings OUT and crossed at top, two black eyelets on right side, professional e-commerce flat lay' },
            { folder: 'flatlay', file: 'Swimwear_Navy_01.png', type: 'flatlay', label: 'Swim Navy', isPhotoRef: true, description: 'navy swim briefs laid flat, drawstrings OUT and crossed at top, two black eyelets on right side, white lining visible, professional e-commerce flat lay' },

            // === SHORTS FLAT LAY REFS (Porto style) ===
            { folder: 'shorts', file: 'Shorts_FlatLay_Burgundy.png', type: 'flatlay', label: 'Burgundy Shorts', isPhotoRef: true, description: 'burgundy terry shorts laid flat, button waistband, white side piping, two black eyelets on hem, professional e-commerce flat lay' },
            { folder: 'shorts', file: 'Shorts_FlatLay_Pink.png', type: 'flatlay', label: 'Pink Porto', isPhotoRef: true, description: 'dusty pink shorts laid flat, button waistband, diagonal pockets, two black eyelets on left hem, professional e-commerce flat lay' },
            { folder: 'shorts', file: 'Shorts_FlatLay_Navy.png', type: 'flatlay', label: 'Navy Porto', isPhotoRef: true, description: 'navy shorts laid flat, button waistband, white side piping, two black eyelets on hem, professional e-commerce flat lay' },
            { folder: 'shorts', file: 'Shorts_FlatLay_White.png', type: 'flatlay', label: 'White Porto', isPhotoRef: true, description: 'white shorts laid flat, black button waistband, diagonal pockets, two black eyelets on left hem, professional e-commerce flat lay' },

            // === SHORTS EYELET REFS ===
            { folder: 'shorts', file: 'Shorts_Eyelet_Burgundy.png', type: 'eyelet', label: 'Burgundy Eyelet', isPhotoRef: true, description: 'burgundy terry shorts corner detail, two black RON DORFF eyelets, white piping visible, diagonal angle' },
            { folder: 'shorts', file: 'Shorts_Eyelet_Pink.png', type: 'eyelet', label: 'Pink Eyelet', isPhotoRef: true, description: 'dusty pink shorts corner detail, two black RON DORFF PARIS STOCKHOLM eyelets, diagonal angle showing hem' },
            { folder: 'shorts', file: 'Shorts_Eyelet_Navy.png', type: 'eyelet', label: 'Navy Eyelet', isPhotoRef: true, description: 'navy shorts corner detail, two black RON DORFF eyelets, white piping visible, diagonal angle' },
            { folder: 'shorts', file: 'Shorts_Eyelet_Gray.png', type: 'eyelet', label: 'Gray Eyelet', isPhotoRef: true, description: 'heather gray shorts corner detail, two black RON DORFF eyelets, diagonal angle' },

            // === SHORTS BELT/WAISTBAND REFS ===
            { folder: 'shorts', file: 'Shorts_Belt_Navy.png', type: 'belt', label: 'Navy Waistband', isPhotoRef: true, description: 'navy shorts waistband detail, button closure, white piping, pocket edge visible, diagonal angle' },
            { folder: 'shorts', file: 'Shorts_Button_White.png', type: 'belt', label: 'White Button', isPhotoRef: true, description: 'white shorts waistband close-up, branded black button with RON DORFF text, pocket pleat detail' },
            { folder: 'shorts', file: 'Shorts_Pocket_Pink.png', type: 'belt', label: 'Pink Pocket', isPhotoRef: true, description: 'dusty pink shorts waistband and pocket detail, button closure, diagonal pocket edge' },

            // === SWIM SHORTS FLAT LAY REFS (with branded drawstrings) ===
            { folder: 'shorts-flatlay', file: 'Shorts_Flatlay_Orange.webp', type: 'flatlay', label: 'Swim Orange', isPhotoRef: true, description: 'orange swim shorts laid flat, branded RON DORFF PARIS STOCKHOLM drawstrings in loop at top, elastic waistband, two black eyelets on lower right, side pockets, professional e-commerce flat lay' },
            { folder: 'shorts-flatlay', file: 'Shorts_Flatlay_Brown.webp', type: 'flatlay', label: 'Swim Brown', isPhotoRef: true, description: 'dark brown/burgundy swim shorts laid flat, branded RON DORFF PARIS STOCKHOLM drawstrings in loop at top, elastic waistband, two black eyelets on lower right, side pockets, professional e-commerce flat lay' },
            { folder: 'shorts-flatlay', file: 'Shorts_Flatlay_Striped.webp', type: 'flatlay', label: 'Swim Striped', isPhotoRef: true, description: 'red/white/navy vertical striped swim shorts laid flat, branded RON DORFF PARIS STOCKHOLM drawstrings in loop at top, elastic waistband, two black eyelets on lower right, professional e-commerce flat lay' },

            // === SWIM SHORTS EYELET REFS ===
            { folder: 'shorts-flatlay', file: 'Shorts_Eyelet_Brown.jpg', type: 'eyelet', label: 'Swim Eyelet Brown', isPhotoRef: true, description: 'dark brown swim shorts corner detail, TIGHT MACRO close-up, two BLACK RON DORFF PARIS STOCKHOLM eyelets, diagonal angle showing hem and stitching, fabric fills 80% of frame' },

            // === CAP PRODUCT SHOTS (flatlay) - forSku limits to cap product only ===
            { folder: 'cap', file: 'Cap_Product_Pink_DAD.png', type: 'flatlay', label: 'Pink DAD Cap', isPhotoRef: true, forSku: '21CA653DD.SO', description: 'pink cotton cap product shot, DAD embroidery on front, 3/4 angle showing crown and brim' },
            { folder: 'cap', file: 'Cap_Product_Black_Corduroy.png', type: 'flatlay', label: 'Black Cord Cap', isPhotoRef: true, forSku: '21CA653DD.SO', description: 'black corduroy cap product shot, RON DORFF white text on front, 3/4 angle' },
            { folder: 'cap', file: 'Cap_Product_Gray_Logo.png', type: 'flatlay', label: 'Gray Logo Cap', isPhotoRef: true, forSku: '21CA653DD.SO', description: 'heather gray cap product shot, colorful RON DORFF logo on front, 3/4 angle' },

            // === CAP DETAIL/EMBROIDERY SHOTS (eyelet/print) ===
            { folder: 'cap', file: 'Cap_Detail_DAD_Embroidery.png', type: 'eyelet', label: 'DAD Embroid', isPhotoRef: true, forSku: '21CA653DD.SO', description: 'close-up of DAD embroidery detail on pink cap, tonal pink thread on pink fabric' },
            { folder: 'cap', file: 'Cap_Detail_DAD_Embroidery.png', type: 'print', label: 'DAD Print', isPhotoRef: true, forSku: '21CA653DD.SO', description: 'close-up of DAD embroidery detail on pink cap, tonal pink thread on pink fabric' },
            { folder: 'cap', file: 'Cap_Eyelet_Black.png', type: 'eyelet', label: 'Eyelet Black', isPhotoRef: true, forSku: '21CA653DD.SO', description: 'close-up of black metal RON DORFF eyelets on black cap, side view showing two eyelets' },
            { folder: 'cap', file: 'Cap_Eyelet_Green_Corduroy.png', type: 'eyelet', label: 'Eyelet Green', isPhotoRef: true, forSku: '21CA653DD.SO', description: 'close-up of black metal RON DORFF eyelets on green corduroy cap with RON DORFF embroidery' },
            { folder: 'cap', file: 'Cap_Eyelet_Pink_Corduroy.png', type: 'eyelet', label: 'Eyelet Pink', isPhotoRef: true, forSku: '21CA653DD.SO', description: 'close-up of black metal RON DORFF eyelets on pink corduroy cap with RON DORFF embroidery' },

            // === CAP ON-MODEL SHOTS (all front pose - headshots) ===
            { folder: 'cap', file: 'Cap_Model_Pink_DAD.png', type: 'on-model', poseType: 'front', label: 'Cap Pink DAD', isPhotoRef: true, forSku: '21CA653DD.SO', description: 'model wearing pink DAD cap with white t-shirt, head slightly turned, editorial pose' },
            { folder: 'cap', file: 'Cap_Model_Black_Corduroy.png', type: 'on-model', poseType: 'front', label: 'Cap Black Cord', isPhotoRef: true, forSku: '21CA653DD.SO', description: 'model wearing black corduroy RON DORFF cap with white t-shirt, front facing' },
            { folder: 'cap', file: 'Cap_Model_Pink_Corduroy.png', type: 'on-model', poseType: 'front', label: 'Cap Pink Cord', isPhotoRef: true, forSku: '21CA653DD.SO', description: 'model wearing pink corduroy RON DORFF cap with white t-shirt, slight head turn' },
            { folder: 'cap', file: 'Cap_Model_Black_Varsity.png', type: 'on-model', poseType: 'front', label: 'Cap Black Vars', isPhotoRef: true, forSku: '21CA653DD.SO', description: 'model wearing black RON DORFF varsity cap with white t-shirt' },
            { folder: 'cap', file: 'Cap_Model_Black_Trim.png', type: 'on-model', poseType: 'front', label: 'Cap Black Trim', isPhotoRef: true, forSku: '21CA653DD.SO', description: 'model wearing black cap with gray trim, RON DORFF text, white t-shirt' },

            // === TOTE BAG PRODUCT SHOTS (flatlay) - forSku limits to tote product only ===
            { folder: 'tote', file: 'Tote_Clean_Reference.png', type: 'flatlay', label: 'Tote Clean Ref', isPhotoRef: true, forSku: '21BG97.SO', description: 'CLEAN tote bag - perfectly flat canvas, no wrinkles, ombre pink-to-orange gradient, FEARLESS SUMMER text, black eyelets, light gray backdrop' },
            { folder: 'tote', file: 'Tote_Product_Black.png', type: 'flatlay', label: 'Tote Black', isPhotoRef: true, forSku: '21BG97.SO', description: 'black tote bag product shot, RON DORFF label, handles up, two black eyelets at bottom' },
            { folder: 'tote', file: 'Tote_Product_Navy_Wanted.png', type: 'flatlay', label: 'Tote Navy Wanted', isPhotoRef: true, forSku: '21BG97.SO', description: 'navy WANTED tote bag product shot, sunset stripe gradient, handles up' },
            { folder: 'tote', file: 'Tote_Product_Olive_Discipline.png', type: 'flatlay', label: 'Tote Olive Disc', isPhotoRef: true, forSku: '21BG97.SO', description: 'olive DISCIPLINE IS NOT A DIRTY WORD tote bag product shot, handles up' },

            // === TOTE BAG ON-MODEL SHOTS ===
            // Black refs = 3/4 body (cropped at mid-thigh), Olive refs = full body (feet visible)
            { folder: 'tote', file: 'Tote_Model_Black_Shoulder.png', type: 'on-model', poseType: '3/4', label: 'Tote Shoulder Blk', isPhotoRef: true, forSku: '21BG97.SO', description: '3/4 BODY CROP (mid-thigh), tote over shoulder, white t-shirt, black pants, dynamic pose with leg raised, light gray backdrop' },
            { folder: 'tote', file: 'Tote_Model_Black_Side.png', type: 'on-model', poseType: '3/4', label: 'Tote Side Blk', isPhotoRef: true, forSku: '21BG97.SO', description: '3/4 BODY CROP (mid-thigh), tote held at side by handles, white t-shirt, black pants, light gray backdrop' },
            { folder: 'tote', file: 'Tote_Model_Olive_Shoulder.png', type: 'on-model', poseType: '3/4', label: 'Tote Shoulder Olv', isPhotoRef: true, forSku: '21BG97.SO', description: 'FULL BODY with feet visible, tote over shoulder, white t-shirt, black pants, white sneakers, light gray backdrop' },
            { folder: 'tote', file: 'Tote_Model_Olive_Side.png', type: 'on-model', poseType: '3/4', label: 'Tote Side Olv', isPhotoRef: true, forSku: '21BG97.SO', description: 'FULL BODY with feet visible, tote held at side by handles, white t-shirt, black pants, white sneakers, light gray backdrop' },

            // === MODEL SHOTS - TOPS (on-model with poseType) ===
            // Front pose refs
            { folder: 'model', file: 'Tank_Front_White_01.png', type: 'on-model', poseType: 'front', label: 'Tank Front', isPhotoRef: true, description: 'model wearing white tank top, front view waist up' },
            { folder: 'model', file: 'Henley_Front_Grey_01.png', type: 'on-model', poseType: 'front', label: 'Henley Front', isPhotoRef: true, description: 'model wearing grey henley shirt, front view' },
            { folder: 'model', file: 'Shirt_Front_Turquoise_01.png', type: 'on-model', poseType: 'front', label: 'Shirt Front', isPhotoRef: true, description: 'model wearing turquoise shirt, front view' },
            { folder: 'model', file: 'Sweatshirt_Front_DAD_Grey_01.png', type: 'on-model', poseType: 'front', label: 'Sweat DAD Grey', isPhotoRef: true, description: 'model wearing grey DAD sweatshirt, front view' },
            { folder: 'model', file: 'Sweatshirt_Front_DAD_Navy_02.png', type: 'on-model', poseType: 'front', label: 'Sweat DAD Navy', isPhotoRef: true, description: 'model wearing navy DAD sweatshirt, front view' },
            { folder: 'model', file: 'Tshirt_Front_OliveWhite_01.png', type: 'on-model', poseType: 'front', label: 'Tee Olive Front', isPhotoRef: true, description: 'model wearing olive/white t-shirt, front view' },
            // 3/4 pose refs
            { folder: 'model', file: 'Tank_Side_White_01.png', type: 'on-model', poseType: '3/4', label: 'Tank Side', isPhotoRef: true, description: 'model wearing white tank top, side profile view' },
            { folder: 'model', file: 'Henley_Side_Grey_01.png', type: 'on-model', poseType: '3/4', label: 'Henley Side', isPhotoRef: true, description: 'model wearing grey henley, side view' },
            { folder: 'model', file: 'Sweatshirt_Side_DAD_Grey_01.png', type: 'on-model', poseType: '3/4', label: 'Sweat Side Grey', isPhotoRef: true, description: 'model wearing grey DAD sweatshirt, side view' },
            { folder: 'model', file: 'Sweatshirt_Side_DAD_Navy_01.png', type: 'on-model', poseType: '3/4', label: 'Sweat Side Navy', isPhotoRef: true, description: 'model wearing navy DAD sweatshirt, side view' },
            { folder: 'model', file: 'Tshirt_Side_OliveWhite_01.png', type: 'on-model', poseType: '3/4', label: 'Tee Olive Side', isPhotoRef: true, description: 'model wearing olive/white t-shirt, side view' },

            // === MODEL SHOTS - SHORTS (on-model with poseType) ===
            // Front pose refs
            { folder: 'model', file: 'Shorts_Back_Black_01.png', type: 'on-model', poseType: 'front', label: 'Shorts Black Back', isPhotoRef: true, description: 'model wearing black shorts, back view' },
            { folder: 'model', file: 'Shorts_Front_Navy_02.png', type: 'on-model', poseType: 'front', label: 'Shorts Navy 2', isPhotoRef: true, description: 'model wearing navy shorts, alternate front view' },
            { folder: 'model', file: 'Shorts_HandInPocket_Navy_01.png', type: 'on-model', poseType: 'front', label: 'Shorts Pocket', isPhotoRef: true, description: 'model with hand in pocket wearing navy shorts' },
            { folder: 'model', file: 'Shorts_Front_Olive_01.png', type: 'on-model', poseType: 'front', label: 'Shorts Olive', isPhotoRef: true, description: 'model wearing olive shorts, front view' },
            { folder: 'model', file: 'Shorts_Front_Pink_01.png', type: 'on-model', poseType: 'front', label: 'Shorts Pink', isPhotoRef: true, description: 'model wearing pink shorts, front view' },
            { folder: 'model', file: 'Shorts_ArmsCrossed_Turquoise_01.png', type: 'on-model', poseType: 'front', label: 'Shorts Turquoise', isPhotoRef: true, description: 'model with arms crossed wearing turquoise shorts' },
            // 3/4 pose refs
            { folder: 'model', file: 'Shorts_Front_Black_01.png', type: 'on-model', poseType: '3/4', label: 'Shorts Black', isPhotoRef: true, description: 'model wearing black shorts, front view full body' },
            { folder: 'model', file: 'Shorts_Front_Navy_01.png', type: 'on-model', poseType: '3/4', label: 'Shorts Navy 1', isPhotoRef: true, description: 'model wearing navy shorts, front view' },
            { folder: 'model', file: 'Shorts_Side_Navy_01.png', type: 'on-model', poseType: '3/4', label: 'Shorts Navy Side', isPhotoRef: true, description: 'model wearing navy shorts, side view' },
            { folder: 'model', file: 'Shorts_Back_Pink_01.png', type: 'on-model', poseType: '3/4', label: 'Shorts Pink Back', isPhotoRef: true, description: 'model wearing pink shorts, back view' },
            { folder: 'model', file: 'Shorts_Side_Turquoise_01.png', type: 'on-model', poseType: '3/4', label: 'Shorts Turq Side', isPhotoRef: true, description: 'model wearing turquoise shorts, side view' },

            // === MODEL SHOTS - UNDERWEAR (on-model with poseType) ===
            // Front pose refs
            { folder: 'model', file: 'Underwear_Front_OliveGreen_01.png', type: 'on-model', poseType: 'front', label: 'Underwear Olive', isPhotoRef: true, description: 'model wearing olive green underwear, front view' },
            { folder: 'model', file: 'Underwear_Front_StripedGreen_01.png', type: 'on-model', poseType: 'front', label: 'Underwear Striped', isPhotoRef: true, description: 'model wearing striped green underwear, front view' },
            { folder: 'model', file: 'Underwear_ArmsCrossed_Brown_01.png', type: 'on-model', poseType: 'front', label: 'Underwear Brown', isPhotoRef: true, description: 'model arms crossed wearing brown underwear' },
            // 3/4 pose refs
            { folder: 'model', file: 'Underwear_Side_OliveGreen_01.png', type: 'on-model', poseType: '3/4', label: 'Underwear Olive Side', isPhotoRef: true, description: 'model wearing olive green underwear, side view' },
            { folder: 'model', file: 'Underwear_Side_StripedGreen_01.png', type: 'on-model', poseType: '3/4', label: 'Underwear Str Side', isPhotoRef: true, description: 'model wearing striped green underwear, side view' },
            { folder: 'model', file: 'Underwear_Side_Brown_01.png', type: 'on-model', poseType: '3/4', label: 'Underwear Br Side', isPhotoRef: true, description: 'model wearing brown underwear, side view' },

            // === MODEL SHOTS - COMBOS (Tank + Underwear) (on-model with poseType) ===
            // Front pose refs
            { folder: 'model', file: 'TankUnderwear_Front_White_01.png', type: 'on-model', poseType: 'front', label: 'Tank+Under White', isPhotoRef: true, description: 'model wearing white tank and underwear, front view' },
            { folder: 'model', file: 'TankUnderwear_Front_Olive_01.png', type: 'on-model', poseType: 'front', label: 'Tank+Under Olive', isPhotoRef: true, description: 'model wearing olive tank and underwear, front view' },
            { folder: 'model', file: 'TankUnderwear_Front_Pink_02.png', type: 'on-model', poseType: 'front', label: 'Tank+Under Pink', isPhotoRef: true, description: 'model wearing pink tank and underwear, front view' },
            { folder: 'model', file: 'TankUnderwear_Front_StripedWhite_01.png', type: 'on-model', poseType: 'front', label: 'Tank+Under Stripe', isPhotoRef: true, description: 'model wearing striped tank and white underwear, front' },
            // 3/4 pose refs
            { folder: 'model', file: 'TankUnderwear_Side_White_01.png', type: 'on-model', poseType: '3/4', label: 'Tank+Under Wh Side', isPhotoRef: true, description: 'model wearing white tank and underwear, side view' },
            { folder: 'model', file: 'TankUnderwear_Side_Olive_01.png', type: 'on-model', poseType: '3/4', label: 'Tank+Under Ol Side', isPhotoRef: true, description: 'model wearing olive tank and underwear, side view' },
            { folder: 'model', file: 'TankUnderwear_Side_Pink_01.png', type: 'on-model', poseType: '3/4', label: 'Tank+Under Pk Side', isPhotoRef: true, description: 'model wearing pink tank and underwear, side view' },
            { folder: 'model', file: 'TankUnderwear_Side_StripedWhite_01.png', type: 'on-model', poseType: '3/4', label: 'Tank+Under St Side', isPhotoRef: true, description: 'model wearing striped tank and white underwear, side' },

            // === MODEL SHOTS - COMBOS (Other) (on-model with poseType) ===
            // Front pose refs
            { folder: 'model', file: 'TshirtShorts_ArmsCrossed_Navy_01.png', type: 'on-model', poseType: 'front', label: 'Tee+Shorts Navy', isPhotoRef: true, description: 'model arms crossed wearing navy t-shirt and shorts' },
            { folder: 'model', file: 'SweatshirtShorts_ArmsCrossed_Purple_01.png', type: 'on-model', poseType: 'front', label: 'Sweat+Shorts Purp', isPhotoRef: true, description: 'model arms crossed wearing purple sweatshirt and shorts' },
            // 3/4 pose refs
            { folder: 'model', file: 'TshirtShorts_Side_Navy_01.png', type: 'on-model', poseType: '3/4', label: 'Tee+Shorts Side', isPhotoRef: true, description: 'model wearing navy t-shirt and shorts, side view' },
            { folder: 'model', file: 'SweatshirtShorts_Side_Purple_01.png', type: 'on-model', poseType: '3/4', label: 'Sweat+Shorts Side', isPhotoRef: true, description: 'model wearing purple sweatshirt and shorts, side view' },

            // === ACCESSORIES ===
            { folder: 'accessories', file: 'Cap_Front_DAD_Pink_01.png', type: 'flat_lay', label: 'Pink Cap', isPhotoRef: true, description: 'pink DAD cap on model, front view' },
            { folder: 'accessories', file: 'Cap_Side_Pink_01.png', type: 'flat_lay', label: 'Cap Side', isPhotoRef: true, description: 'pink DAD cap on model, side profile' },
            { folder: 'accessories', file: 'ToteBag_Hand_Olive_01.png', type: 'flat_lay', label: 'Olive Tote', isPhotoRef: true, description: 'model holding olive tote bag at side' },
            { folder: 'accessories', file: 'ToteBag_Shoulder_Olive_01.png', type: 'flat_lay', label: 'Tote Shoulder', isPhotoRef: true, description: 'model with olive tote bag on shoulder' },
            { folder: 'accessories', file: 'ToteBag_Hand_Black_01.png', type: 'flat_lay', label: 'Black Tote', isPhotoRef: true, description: 'model holding black tote bag at side' },
            { folder: 'accessories', file: 'ToteBag_Shoulder_Black_01.png', type: 'flat_lay', label: 'Tote Black', isPhotoRef: true, description: 'model with black tote bag on shoulder' }
        ];

        const ALL_IMAGES = [
            '21bg97.so_2.jpg', '21bg97.so_back.jpg', '21bg97.so_clean.jpg', '21bg97.so_eyelet.jpg', '21bg97.so_front.jpg', '21bg97.so_print.jpg',
            '21ca653dd.so_2.jpg', '21ca653dd.so_3.jpg', '21ca653dd.so_back.jpg', '21ca653dd.so_eyelet.jpg', '21ca653dd.so_front.jpg',
            '21sr20dd.so_2.jpg', '21sr20dd.so_3.jpg', '21sr20dd.so_back.jpg', '21sr20dd.so_belt.jpg', '21sr20dd.so_eyelet.jpg', '21sr20dd.so_front.jpg',
            '21sr21b.s_2.jpg', '21sr21b.s_back.jpg', '21sr21b.s_belt.jpg', '21sr21b.s_eyelet.jpg', '21sr21b.s_front.jpg',
            '21sr23dd.so_back.jpg', '21sr23dd.so_belt.jpg', '21sr23dd.so_eyelet.jpg', '21sr23dd.so_front.jpg',
            '21ss20.rw_back.jpg', '21ss20.rw_belt.jpg', '21ss20.rw_belt_2.jpg', '21ss20.rw_eyelet.jpg', '21ss20.rw_front.jpg',
            '21ss21.be_2.jpg', '21ss21.be_back.jpg', '21ss21.be_belt.jpg', '21ss21.be_belt_2.jpg', '21ss21.be_eyelet.jpg', '21ss21.be_front.jpg', '21ss21.be_pocket.jpg',
            '21sw2019.so_back.jpg', '21sw2019.so_collar.jpg', '21sw2019.so_eyelet.jpg', '21sw2019.so_fabrics.jpg', '21sw2019.so_front.jpg', '21sw2019.so_sleeves.jpg',
            '21tk189.rw_back.jpg', '21tk189.rw_collar.jpg', '21tk189.rw_eyelet.jpg', '21tk189.rw_front.jpg', '21tk189.rw_sleeves.jpg', '21tk189.rw_sleeves_2.jpg',
            '21ts1115dd.so_back.jpg', '21ts1115dd.so_collar.jpg', '21ts1115dd.so_fabrics.jpg', '21ts1115dd.so_front.jpg', '21ts1115dd.so_sleeves.jpg',
            '21ts1267.so_back.jpg', '21ts1267.so_collar.jpg', '21ts1267.so_fabrics.jpg', '21ts1267.so_front.jpg', '21ts1267.so_print.jpg', '21ts1267.so_sleeves.jpg',
            '21ts1505.rw_2.jpg', '21ts1505.rw_back.jpg', '21ts1505.rw_buttons.jpg', '21ts1505.rw_collar.jpg', '21ts1505.rw_eyelet.jpg', '21ts1505.rw_fabrics.jpg', '21ts1505.rw_front.jpg', '21ts1505.rw_sleeves.jpg', '21ts1505.rw_sleeves_2.jpg',
            '21ur30.w_2.jpg', '21ur30.w_back.jpg', '21ur30.w_eyelet.jpg', '21ur30.w_front.jpg',
            '21ur42.w_2.jpg', '21ur42.w_back.jpg', '21ur42.w_eyelet.jpg', '21ur42.w_front.jpg'
        ];

        // ========== STATE ==========
        let imageAnalysis = {}; // Loaded from JSON
        let selectedProductIndex = null;
        let categoryState = {}; // { shotType: { guide: null, selectedImages: [], results: [] } }

        // Pose view state
        let viewMode = 'productsV3'; // 'products', 'productsV2', 'productsV3', or 'poses'
        let selectedPose = null;
        let poseState = {}; // { `${productIndex}_${shotType}`: { expanded, selectedImages, selectedModels, selectedFootwear } }

        // Products V2 state
        let selectedV2ShotType = null;
        let productV2State = {}; // { `${productIndex}_${shotType}`: { expanded, selectedImages, selectedGuides, noneGuideSelected } }
        const V2_SHOT_TYPES = ['flatlay', 'eyelet', 'collar', 'fabrics', 'belt', 'print']; // Shot types for V2

        // Products V3 state (similar to V2 but with new settings)
        let selectedV3ShotType = null;
        let productV3State = {}; // { `${productIndex}_${shotType}`: { expanded, selectedImages, selectedGuides, noneGuideSelected } }
        const V3_SHOT_TYPES = ['flatlay', 'eyelet', 'collar', 'fabrics', 'belt', 'print', 'on-model']; // Shot types for V3
        let settingsV3 = { aspect: '3:4', resolution: '2K', seeds: 1, provider: 'nano-pro' };

        // V3 Prompts loaded from JSON files
        let LOADED_PROMPTS_V3 = {};

        // Load all V3 product prompts from JSON files
        async function loadProductPromptsV3() {
            const skus = PRODUCTS.map(p => p.sku);
            const promptsDir = '/assets/brand/rondorff/prompts-v3';

            console.log('ðŸ“‚ Loading V3 product prompts...');

            for (const sku of skus) {
                try {
                    const response = await fetch(`${promptsDir}/${sku}.json`);
                    if (!response.ok) continue;
                    const contentType = response.headers.get('content-type');
                    if (!contentType || !contentType.includes('application/json')) continue;
                    const data = await response.json();
                    LOADED_PROMPTS_V3[sku] = data.prompts;
                    console.log(`âœ“ Loaded V3 prompts for ${sku} (${Object.keys(data.prompts).length} shot types)`);
                } catch (err) {
                    // Silently ignore - V3 prompts are optional, falls back to V2
                }
            }

            console.log(`ðŸ“‚ Loaded V3 prompts for ${Object.keys(LOADED_PROMPTS_V3).length}/${skus.length} products`);
        }

        // Get V3 prompt - falls back to V2 if V3 not available
        function getPromptOverrideV3(sku, shotType, guideType) {
            // Try V3 first
            const v3Prompts = LOADED_PROMPTS_V3[sku];
            if (v3Prompts) {
                if (guideType) {
                    const guideKey = `${shotType}_${guideType}`;
                    if (v3Prompts[guideKey]) return v3Prompts[guideKey];
                }
                if (v3Prompts[shotType]) return v3Prompts[shotType];
            }

            // Fall back to V2
            return getPromptOverrideV2(sku, shotType, guideType);
        }

        // Build V3 prompt with template variable replacement (same as V2)
        function buildPromptV3(shotType, product, selectedImages, guideInfo = null) {
            const sku = product.sku;
            const guideType = guideInfo?.isPhotoRef ? 'photo' : (guideInfo ? 'canny' : null);

            // Get prompt template
            let prompt = getPromptOverrideV3(sku, shotType, guideType);

            if (!prompt) {
                // Generic fallback for V3
                prompt = `E-commerce ${shotType} photograph.\n\nIMAGE ORDER:\n- Images 1+: Product photos - use for color and details\n${guideInfo ? '- LAST image: Composition reference - COPY THIS EXACTLY\n' : ''}\nPRODUCT: {{productColor}} {{shortProductName}}\n\nCRITICAL: Match product colors exactly from input images. Clean, crisp presentation.\n\nLIGHTING & BACKGROUND: Light gray studio backdrop. Bright, even lighting.`;
            }

            // Replace template variables
            const shortName = product.name.split(' ').slice(0, 3).join(' ');
            prompt = prompt
                .replace(/\{\{productColor\}\}/g, product.color)
                .replace(/\{\{shortProductName\}\}/g, shortName)
                .replace(/\{\{productName\}\}/g, product.name)
                .replace(/\{\{material\}\}/g, product.material)
                .replace(/\{\{sku\}\}/g, product.sku);

            // Add guide description if present
            if (guideInfo?.description) {
                prompt = prompt.replace(/\{\{guideDescription\}\}/g, guideInfo.description);
            }

            return prompt;
        }

        // Get all unique shot types across all products
        function getAllShotTypes() {
            const types = new Set();
            PRODUCTS.forEach(p => p.shotTypes.forEach(t => types.add(t)));
            return Array.from(types);
        }

        // Get products that have a specific shot type
        function getProductsForShotType(shotType) {
            return PRODUCTS.map((p, i) => ({ ...p, index: i }))
                .filter(p => p.shotTypes.includes(shotType));
        }

        // Set view mode
        function setViewMode(mode) {
            viewMode = mode;
            document.querySelectorAll('.view-mode-toggle button').forEach(btn => {
                const btnMode = btn.textContent.toLowerCase().replace(' ', '').replace('v', 'v');
                const modeMatch = mode.toLowerCase();
                // Handle button text matching for Products V1, V2, V3
                const isMatch = btnMode === modeMatch ||
                    (btn.textContent === 'Products V1' && mode === 'products') ||
                    (btn.textContent === 'Products V2' && mode === 'productsV2') ||
                    (btn.textContent === 'Products V3' && mode === 'productsV3') ||
                    (btn.textContent === 'Poses' && mode === 'poses');
                btn.classList.toggle('active', isMatch);
            });
            document.getElementById('product-view').style.display = mode === 'products' ? 'block' : 'none';
            document.getElementById('product-v2-view').style.display = mode === 'productsV2' ? 'block' : 'none';
            document.getElementById('product-v3-view').style.display = mode === 'productsV3' ? 'block' : 'none';
            document.getElementById('pose-view').style.display = mode === 'poses' ? 'block' : 'none';
            // Also toggle selected-product-area visibility (it's outside product-view)
            document.getElementById('selected-product-area').style.display = mode === 'products' ? 'block' : 'none';
            // Hide V1/V2 settings bar when in V3 mode (V3 has its own settings at the top)
            document.getElementById('v1v2-settings-bar').style.display = (mode === 'products' || mode === 'productsV2') ? 'flex' : 'none';

            if (mode === 'productsV2') {
                renderProductV2Selector();
                if (!selectedV2ShotType) {
                    selectV2ShotType('flatlay');
                } else {
                    renderProductV2Products();
                }
            }

            if (mode === 'productsV3') {
                renderProductV3Selector();
                if (!selectedV3ShotType) {
                    selectV3ShotType('flatlay');
                } else {
                    renderProductV3Products();
                }
            }

            if (mode === 'poses') {
                renderPoseSelector();
                if (!selectedPose) {
                    // Default to 3/4 since that's what user mentioned
                    selectPose('3/4');
                } else {
                    renderPoseProducts();
                }
            }
        }

        // Render pose selector tabs
        function renderPoseSelector() {
            const container = document.getElementById('pose-selector');
            const allTypes = getAllShotTypes();

            let html = '';
            allTypes.forEach(type => {
                const count = getProductsForShotType(type).length;
                const selected = selectedPose === type ? 'selected' : '';
                const displayName = type.replace('_', ' ');
                html += `<div class="pose-tab ${selected}" onclick="selectPose('${type}')">${displayName}<span class="count">(${count})</span></div>`;
            });
            container.innerHTML = html;
        }

        // Select a pose
        function selectPose(pose) {
            selectedPose = pose;
            // Don't reset state - preserve selections when switching poses
            renderPoseSelector();
            renderPoseProducts();
        }

        // Render products for selected pose
        function renderPoseProducts() {
            const container = document.getElementById('pose-products-area');
            if (!selectedPose) {
                container.innerHTML = '<div class="no-product-selected">Select a pose above</div>';
                return;
            }

            const products = getProductsForShotType(selectedPose);
            const shotType = selectedPose;
            const needsModel = SHOT_TYPES_WITH_MODELS.includes(shotType);

            // Initialize state for each product
            products.forEach(product => {
                const stateKey = `${product.index}_${shotType}`;
                if (!poseState[stateKey]) {
                    const productImages = getProductImages(product.sku);
                    const canUseFootwear = shotType === 'on-model' && CATEGORIES_WITH_FOOTWEAR.includes(product.category);
                    const canUseBottoms = shotType === 'on-model' && CATEGORIES_WITH_BOTTOMS.includes(product.category);
                    const canUseTops = shotType === 'on-model' && CATEGORIES_WITH_TOPS.includes(product.category);
                    poseState[stateKey] = {
                        expanded: true, // Start expanded
                        selectedImages: productImages.map((_, i) => i < 2), // Auto-select first 2
                        selectedModels: needsModel ? MODEL_PORTRAITS.map((_, i) => i === 0) : [],
                        selectedFootwear: canUseFootwear ? FOOTWEAR.map(() => false) : [],
                        selectedBottoms: canUseBottoms ? BOTTOMS.map(() => false) : [],
                        selectedTops: canUseTops ? TOPS.map(() => false) : [],
                        selectedGuides: [],
                        noneGuideSelected: false, // Default to NOT generate without guide
                        poseModes: needsModel ? { copy: true, dynamic: false } : null // Pose mode for model shots
                    };
                }
            });

            // Count total tasks based on all multipliers (models, pose modes, guides)
            const seeds = parseInt(document.querySelector('#seeds-buttons .active')?.dataset.value || '1');
            let totalImages = 0;

            products.forEach(p => {
                const stateKey = `${p.index}_${shotType}`;
                const state = poseState[stateKey];
                if (!state?.selectedImages?.some(Boolean)) return; // Skip products without selections

                // Count selected models (default to 1 if none selected for model shots)
                const selectedModelCount = needsModel
                    ? Math.max(1, (state.selectedModels?.filter(Boolean).length || 0))
                    : 1;

                // Count selected pose modes (default to 1 if none selected)
                const selectedPoseModeCount = needsModel && state.poseModes
                    ? Math.max(1, [state.poseModes.copy, state.poseModes.dynamic].filter(Boolean).length)
                    : 1;

                // Count selected guides (None counts as 1 if selected)
                const relevantGuides = getRelevantGuides(shotType, p);
                const selectedGuideCount = state.selectedGuides?.filter(Boolean).length || 0;
                const guideMultiplier = (state.noneGuideSelected ? 1 : 0) + selectedGuideCount;
                const effectiveGuideMultiplier = Math.max(1, guideMultiplier);

                // Multiply: models x poseModes x guides x seeds
                if (needsModel) {
                    totalImages += selectedModelCount * selectedPoseModeCount * effectiveGuideMultiplier * seeds;
                } else {
                    totalImages += effectiveGuideMultiplier * seeds;
                }
            });

            const selectedCount = products.filter(p => {
                const stateKey = `${p.index}_${shotType}`;
                return poseState[stateKey]?.selectedImages?.some(Boolean);
            }).length;

            let html = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--space-sm); padding: var(--space-sm); background: var(--white); border: 1px solid var(--jet);">
                    <div>
                        <strong>${shotType.replace('_', ' ').toUpperCase()}</strong> - ${selectedCount}/${products.length} products ready
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button onclick="deselectAllPoseProducts()" style="padding: 4px 12px; font-size: 11px;">Deselect All</button>
                        <button onclick="expandAllPoseProducts(true)" style="padding: 4px 12px; font-size: 11px;">Expand All</button>
                        <button onclick="expandAllPoseProducts(false)" style="padding: 4px 12px; font-size: 11px;">Collapse All</button>
                        <button onclick="generateSelectedPoseProducts()" style="padding: 6px 16px; font-size: 12px; background: var(--jet); color: white; font-weight: 500;">Generate All (${totalImages} images)</button>
                    </div>
                </div>
            `;

            products.forEach(product => {
                const stateKey = `${product.index}_${shotType}`;
                const state = poseState[stateKey];
                const productImages = getProductImages(product.sku);
                const frontImg = getFrontImage(product.sku);
                const hasSelection = state.selectedImages.some(Boolean);
                const expandedClass = state.expanded ? 'expanded' : '';
                const selectedClass = hasSelection ? 'selected' : '';
                const canUseFootwear = shotType === 'on-model' && CATEGORIES_WITH_FOOTWEAR.includes(product.category);
                const canUseBottoms = shotType === 'on-model' && CATEGORIES_WITH_BOTTOMS.includes(product.category);
                const canUseTops = shotType === 'on-model' && CATEGORIES_WITH_TOPS.includes(product.category);

                // Get relevant photo references for this shot type AND product
                const relevantGuides = getRelevantGuides(shotType, product);
                const photoRefs = relevantGuides.filter(g => g.isPhotoRef);

                // Initialize selectedGuides if not exists or length changed
                if (!state.selectedGuides || state.selectedGuides.length !== relevantGuides.length) {
                    state.selectedGuides = relevantGuides.map(() => false);
                }

                // Model images for portrait shots
                const modelImagesHtml = needsModel ? MODEL_PORTRAITS.map((model, i) => `
                    <div class="pose-image-option ${state.selectedModels[i] ? 'selected' : ''}"
                         onclick="event.stopPropagation(); togglePoseModelImage(${product.index}, '${shotType}', ${i})" title="${model.name}">
                        <img src="${model.thumb}" alt="${model.name}">
                        <span class="check">âœ“</span>
                        <span style="position: absolute; bottom: 2px; left: 2px; width: 14px; height: 14px; background: #3b82f6; color: white; font-size: 8px; font-weight: 700; display: flex; align-items: center; justify-content: center;">M</span>
                    </div>
                `).join('') : '';

                // Footwear images
                const footwearImagesHtml = canUseFootwear ? FOOTWEAR.map((shoe, i) => `
                    <div class="pose-image-option ${state.selectedFootwear[i] ? 'selected' : ''}"
                         onclick="event.stopPropagation(); togglePoseFootwearImage(${product.index}, '${shotType}', ${i})" title="${shoe.name}">
                        <img src="${shoe.thumb}" alt="${shoe.name}">
                        <span class="check">âœ“</span>
                        <span style="position: absolute; bottom: 2px; left: 2px; width: 14px; height: 14px; background: #8b5cf6; color: white; font-size: 8px; font-weight: 700; display: flex; align-items: center; justify-content: center;">F</span>
                    </div>
                `).join('') : '';

                // Bottoms images (pants/shorts for tops)
                const bottomsImagesHtml = canUseBottoms ? BOTTOMS.map((bottom, i) => `
                    <div class="pose-image-option ${state.selectedBottoms?.[i] ? 'selected' : ''}"
                         onclick="event.stopPropagation(); togglePoseBottomsImage(${product.index}, '${shotType}', ${i})" title="${bottom.name}">
                        <img src="${bottom.thumb}" alt="${bottom.name}">
                        <span class="check">âœ“</span>
                        <span style="position: absolute; bottom: 2px; left: 2px; width: 14px; height: 14px; background: #10b981; color: white; font-size: 8px; font-weight: 700; display: flex; align-items: center; justify-content: center;">B</span>
                    </div>
                `).join('') : '';

                // Tops images (t-shirts for accessories)
                const topsImagesHtml = canUseTops ? TOPS.map((top, i) => `
                    <div class="pose-image-option ${state.selectedTops?.[i] ? 'selected' : ''}"
                         onclick="event.stopPropagation(); togglePoseTopsImage(${product.index}, '${shotType}', ${i})" title="${top.name}">
                        <img src="${top.thumb}" alt="${top.name}">
                        <span class="check">âœ“</span>
                        <span style="position: absolute; bottom: 2px; left: 2px; width: 14px; height: 14px; background: #f59e0b; color: white; font-size: 8px; font-weight: 700; display: flex; align-items: center; justify-content: center;">T</span>
                    </div>
                `).join('') : '';

                // Photo references for this shot type
                // For on-model shots, group by poseType (Front / 3/4) and no None option
                // For other shot types, show None option and flat list
                const noneSelected = state.noneGuideSelected || false;
                const isOnModelShot = shotType === 'on-model';

                let photoRefsHtml = '';
                if (isOnModelShot && photoRefs.length > 0) {
                    // Group refs by poseType
                    const frontRefs = photoRefs.filter(g => g.poseType === 'front');
                    const threeQuarterRefs = photoRefs.filter(g => g.poseType === '3/4');

                    const renderRefGroup = (refs, groupLabel) => refs.length > 0 ? `
                        <div style="margin-bottom: 6px;">
                            <div style="font-size: 10px; color: #666; margin-bottom: 3px;">${groupLabel}:</div>
                            <div class="pose-product-images-row">
                                ${refs.map((guide) => {
                                    const globalIndex = relevantGuides.indexOf(guide);
                                    const photoRefPath = guide.folder === 'canny'
                                        ? '/assets/brand/rondorff/canny/refs/' + guide.file
                                        : '/assets/brand/rondorff/refs/' + guide.folder + '/' + guide.file;
                                    return `
                                        <div class="pose-image-option ${state.selectedGuides[globalIndex] ? 'selected' : ''}"
                                             onclick="togglePoseGuide(${product.index}, '${shotType}', ${globalIndex})" title="${guide.label}">
                                            <img src="${photoRefPath}" alt="${guide.label}">
                                            <span class="check">âœ“</span>
                                            <span style="position: absolute; bottom: 2px; left: 2px; width: 14px; height: 14px; background: #f59e0b; color: white; font-size: 8px; font-weight: 700; display: flex; align-items: center; justify-content: center;">R</span>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    ` : '';

                    photoRefsHtml = `
                        <div style="margin-top: 8px;">
                            <div style="font-size: 10px; color: #666; margin-bottom: 4px; font-weight: 600;">Photo References:</div>
                            ${renderRefGroup(frontRefs, 'Front')}
                            ${renderRefGroup(threeQuarterRefs, '3/4')}
                        </div>
                    `;
                } else if (photoRefs.length > 0) {
                    // Non-model shots - show None option and flat list
                    photoRefsHtml = `
                        <div style="margin-top: 8px;">
                            <div style="font-size: 10px; color: #666; margin-bottom: 4px;">Photo References:</div>
                            <div class="pose-product-images-row">
                                <div class="pose-image-option ${noneSelected ? 'selected' : ''}"
                                     onclick="togglePoseNoneGuide(${product.index}, '${shotType}')" title="Generate without guide" style="display: flex; align-items: center; justify-content: center; background: #f5f5f5; min-width: 48px; min-height: 48px;">
                                    <span style="font-size: 10px; font-weight: 600; color: #666;">None</span>
                                    <span class="check">âœ“</span>
                                </div>
                                ${photoRefs.map((guide, i) => {
                                    const globalIndex = relevantGuides.indexOf(guide);
                                    const photoRefPath = guide.folder === 'canny'
                                        ? '/assets/brand/rondorff/canny/refs/' + guide.file
                                        : '/assets/brand/rondorff/refs/' + guide.folder + '/' + guide.file;
                                    return `
                                        <div class="pose-image-option ${state.selectedGuides[globalIndex] ? 'selected' : ''}"
                                             onclick="togglePoseGuide(${product.index}, '${shotType}', ${globalIndex})" title="${guide.label}">
                                            <img src="${photoRefPath}" alt="${guide.label}">
                                            <span class="check">âœ“</span>
                                            <span style="position: absolute; bottom: 2px; left: 2px; width: 14px; height: 14px; background: #f59e0b; color: white; font-size: 8px; font-weight: 700; display: flex; align-items: center; justify-content: center;">R</span>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    `;
                }

                // Pose mode toggle for model shots
                const poseModeHtml = needsModel && state.poseModes ? `
                    <div class="pose-mode-toggle" style="display: flex; gap: 2px; margin-right: 8px;" onclick="event.stopPropagation();">
                        <button class="pose-mode-btn ${state.poseModes.copy ? 'active' : ''}" onclick="togglePosePoseMode(${product.index}, '${shotType}', 'copy')" style="padding: 4px 8px; font-size: 10px; ${state.poseModes.copy ? 'background: var(--jet); color: white;' : ''}">Copy</button>
                        <button class="pose-mode-btn ${state.poseModes.dynamic ? 'active' : ''}" onclick="togglePosePoseMode(${product.index}, '${shotType}', 'dynamic')" style="padding: 4px 8px; font-size: 10px; ${state.poseModes.dynamic ? 'background: var(--jet); color: white;' : ''}">Dynamic</button>
                    </div>
                ` : '';

                html += `
                    <div class="pose-product-card ${expandedClass} ${selectedClass}">
                        <div class="pose-product-header" onclick="togglePoseProductExpand(${product.index}, '${shotType}')">
                            <img class="pose-product-thumb" src="/assets/brand/rondorff/ecom/thumbs/${frontImg}" alt="${product.name}">
                            <div class="pose-product-info">
                                <div class="pose-product-name">${product.name}</div>
                                <div class="pose-product-sku">${product.sku} â€¢ ${product.color} â€¢ ${state.selectedImages.filter(Boolean).length}/${productImages.length} images</div>
                            </div>
                            <div class="pose-product-actions">
                                ${poseModeHtml}
                                <button onclick="event.stopPropagation(); selectAllPoseImages(${product.index}, '${shotType}', true)" style="padding: 4px 8px; font-size: 10px;">All</button>
                                <button onclick="event.stopPropagation(); selectAllPoseImages(${product.index}, '${shotType}', false)" style="padding: 4px 8px; font-size: 10px;">None</button>
                                <button onclick="event.stopPropagation(); generateSinglePoseProduct(${product.index})" style="padding: 4px 12px; font-size: 11px; background: var(--jet); color: white;">Generate</button>
                            </div>
                        </div>
                        <div class="pose-product-images">
                            <div class="pose-product-images-row">
                                ${modelImagesHtml}
                                ${footwearImagesHtml}
                                ${bottomsImagesHtml}
                                ${topsImagesHtml}
                                ${productImages.map((img, i) => `
                                    <div class="pose-image-option ${state.selectedImages[i] ? 'selected' : ''}"
                                         onclick="togglePoseImage(${product.index}, '${shotType}', ${i})" title="${getShotType(img)}">
                                        <img src="/assets/brand/rondorff/ecom/thumbs/${img}" alt="${getShotType(img)}">
                                        <span class="check">âœ“</span>
                                    </div>
                                `).join('')}
                            </div>
                            ${photoRefsHtml}
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        // Toggle product expansion in pose view
        function togglePoseProductExpand(productIndex, shotType) {
            const stateKey = `${productIndex}_${shotType}`;
            if (poseState[stateKey]) {
                poseState[stateKey].expanded = !poseState[stateKey].expanded;
                renderPoseProducts();
            }
        }

        // Expand/collapse all products in pose view
        function expandAllPoseProducts(expand) {
            const products = getProductsForShotType(selectedPose);
            products.forEach(product => {
                const stateKey = `${product.index}_${selectedPose}`;
                if (poseState[stateKey]) {
                    poseState[stateKey].expanded = expand;
                }
            });
            renderPoseProducts();
        }

        // Toggle individual image selection in pose view
        function togglePoseImage(productIndex, shotType, imageIndex) {
            const stateKey = `${productIndex}_${shotType}`;
            if (poseState[stateKey]) {
                poseState[stateKey].selectedImages[imageIndex] = !poseState[stateKey].selectedImages[imageIndex];
                renderPoseProducts();
            }
        }

        // Toggle model image selection in pose view
        function togglePoseModelImage(productIndex, shotType, modelIndex) {
            const stateKey = `${productIndex}_${shotType}`;
            if (poseState[stateKey] && poseState[stateKey].selectedModels) {
                poseState[stateKey].selectedModels[modelIndex] = !poseState[stateKey].selectedModels[modelIndex];
                renderPoseProducts();
            }
        }

        // Toggle footwear image selection in pose view
        function togglePoseFootwearImage(productIndex, shotType, footwearIndex) {
            const stateKey = `${productIndex}_${shotType}`;
            if (poseState[stateKey] && poseState[stateKey].selectedFootwear) {
                poseState[stateKey].selectedFootwear[footwearIndex] = !poseState[stateKey].selectedFootwear[footwearIndex];
                renderPoseProducts();
            }
        }

        // Toggle bottoms selection in pose view (for tops like shirts, tank tops)
        function togglePoseBottomsImage(productIndex, shotType, bottomsIndex) {
            const stateKey = `${productIndex}_${shotType}`;
            if (poseState[stateKey] && poseState[stateKey].selectedBottoms) {
                poseState[stateKey].selectedBottoms[bottomsIndex] = !poseState[stateKey].selectedBottoms[bottomsIndex];
                renderPoseProducts();
            }
        }

        // Toggle tops selection in pose view (for accessories like tote bags)
        function togglePoseTopsImage(productIndex, shotType, topsIndex) {
            const stateKey = `${productIndex}_${shotType}`;
            if (poseState[stateKey] && poseState[stateKey].selectedTops) {
                poseState[stateKey].selectedTops[topsIndex] = !poseState[stateKey].selectedTops[topsIndex];
                renderPoseProducts();
            }
        }

        // Toggle guide/photo reference selection in pose view
        function togglePoseGuide(productIndex, shotType, guideIndex) {
            const stateKey = `${productIndex}_${shotType}`;
            if (poseState[stateKey] && poseState[stateKey].selectedGuides) {
                poseState[stateKey].selectedGuides[guideIndex] = !poseState[stateKey].selectedGuides[guideIndex];
                renderPoseProducts();
            }
        }

        // Toggle "None" guide option in pose view
        function togglePoseNoneGuide(productIndex, shotType) {
            const stateKey = `${productIndex}_${shotType}`;
            if (poseState[stateKey]) {
                poseState[stateKey].noneGuideSelected = !poseState[stateKey].noneGuideSelected;
                renderPoseProducts();
            }
        }

        // Toggle pose mode (copy/dynamic) in pose view
        function togglePosePoseMode(productIndex, shotType, mode) {
            const stateKey = `${productIndex}_${shotType}`;
            if (poseState[stateKey] && poseState[stateKey].poseModes) {
                // Toggle the selected mode (multi-select like in products view)
                poseState[stateKey].poseModes[mode] = !poseState[stateKey].poseModes[mode];
                renderPoseProducts();
            }
        }

        // Select all/none images for a product in pose view
        function selectAllPoseImages(productIndex, shotType, selectAll) {
            const stateKey = `${productIndex}_${shotType}`;
            if (poseState[stateKey]) {
                poseState[stateKey].selectedImages = poseState[stateKey].selectedImages.map(() => selectAll);
                renderPoseProducts();
            }
        }

        // Deselect all products in pose view (images, models, footwear, guides)
        function deselectAllPoseProducts() {
            const products = getProductsForShotType(selectedPose);
            const shotType = selectedPose;
            products.forEach(product => {
                const stateKey = `${product.index}_${shotType}`;
                if (poseState[stateKey]) {
                    poseState[stateKey].selectedImages = poseState[stateKey].selectedImages.map(() => false);
                    if (poseState[stateKey].selectedModels) {
                        poseState[stateKey].selectedModels = poseState[stateKey].selectedModels.map(() => false);
                    }
                    if (poseState[stateKey].selectedFootwear) {
                        poseState[stateKey].selectedFootwear = poseState[stateKey].selectedFootwear.map(() => false);
                    }
                    if (poseState[stateKey].selectedGuides) {
                        poseState[stateKey].selectedGuides = poseState[stateKey].selectedGuides.map(() => false);
                    }
                }
            });
            renderPoseProducts();
        }

        // Generate selected pose for all products with selected images
        async function generateSelectedPoseProducts() {
            const products = getProductsForShotType(selectedPose);
            const shotType = selectedPose;

            // Get products that have at least one image selected
            const productsToGenerate = products.filter(p => {
                const stateKey = `${p.index}_${shotType}`;
                return poseState[stateKey]?.selectedImages?.some(Boolean);
            });

            if (productsToGenerate.length === 0) {
                alert('Please select at least one image for at least one product');
                return;
            }

            // Queue ALL products first (don't process yet), then process everything in parallel
            for (const product of productsToGenerate) {
                // Add tasks to queue without starting processing
                await queuePoseProductTasks(product.index);
            }
            // Now process all queued tasks in parallel
            if (!isProcessingQueue && generationQueue.length > 0) {
                processQueue();
            }
        }

        // Queue tasks for a single product (without starting processing)
        async function queuePoseProductTasks(productIndex) {
            return generateSinglePoseProduct(productIndex, false);
        }

        // Generate pose for a single product
        async function generateSinglePoseProduct(productIndex, startProcessing = true) {
            const product = PRODUCTS[productIndex];
            const shotType = selectedPose;
            const productImages = getProductImages(product.sku);

            // Use the same state key format as renderPoseProducts
            const stateKey = `${productIndex}_${shotType}`;

            // Check if state exists (should be initialized by renderPoseProducts)
            const state = poseState[stateKey];
            if (!state) {
                console.log(`No state for ${product.sku} - ${shotType}. Make sure to view the pose first.`);
                return;
            }

            // Get selected images (filenames)
            const selectedImgs = productImages.filter((_, i) => state.selectedImages[i]);
            if (selectedImgs.length === 0) {
                console.log(`No images selected for ${product.sku} - ${shotType}`);
                return;
            }

            // Determine if this shot type needs models
            const needsModel = SHOT_TYPES_WITH_MODELS.includes(shotType);

            // Get settings from current UI
            const provider = document.querySelector('#provider-buttons .active')?.dataset.value || 'gemini';
            const aspect = document.querySelector('#aspect-buttons .active')?.dataset.value || '3:4';
            const resolution = document.querySelector('#resolution-buttons .active')?.dataset.value || '2K';
            const seeds = parseInt(document.querySelector('#seeds-buttons .active')?.dataset.value || '1');

            // Build settings object matching the products view format
            const taskSettings = {
                aspect,
                resolution,
                seeds,
                provider
            };

            // Get selected models (array of model objects)
            const selectedModels = [];
            if (needsModel && state.selectedModels) {
                state.selectedModels.forEach((selected, i) => {
                    if (selected) selectedModels.push(MODEL_PORTRAITS[i]);
                });
                // Default to first model if none selected
                if (selectedModels.length === 0) selectedModels.push(MODEL_PORTRAITS[0]);
            }

            // Get selected footwear (array of footwear objects)
            const selectedFootwear = [];
            if (state.selectedFootwear) {
                state.selectedFootwear.forEach((selected, i) => {
                    if (selected) selectedFootwear.push(FOOTWEAR[i]);
                });
            }

            // Get selected bottoms (array of bottom objects) - for tops like shirts, tank tops
            const selectedBottoms = [];
            if (state.selectedBottoms) {
                state.selectedBottoms.forEach((selected, i) => {
                    if (selected) selectedBottoms.push(BOTTOMS[i]);
                });
            }

            // Get selected tops (array of top objects) - for accessories like tote bags
            const selectedTops = [];
            if (state.selectedTops) {
                state.selectedTops.forEach((selected, i) => {
                    if (selected) selectedTops.push(TOPS[i]);
                });
            }

            // Get selected guides (from state if available)
            const selectedGuides = [];
            if (state.selectedGuides) {
                const relevantGuides = getRelevantGuides(shotType, product);
                state.selectedGuides.forEach((selected, i) => {
                    if (selected && relevantGuides[i]) selectedGuides.push(relevantGuides[i]);
                });
            }

            // Get selected pose modes from state
            const selectedPoseModes = [];
            if (state.poseModes) {
                if (state.poseModes.copy) selectedPoseModes.push('copy');
                if (state.poseModes.dynamic) selectedPoseModes.push('dynamic');
            }
            // Default to 'copy' if no pose mode selected
            if (selectedPoseModes.length === 0 && needsModel) selectedPoseModes.push('copy');

            // Add tasks to queue - matching the products view format
            // For model shots, create one task per model AND per pose mode
            if (needsModel && selectedModels.length > 0) {
                selectedPoseModes.forEach(poseMode => {
                    selectedModels.forEach(model => {
                        // Add task without guide if noneGuideSelected
                        if (state.noneGuideSelected) {
                            generationQueue.push({
                                shotType,
                                product: { ...product },
                                selectedImgs: [...selectedImgs],
                                selectedModels: [model],
                                selectedFootwear: [...selectedFootwear],
                                selectedBottoms: [...selectedBottoms],
                                selectedTops: [...selectedTops],
                                guide: null,
                                poseMode,
                                settings: { ...taskSettings }
                            });
                        }
                        // Add tasks for each selected guide
                        selectedGuides.forEach(guide => {
                            generationQueue.push({
                                shotType,
                                product: { ...product },
                                selectedImgs: [...selectedImgs],
                                selectedModels: [model],
                                selectedFootwear: [...selectedFootwear],
                                selectedBottoms: [...selectedBottoms],
                                selectedTops: [...selectedTops],
                                guide: { ...guide },
                                poseMode,
                                settings: { ...taskSettings }
                            });
                        });
                    });
                });
            } else {
                // Non-model shots
                if (state.noneGuideSelected || selectedGuides.length === 0) {
                    generationQueue.push({
                        shotType,
                        product: { ...product },
                        selectedImgs: [...selectedImgs],
                        selectedModels: [],
                        selectedFootwear: [],
                        selectedBottoms: [],
                        selectedTops: [],
                        guide: null,
                        poseMode: null,
                        settings: { ...taskSettings }
                    });
                }
                selectedGuides.forEach(guide => {
                    generationQueue.push({
                        shotType,
                        product: { ...product },
                        selectedImgs: [...selectedImgs],
                        selectedModels: [],
                        selectedFootwear: [],
                        selectedBottoms: [],
                        selectedTops: [],
                        guide: { ...guide },
                        poseMode: null,
                        settings: { ...taskSettings }
                    });
                });
            }

            updateQueueStatus();

            // Start processing if not already (and if requested)
            if (startProcessing && !isProcessingQueue) {
                processQueue();
            }
        }

        // ========== PRODUCTS V2 FUNCTIONS ==========

        // Get products that have a specific V2 shot type
        function getProductsForV2ShotType(shotType) {
            return PRODUCTS.map((p, i) => ({ ...p, index: i }))
                .filter(p => p.shotTypes.includes(shotType));
        }

        // Render shot type selector for Products V2
        function renderProductV2Selector() {
            const container = document.getElementById('product-v2-selector');
            let html = '';
            V2_SHOT_TYPES.forEach(type => {
                const count = getProductsForV2ShotType(type).length;
                const selected = selectedV2ShotType === type ? 'selected' : '';
                const displayName = type.replace('_', ' ');
                html += `<div class="pose-tab ${selected}" onclick="selectV2ShotType('${type}')">${displayName}<span class="count">(${count})</span></div>`;
            });
            container.innerHTML = html;
        }

        // Select a shot type for Products V2
        function selectV2ShotType(shotType) {
            selectedV2ShotType = shotType;
            renderProductV2Selector();
            renderProductV2Products();
        }

        // Get relevant guides for V2 shot types (combined canny and photo refs)
        function getV2Guides(shotType, product) {
            // Combine both canny guides and photo references
            const allGuides = [...CANNY_GUIDE_IMAGES, ...PHOTO_REF_IMAGES];

            // Get ALL guides for this shot type (both canny and photo refs)
            return allGuides.filter(g => {
                // Match shot type
                if (g.type !== shotType) return false;
                // If guide has forSku filter, check it matches
                if (g.forSku && g.forSku !== product.sku) return false;
                return true;
            });
        }

        // Render products for selected V2 shot type
        function renderProductV2Products() {
            const container = document.getElementById('product-v2-area');
            if (!selectedV2ShotType) {
                container.innerHTML = '<div class="no-product-selected">Select a shot type above</div>';
                return;
            }

            const products = getProductsForV2ShotType(selectedV2ShotType);
            const shotType = selectedV2ShotType;

            // Initialize state for each product
            products.forEach(product => {
                const stateKey = `${product.index}_${shotType}_v2`;
                if (!productV2State[stateKey]) {
                    const productImages = getProductImages(product.sku);
                    productV2State[stateKey] = {
                        expanded: true,
                        selectedImages: productImages.map((_, i) => i < 2), // Auto-select first 2
                        selectedGuides: [],
                        noneGuideSelected: true // Default to generate without guide
                    };
                }
            });

            // Count total tasks
            const seeds = parseInt(document.querySelector('#seeds-buttons .active')?.dataset.value || '1');
            let totalImages = 0;

            products.forEach(p => {
                const stateKey = `${p.index}_${shotType}_v2`;
                const state = productV2State[stateKey];
                if (!state?.selectedImages?.some(Boolean)) return;

                const relevantGuides = getV2Guides(shotType, p);
                const selectedGuideCount = state.selectedGuides?.filter(Boolean).length || 0;
                const guideMultiplier = (state.noneGuideSelected ? 1 : 0) + selectedGuideCount;
                const effectiveGuideMultiplier = Math.max(1, guideMultiplier);

                totalImages += effectiveGuideMultiplier * seeds;
            });

            const selectedCount = products.filter(p => {
                const stateKey = `${p.index}_${shotType}_v2`;
                return productV2State[stateKey]?.selectedImages?.some(Boolean);
            }).length;

            let html = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--space-sm); padding: var(--space-sm); background: var(--white); border: 1px solid var(--jet);">
                    <div>
                        <strong>${shotType.toUpperCase()}</strong> - ${selectedCount}/${products.length} products ready
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button onclick="deselectAllV2Products()" style="padding: 4px 12px; font-size: 11px;">Deselect All</button>
                        <button onclick="expandAllV2Products(true)" style="padding: 4px 12px; font-size: 11px;">Expand All</button>
                        <button onclick="expandAllV2Products(false)" style="padding: 4px 12px; font-size: 11px;">Collapse All</button>
                        <button onclick="generateSelectedV2Products()" style="padding: 6px 16px; font-size: 12px; background: var(--jet); color: white; font-weight: 500;">Generate All (${totalImages} images)</button>
                    </div>
                </div>
            `;

            products.forEach(product => {
                const stateKey = `${product.index}_${shotType}_v2`;
                const state = productV2State[stateKey];
                const productImages = getProductImages(product.sku);
                const frontImg = getFrontImage(product.sku);
                const hasSelection = state.selectedImages.some(Boolean);
                const expandedClass = state.expanded ? 'expanded' : '';
                const selectedClass = hasSelection ? 'selected' : '';

                // Get relevant guides for this shot type AND product
                const relevantGuides = getV2Guides(shotType, product);

                // Initialize selectedGuides if not exists or length changed
                if (!state.selectedGuides || state.selectedGuides.length !== relevantGuides.length) {
                    state.selectedGuides = relevantGuides.map(() => false);
                }

                // Guides/References section
                const noneSelected = state.noneGuideSelected || false;
                let guidesHtml = '';
                if (relevantGuides.length > 0) {
                    guidesHtml = `
                        <div style="margin-top: 8px;">
                            <div style="font-size: 10px; color: #666; margin-bottom: 4px;">Guides & References:</div>
                            <div class="pose-product-images-row">
                                <div class="pose-image-option ${noneSelected ? 'selected' : ''}"
                                     onclick="toggleV2NoneGuide(${product.index}, '${shotType}')" title="Generate without guide" style="display: flex; align-items: center; justify-content: center; background: #f5f5f5; min-width: 48px; min-height: 48px;">
                                    <span style="font-size: 10px; font-weight: 600; color: #666;">None</span>
                                    <span class="check">âœ“</span>
                                </div>
                                ${relevantGuides.map((guide, i) => {
                                    // Determine correct path based on guide type
                                    let guidePath;
                                    if (!guide.isPhotoRef) {
                                        // Canny guides (black/white line drawings)
                                        guidePath = '/assets/brand/rondorff/canny/guides/' + guide.file;
                                    } else if (guide.folder === 'canny') {
                                        // Photo refs in legacy canny/refs folder
                                        guidePath = '/assets/brand/rondorff/canny/refs/' + guide.file;
                                    } else {
                                        // Photo refs in refs/{folder} folder
                                        guidePath = '/assets/brand/rondorff/refs/' + guide.folder + '/' + guide.file;
                                    }
                                    const badgeColor = guide.isPhotoRef ? '#f59e0b' : '#3b82f6';
                                    const badgeText = guide.isPhotoRef ? 'R' : 'C';
                                    return `
                                        <div class="pose-image-option ${state.selectedGuides[i] ? 'selected' : ''}"
                                             onclick="toggleV2Guide(${product.index}, '${shotType}', ${i})" title="${guide.label}">
                                            <img src="${guidePath}" alt="${guide.label}">
                                            <span class="check">âœ“</span>
                                            <span style="position: absolute; bottom: 2px; left: 2px; width: 14px; height: 14px; background: ${badgeColor}; color: white; font-size: 8px; font-weight: 700; display: flex; align-items: center; justify-content: center;">${badgeText}</span>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    `;
                }

                html += `
                    <div class="pose-product-card ${expandedClass} ${selectedClass}">
                        <div class="pose-product-header" onclick="toggleV2ProductExpand(${product.index}, '${shotType}')">
                            <img class="pose-product-thumb" src="/assets/brand/rondorff/ecom/thumbs/${frontImg}" alt="${product.name}">
                            <div class="pose-product-info">
                                <div class="pose-product-name">${product.name}</div>
                                <div class="pose-product-sku">${product.sku} â€¢ ${product.color} â€¢ ${state.selectedImages.filter(Boolean).length}/${productImages.length} images</div>
                            </div>
                            <div class="pose-product-actions">
                                <button onclick="event.stopPropagation(); selectAllV2Images(${product.index}, '${shotType}', true)" style="padding: 4px 8px; font-size: 10px;">All</button>
                                <button onclick="event.stopPropagation(); selectAllV2Images(${product.index}, '${shotType}', false)" style="padding: 4px 8px; font-size: 10px;">None</button>
                                <button onclick="event.stopPropagation(); generateSingleV2Product(${product.index})" style="padding: 4px 12px; font-size: 11px; background: var(--jet); color: white;">Generate</button>
                            </div>
                        </div>
                        <div class="pose-product-images">
                            <div class="pose-product-images-row">
                                ${productImages.map((img, i) => `
                                    <div class="pose-image-option ${state.selectedImages[i] ? 'selected' : ''}"
                                         onclick="toggleV2Image(${product.index}, '${shotType}', ${i})" title="${getShotType(img)}">
                                        <img src="/assets/brand/rondorff/ecom/thumbs/${img}" alt="${getShotType(img)}">
                                        <span class="check">âœ“</span>
                                    </div>
                                `).join('')}
                            </div>
                            ${guidesHtml}
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        // Toggle V2 product expansion
        function toggleV2ProductExpand(productIndex, shotType) {
            const stateKey = `${productIndex}_${shotType}_v2`;
            if (productV2State[stateKey]) {
                productV2State[stateKey].expanded = !productV2State[stateKey].expanded;
                renderProductV2Products();
            }
        }

        // Expand/collapse all V2 products
        function expandAllV2Products(expand) {
            const products = getProductsForV2ShotType(selectedV2ShotType);
            products.forEach(product => {
                const stateKey = `${product.index}_${selectedV2ShotType}_v2`;
                if (productV2State[stateKey]) {
                    productV2State[stateKey].expanded = expand;
                }
            });
            renderProductV2Products();
        }

        // Toggle V2 image selection
        function toggleV2Image(productIndex, shotType, imageIndex) {
            const stateKey = `${productIndex}_${shotType}_v2`;
            if (productV2State[stateKey]) {
                productV2State[stateKey].selectedImages[imageIndex] = !productV2State[stateKey].selectedImages[imageIndex];
                renderProductV2Products();
            }
        }

        // Select all/none V2 images
        function selectAllV2Images(productIndex, shotType, selectAll) {
            const stateKey = `${productIndex}_${shotType}_v2`;
            if (productV2State[stateKey]) {
                productV2State[stateKey].selectedImages = productV2State[stateKey].selectedImages.map(() => selectAll);
                renderProductV2Products();
            }
        }

        // Toggle V2 guide selection
        function toggleV2Guide(productIndex, shotType, guideIndex) {
            const stateKey = `${productIndex}_${shotType}_v2`;
            if (productV2State[stateKey]) {
                productV2State[stateKey].selectedGuides[guideIndex] = !productV2State[stateKey].selectedGuides[guideIndex];
                renderProductV2Products();
            }
        }

        // Toggle V2 none guide
        function toggleV2NoneGuide(productIndex, shotType) {
            const stateKey = `${productIndex}_${shotType}_v2`;
            if (productV2State[stateKey]) {
                productV2State[stateKey].noneGuideSelected = !productV2State[stateKey].noneGuideSelected;
                renderProductV2Products();
            }
        }

        // Deselect all V2 products
        function deselectAllV2Products() {
            const products = getProductsForV2ShotType(selectedV2ShotType);
            products.forEach(product => {
                const stateKey = `${product.index}_${selectedV2ShotType}_v2`;
                if (productV2State[stateKey]) {
                    productV2State[stateKey].selectedImages = productV2State[stateKey].selectedImages.map(() => false);
                }
            });
            renderProductV2Products();
        }

        // Generate all selected V2 products
        async function generateSelectedV2Products() {
            const products = getProductsForV2ShotType(selectedV2ShotType);
            const shotType = selectedV2ShotType;

            const productsToGenerate = products.filter(p => {
                const stateKey = `${p.index}_${shotType}_v2`;
                return productV2State[stateKey]?.selectedImages?.some(Boolean);
            });

            if (productsToGenerate.length === 0) {
                alert('Please select at least one image for at least one product');
                return;
            }

            for (const product of productsToGenerate) {
                await queueV2ProductTasks(product.index);
            }

            if (!isProcessingQueue && generationQueue.length > 0) {
                processQueue();
            }
        }

        // Queue tasks for a single V2 product
        async function queueV2ProductTasks(productIndex) {
            return generateSingleV2Product(productIndex, false);
        }

        // Generate single V2 product
        async function generateSingleV2Product(productIndex, startProcessing = true) {
            const product = PRODUCTS[productIndex];
            const shotType = selectedV2ShotType;
            const productImages = getProductImages(product.sku);
            const stateKey = `${productIndex}_${shotType}_v2`;

            const state = productV2State[stateKey];
            if (!state) {
                console.log(`No state for ${product.sku} - ${shotType} V2`);
                return;
            }

            const selectedImgs = productImages.filter((_, i) => state.selectedImages[i]);
            if (selectedImgs.length === 0) {
                console.log(`No images selected for ${product.sku} - ${shotType} V2`);
                return;
            }

            const provider = document.querySelector('#provider-buttons .active')?.dataset.value || 'gemini';
            const aspect = document.querySelector('#aspect-buttons .active')?.dataset.value || '3:4';
            const resolution = document.querySelector('#resolution-buttons .active')?.dataset.value || '2K';
            const seeds = parseInt(document.querySelector('#seeds-buttons .active')?.dataset.value || '1');

            const taskSettings = { aspect, resolution, seeds, provider };

            // Get relevant guides
            const relevantGuides = getV2Guides(shotType, product);
            const selectedGuideIndices = state.selectedGuides
                .map((selected, i) => selected ? i : -1)
                .filter(i => i >= 0);

            // If "None" is selected, add a task without guide
            // Note: seeds are handled in processQueue, so we only create 1 task here
            if (state.noneGuideSelected) {
                generationQueue.push({
                    product: { ...product },
                    shotType,
                    selectedImgs: [...selectedImgs],
                    selectedModels: [],
                    selectedFootwear: [],
                    selectedBottoms: [],
                    selectedTops: [],
                    guide: null,
                    poseMode: null,
                    settings: { ...taskSettings },
                    isV2: true
                });
            }

            // Add tasks for each selected guide
            // Note: seeds are handled in processQueue, so we only create 1 task per guide
            selectedGuideIndices.forEach(guideIdx => {
                const guide = relevantGuides[guideIdx];
                generationQueue.push({
                    product: { ...product },
                    shotType,
                    selectedImgs: [...selectedImgs],
                    selectedModels: [],
                    selectedFootwear: [],
                    selectedBottoms: [],
                    selectedTops: [],
                    guide: { ...guide },
                    poseMode: null,
                    settings: { ...taskSettings },
                    isV2: true
                });
            });

            updateQueueStatus();

            if (startProcessing && !isProcessingQueue) {
                processQueue();
            }
        }

        let settings = { aspect: '3:4', resolution: '2K', seeds: 1, provider: 'gemini' };

        // E-Commerce tab state for new layout
        let selectedInputImages = []; // Array of booleans for product images
        let selectedGuideImages = []; // Array of booleans for canny guides
        let ecomResults = []; // Array of generated results

        // Global results (persists across tabs)
        let globalResults = [];
        let ecomGlobalLoader = null;
        let ecomLightbox = null; // Shared lightbox instance
        let batchCounter = 0; // Track batch numbers for results

        // Generation queue
        let generationQueue = [];
        let isProcessingQueue = false;
        const MAX_CONCURRENT = 15; // Limit concurrent API requests

        // Canny tab state
        let cannyImages = []; // Array of { file, url, name, analysis }
        const CANNY_GRID_SIZE = 18; // Number of upload slots (3 rows x 6)
        let cannySettings = { aspect: '3:4', resolution: '2K', seeds: 1 };

        // ========== HELPERS ==========
        function skuToPrefix(sku) { return sku.toLowerCase(); }
        function getProductImages(sku) { return ALL_IMAGES.filter(img => img.startsWith(skuToPrefix(sku))); }
        function getShotType(filename) { return filename.replace('.jpg', '').split('_').slice(1).join(' '); }
        function getFrontImage(sku) { return ALL_IMAGES.find(img => img.startsWith(skuToPrefix(sku)) && img.includes('_front')); }

        // ========== LOAD/SAVE ANALYSIS ==========
        async function loadAnalysis() {
            try {
                // Load from pre-analyzed JSON file
                const res = await fetch('/assets/brand/rondorff/ecom/image-analysis.json');
                const data = await res.json();
                imageAnalysis = data.images || {};
                console.log(`Loaded ${Object.keys(imageAnalysis).length} pre-analyzed images`);
                updateAnalyzedCount();
            } catch (e) {
                console.log('No existing analysis found, trying localStorage');
                // Fallback to localStorage
                const stored = localStorage.getItem('rondorff-image-analysis');
                if (stored) {
                    imageAnalysis = JSON.parse(stored);
                    updateAnalyzedCount();
                }
            }
        }

        async function saveAnalysis() {
            // Save to localStorage as backup
            localStorage.setItem('rondorff-image-analysis', JSON.stringify(imageAnalysis));
        }

        function updateAnalyzedCount() {
            document.getElementById('analyzed-count').textContent = Object.keys(imageAnalysis).length;
        }

        // ========== TABS ==========
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById(`tab-${tab.dataset.tab}`).classList.add('active');
            });
        });

        // ========== SETTINGS BUTTONS ==========
        function setupSettingsButtons() {
            ['aspect', 'resolution', 'seeds', 'provider'].forEach(setting => {
                const container = document.getElementById(`${setting}-buttons`);
                if (!container) return;
                container.addEventListener('click', (e) => {
                    if (e.target.tagName !== 'BUTTON') return;
                    container.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    settings[setting] = e.target.dataset.value;
                    // Update generate button when seeds change
                    if (setting === 'seeds') {
                        updateGenerateAllButton();
                    }
                });
            });
        }

        // ========== OVERVIEW TAB ==========
        function renderOverview() {
            const container = document.getElementById('products-overview');
            let html = '';
            const categories = {};
            PRODUCTS.forEach(p => { if (!categories[p.category]) categories[p.category] = []; categories[p.category].push(p); });

            for (const [category, products] of Object.entries(categories)) {
                html += `<div class="category-section"><div class="category-header">${category}</div>`;
                products.forEach(product => {
                    const images = getProductImages(product.sku);
                    html += `<div class="product-card">
                        <div class="product-header">
                            <div class="product-info">
                                <div class="product-name">${product.name}</div>
                                <div class="product-sku">${product.sku}</div>
                            </div>
                            <div class="product-meta">
                                <div class="product-color">${product.color}</div>
                                <div class="product-material">${product.material}</div>
                            </div>
                        </div>
                        <div class="image-grid">`;
                    images.forEach(img => {
                        const shot = getShotType(img);
                        const analyzed = imageAnalysis[img] ? ' (analyzed)' : '';
                        html += `<div class="image-slot">
                            <img class="image-thumb" src="/assets/brand/rondorff/ecom/thumbs/${img}"
                                 data-full="/assets/brand/rondorff/ecom/originals/${img}" data-name="${product.name}" data-shot="${shot}"
                                 onclick="openLightbox(this)" alt="${shot}">
                            <div class="image-label">${shot}</div>
                        </div>`;
                    });
                    html += `</div><div class="requirements-row">`;
                    product.shotTypes.forEach(req => {
                        const shotTypes = images.map(img => getShotType(img));
                        const hasIt = shotTypes.some(s => s === req || (s === 'front' && req === 'flat_lay') || s.includes(req.replace('_', ' ')));
                        html += `<span class="req-tag ${hasIt ? 'has' : 'needed'}">${req.replace('_', ' ')}</span>`;
                    });
                    if (product.video) html += `<span class="req-tag video">VIDEO</span>`;
                    html += `</div></div>`;
                });
                html += `</div>`;
            }
            container.innerHTML = html;
        }

        // ========== E-COMMERCE TAB ==========
        function renderProductSelector() {
            const container = document.getElementById('product-selector');
            let html = '';
            PRODUCTS.forEach((product, index) => {
                const frontImg = getFrontImage(product.sku);
                const selected = selectedProductIndex === index ? 'selected' : '';
                html += `<div class="product-thumb ${selected}" onclick="selectProduct(${index})">
                    <img src="/assets/brand/rondorff/ecom/thumbs/${frontImg}" alt="${product.name}">
                    <div class="product-thumb-label">${product.sku.split('.')[0]}</div>
                </div>`;
            });
            container.innerHTML = html;
        }

        function selectProduct(index) {
            selectedProductIndex = index;
            // Reset category state for new product
            categoryState = {};
            // Reset new e-commerce state
            const product = PRODUCTS[index];
            const productImages = getProductImages(product.sku);
            selectedInputImages = productImages.map(() => false);
            selectedGuideImages = CANNY_GUIDE_IMAGES.map(() => false);
            ecomResults = [];
            renderProductSelector();
            renderSelectedProduct();
        }

        function renderSelectedProduct() {
            const container = document.getElementById('selected-product-area');
            if (selectedProductIndex === null) {
                container.innerHTML = `<div class="no-product-selected">Select a product above to start generating</div>`;
                return;
            }

            const product = PRODUCTS[selectedProductIndex];
            const productImages = getProductImages(product.sku);
            const allAnalyzed = productImages.every(img => imageAnalysis[img]);

            // Initialize category state for each shot type
            product.shotTypes.forEach(shotType => {
                if (!categoryState[shotType]) {
                    const relevantGuides = getRelevantGuides(shotType, product);
                    // Check if footwear is available for this shot type and product category
                    const canUseFootwear = shotType === 'on-model' && CATEGORIES_WITH_FOOTWEAR.includes(product.category);
                    // Check if bottoms is available for this shot type and product category (tops only)
                    const canUseBottoms = shotType === 'on-model' && CATEGORIES_WITH_BOTTOMS.includes(product.category);
                    // Check if this shot type needs pose mode (face and 3/4)
                    const needsPoseMode = SHOT_TYPES_WITH_MODELS.includes(shotType);
                    categoryState[shotType] = {
                        selectedGuides: relevantGuides.map(() => false), // Array of booleans for multi-select
                        noneGuideSelected: false, // "None" option - generate without canny guide
                        selectedImages: productImages.map(() => false),
                        selectedModels: needsPoseMode ? MODEL_PORTRAITS.map(() => false) : [],
                        selectedFootwear: canUseFootwear ? FOOTWEAR.map(() => false) : [],
                        selectedBottoms: canUseBottoms ? BOTTOMS.map(() => false) : [],
                        poseModes: needsPoseMode ? { copy: true, dynamic: false } : null, // Multi-select for pose modes
                        results: []
                    };
                }
            });

            let html = `
                <div class="selected-product-header">
                    <div>
                        <div class="selected-product-title">${product.name}</div>
                        <div class="selected-product-sku">${product.sku} - ${product.color}</div>
                    </div>
                    <button class="header-btn" id="generate-all-btn" onclick="generateAllCategories()" disabled>Generate</button>
                </div>
                <div class="category-rows">
            `;

            product.shotTypes.forEach(shotType => {
                html += renderCategoryRow(shotType, product, productImages);
            });

            html += `</div>`;
            container.innerHTML = html;

            // Update Generate All button state
            updateGenerateAllButton();
        }

        function renderCategoryRow(shotType, product, productImages) {
            const state = categoryState[shotType];
            const hasModels = SHOT_TYPES_WITH_MODELS.includes(shotType);
            const hasPoseMode = hasModels; // face and 3/4 shots have pose mode
            const hasFootwear = shotType === 'on-model' && CATEGORIES_WITH_FOOTWEAR.includes(product.category);
            const selectedCount = state.selectedImages.filter(Boolean).length + (hasModels ? state.selectedModels.filter(Boolean).length : 0);
            const totalCount = productImages.length + (hasModels ? MODEL_PORTRAITS.length : 0);

            // Get relevant canny guides for this shot type (filtered by product)
            const relevantGuides = getRelevantGuides(shotType, product);

            // Render model portraits first for on-model shots
            const modelImagesHtml = hasModels ? MODEL_PORTRAITS.map((model, i) => `
                <div class="image-option ${state.selectedModels[i] ? 'selected' : ''}"
                     onclick="toggleModelImage('${shotType}', ${i})" title="${model.name}" style="position: relative;">
                    <img src="${model.thumb}" alt="${model.name}">
                    <span class="check">âœ“</span>
                    <span class="model-badge" style="position: absolute; bottom: 2px; left: 2px; width: 14px; height: 14px; background: #3b82f6; color: white; font-size: 8px; font-weight: 700; display: flex; align-items: center; justify-content: center;">M</span>
                </div>
            `).join('') : '';

            // Render footwear option for bottoms 3/4 shots
            const footwearImagesHtml = hasFootwear ? FOOTWEAR.map((shoe, i) => `
                <div class="image-option ${state.selectedFootwear[i] ? 'selected' : ''}"
                     onclick="toggleFootwearImage('${shotType}', ${i})" title="${shoe.name}" style="position: relative;">
                    <img src="${shoe.thumb}" alt="${shoe.name}">
                    <span class="check">âœ“</span>
                    <span class="model-badge" style="position: absolute; bottom: 2px; left: 2px; width: 14px; height: 14px; background: #8b5cf6; color: white; font-size: 8px; font-weight: 700; display: flex; align-items: center; justify-content: center;">F</span>
                </div>
            `).join('') : '';

            // Separate canny guides from photo refs
            const cannyGuides = relevantGuides.filter(g => !g.isPhotoRef);
            const photoRefs = relevantGuides.filter(g => g.isPhotoRef);

            // Render guides row with "None" option - ALWAYS show "None" even if no guides exist
            const noneSelected = state.noneGuideSelected || false;
            const hasGuides = cannyGuides.length > 0;
            const guidesLabel = hasGuides ? 'Canny Guides (line drawings for composition)' : 'Generation Mode';
            const cannyGuidesHtml = `
                <div class="section-label">${guidesLabel}</div>
                <div class="guides-row">
                    <div class="image-option guide-image-option ${noneSelected ? 'selected' : ''}"
                         onclick="selectNoneGuide('${shotType}')" title="Generate without guide" style="position: relative; display: flex; align-items: center; justify-content: center; background: #f5f5f5; min-width: 60px; cursor: pointer;">
                        <span style="font-size: 11px; color: #666;">${hasGuides ? 'None' : 'Generate'}</span>
                        <span class="check">âœ“</span>
                    </div>
                    ${cannyGuides.map((guide, i) => {
                        const globalIndex = relevantGuides.indexOf(guide);
                        return `
                        <div class="image-option guide-image-option ${state.selectedGuides[globalIndex] ? 'selected' : ''}"
                             onclick="toggleCategoryGuide('${shotType}', ${globalIndex})" title="${guide.label}" style="position: relative;">
                            <img src="/assets/brand/rondorff/canny/guides/${guide.file}" alt="${guide.label}">
                            <span class="check">âœ“</span>
                        </div>
                    `}).join('')}
                </div>
            `;

            // Render photo refs row
            const photoRefsHtml = photoRefs.length > 0 ? `
                <div class="section-label" style="margin-top: 8px;">Photo References (match this exact composition)</div>
                <div class="guides-row">
                    ${photoRefs.map((guide, i) => {
                        const globalIndex = relevantGuides.indexOf(guide);
                        const photoRefPath = guide.folder === 'canny'
                            ? `/assets/brand/rondorff/canny/refs/${guide.file}`
                            : `/assets/brand/rondorff/refs/${guide.folder}/${guide.file}`;
                        return `
                        <div class="image-option guide-image-option ${state.selectedGuides[globalIndex] ? 'selected' : ''}"
                             onclick="toggleCategoryGuide('${shotType}', ${globalIndex})" title="${guide.label}" style="position: relative; border-color: #3b82f6;">
                            <img src="${photoRefPath}" alt="${guide.label}">
                            <span class="check">âœ“</span>
                        </div>
                    `}).join('')}
                </div>
            ` : '';

            const guidesHtml = cannyGuidesHtml + photoRefsHtml;

            // Pose mode toggle buttons for face/3-4 shots (multi-select)
            const poseModeHtml = hasPoseMode && state.poseModes ? `
                <div class="pose-mode-toggle">
                    <button class="pose-mode-btn ${state.poseModes.copy ? 'active' : ''}" onclick="togglePoseMode('${shotType}', 'copy')">Copy</button>
                    <button class="pose-mode-btn ${state.poseModes.dynamic ? 'active' : ''}" onclick="togglePoseMode('${shotType}', 'dynamic')">Dynamic</button>
                </div>
            ` : '';

            return `
                <div class="category-row" data-shot-type="${shotType}">
                    <div class="category-row-header">
                        <div class="category-row-title">${shotType.replace('_', ' ')}</div>
                        <div class="category-row-actions">
                            ${poseModeHtml}
                            <button class="select-btn" onclick="selectAllImages('${shotType}', true)">All</button>
                            <button class="select-btn" onclick="selectAllImages('${shotType}', false)">None</button>
                            <span class="category-row-status">${selectedCount}/${totalCount}</span>
                        </div>
                    </div>
                    <div class="inputs-guides-section">
                        <div class="section-label">Input Images${hasModels ? ' (+ Models)' : ''}${hasFootwear ? ' (+ Footwear)' : ''}</div>
                        <div class="images-row">
                            ${modelImagesHtml}
                            ${footwearImagesHtml}
                            ${productImages.map((img, i) => `
                                <div class="image-option ${state.selectedImages[i] ? 'selected' : ''}"
                                     onclick="toggleInputImage('${shotType}', ${i})" title="${getShotType(img)}" style="position: relative;">
                                    <img src="/assets/brand/rondorff/ecom/thumbs/${img}" alt="${getShotType(img)}">
                                    <span class="check">âœ“</span>
                                </div>
                            `).join('')}
                        </div>
                        ${guidesHtml}
                    </div>
                    <button class="category-generate-btn" onclick="generateCategory('${shotType}')" ${selectedCount === 0 ? 'disabled' : ''}>
                        Generate ${shotType.replace('_', ' ')}
                    </button>
                </div>
            `;
        }

        // Get relevant canny guides for a shot type
        // Get canny guides for a shot type, optionally filtered by product
        function getRelevantGuides(shotType, product = null) {
            const typeMap = {
                'flatlay': 'flatlay',
                'flat_lay': 'flatlay',
                'back': 'flatlay', // Back shots use same flatlay guides/refs
                'eyelet': 'eyelet',
                'collar': 'collar',
                'belt': 'belt',
                'sleeves': 'sleeves',
                'fabrics': 'fabrics',
                'print': 'print',
                'face': 'face',
                '3/4': '3/4',
                'on-model': 'on-model'
            };
            const guideType = typeMap[shotType];
            if (!guideType) return [];

            // Filter function for photo refs based on product and view type
            const filterPhotoRef = (ref) => {
                // Filter by forSku if specified (cap/tote refs only for their products)
                if (ref.forSku) {
                    if (!product || product.sku !== ref.forSku) return false;
                }

                // For on-model shots, include all refs (they'll be grouped by poseType in UI)
                // For legacy face/3/4 shot types, filter by label
                if (shotType === 'face' || shotType === '3/4') {
                    const label = ref.label || '';
                    const isFront = label.includes('Front');
                    const isSideOrBack = label.includes('Side') || label.includes('Back');

                    // If ref has a view label, filter based on shot type
                    if (isFront || isSideOrBack) {
                        if (shotType === 'face' && isSideOrBack) return false; // Hide Side/Back from face
                        if (shotType === '3/4' && isFront) return false; // Hide Front from 3/4
                    }
                }
                // For on-model: no filtering needed, UI groups by poseType

                return true;
            };

            // Combine canny guides and filtered photo refs for this shot type
            const cannyGuides = CANNY_GUIDE_IMAGES.filter(g => g.type === guideType);
            const photoRefs = PHOTO_REF_IMAGES.filter(g => g.type === guideType && filterPhotoRef(g));
            return [...cannyGuides, ...photoRefs];
        }

        // Select a canny guide for a category (multi-select, independent of "None")
        function toggleCategoryGuide(shotType, guideIndex) {
            if (!categoryState[shotType]) return;
            categoryState[shotType].selectedGuides[guideIndex] = !categoryState[shotType].selectedGuides[guideIndex];
            renderSelectedProduct();
        }

        // Select "None" option - can be combined with guides for parallel requests
        function selectNoneGuide(shotType) {
            if (!categoryState[shotType]) return;
            categoryState[shotType].noneGuideSelected = !categoryState[shotType].noneGuideSelected;
            renderSelectedProduct();
        }

        function toggleInputImage(shotType, index) {
            if (!categoryState[shotType]) return;
            categoryState[shotType].selectedImages[index] = !categoryState[shotType].selectedImages[index];
            renderSelectedProduct();
        }

        function toggleModelImage(shotType, index) {
            if (!categoryState[shotType] || !categoryState[shotType].selectedModels) return;
            categoryState[shotType].selectedModels[index] = !categoryState[shotType].selectedModels[index];
            renderSelectedProduct();
        }

        function toggleFootwearImage(shotType, index) {
            if (!categoryState[shotType] || !categoryState[shotType].selectedFootwear) return;
            categoryState[shotType].selectedFootwear[index] = !categoryState[shotType].selectedFootwear[index];
            renderSelectedProduct();
        }

        function togglePoseMode(shotType, mode) {
            if (!categoryState[shotType] || !categoryState[shotType].poseModes) return;
            categoryState[shotType].poseModes[mode] = !categoryState[shotType].poseModes[mode];
            renderSelectedProduct();
        }

        function selectAllImages(shotType, selectAll) {
            if (!categoryState[shotType]) return;
            const product = PRODUCTS[selectedProductIndex];
            const productImages = getProductImages(product.sku);
            categoryState[shotType].selectedImages = productImages.map(() => selectAll);
            // Also select/deselect models if applicable
            if (SHOT_TYPES_WITH_MODELS.includes(shotType)) {
                categoryState[shotType].selectedModels = MODEL_PORTRAITS.map(() => selectAll);
            }
            // Also select/deselect footwear if applicable
            if (shotType === 'on-model' && CATEGORIES_WITH_FOOTWEAR.includes(product.category)) {
                categoryState[shotType].selectedFootwear = FOOTWEAR.map(() => selectAll);
            }
            renderSelectedProduct();
        }

        function clearGuides(shotType) {
            // Clear all selected guides including None
            if (categoryState[shotType]) {
                const product = selectedProductIndex !== null ? PRODUCTS[selectedProductIndex] : null;
                const relevantGuides = getRelevantGuides(shotType, product);
                categoryState[shotType].selectedGuides = relevantGuides.map(() => false);
                categoryState[shotType].noneGuideSelected = false;
                renderSelectedProduct();
            }
        }

        // New E-Commerce selection functions
        function toggleInputImageSelection(index) {
            selectedInputImages[index] = !selectedInputImages[index];
            renderSelectedProduct();
        }

        function toggleGuideImageSelection(index) {
            selectedGuideImages[index] = !selectedGuideImages[index];
            renderSelectedProduct();
        }

        // ========== ANALYZE ==========
        async function analyzeAllImages() {
            const btn = document.getElementById('analyze-all-btn');
            const originalText = btn.textContent;
            btn.disabled = true;

            const unanalyzed = ALL_IMAGES.filter(img => !imageAnalysis[img]);
            if (unanalyzed.length === 0) {
                alert('All images already analyzed!');
                btn.disabled = false;
                return;
            }

            let analyzed = 0;
            for (const img of unanalyzed) {
                btn.textContent = `Analyzing ${analyzed + 1}/${unanalyzed.length}...`;

                try {
                    const imageUrl = window.location.origin + `/assets/brand/rondorff/ecom/originals/${img}`;
                    const response = await fetch('/api/analyze-gemini', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            image_url: imageUrl,
                            prompt: `Analyze this product image for e-commerce photography. Return a brief JSON:
{
  "shotType": "flat lay / detail / close-up / etc",
  "part": "front / back / collar / sleeve / eyelet / etc",
  "details": ["key visible details"],
  "colors": ["colors visible"],
  "description": "One sentence description for use in AI prompts"
}`
                        })
                    });

                    const data = await response.json();
                    if (data.content) {
                        try {
                            const cleaned = data.content.replace(/```json\n?|\n?```/g, '').trim();
                            imageAnalysis[img] = JSON.parse(cleaned);
                        } catch {
                            imageAnalysis[img] = { description: data.content };
                        }
                    }
                } catch (e) {
                    console.error(`Failed to analyze ${img}:`, e);
                }
                analyzed++;
                updateAnalyzedCount();
            }

            saveAnalysis();
            btn.textContent = originalText;
            btn.disabled = false;
            alert(`Analyzed ${analyzed} images. Data saved to localStorage.`);
        }

        async function analyzeProductImages() {
            const btn = document.getElementById('analyze-btn');
            const statusEl = document.getElementById('analysis-status');
            btn.textContent = 'Analyzing...';
            btn.disabled = true;
            btn.classList.add('analyzing');

            const product = PRODUCTS[selectedProductIndex];
            const productImages = getProductImages(product.sku);
            let analyzed = 0;

            for (const img of productImages) {
                if (imageAnalysis[img]) { analyzed++; continue; }

                statusEl.textContent = `Analyzing ${analyzed + 1}/${productImages.length}...`;

                try {
                    const imageUrl = window.location.origin + `/assets/brand/rondorff/ecom/originals/${img}`;
                    const response = await fetch('/api/analyze-gemini', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            image_url: imageUrl,
                            prompt: `Analyze this product image for e-commerce photography. Return a brief JSON:
{
  "shotType": "flat lay / detail / close-up / etc",
  "part": "front / back / collar / sleeve / eyelet / etc",
  "details": ["key visible details"],
  "colors": ["colors visible"],
  "description": "One sentence description for use in AI prompts"
}`
                        })
                    });

                    const data = await response.json();
                    if (data.content) {
                        try {
                            const cleaned = data.content.replace(/```json\n?|\n?```/g, '').trim();
                            imageAnalysis[img] = JSON.parse(cleaned);
                        } catch {
                            imageAnalysis[img] = { description: data.content };
                        }
                    }
                } catch (e) {
                    console.error(`Failed to analyze ${img}:`, e);
                }
                analyzed++;
            }

            saveAnalysis();
            updateAnalyzedCount();
            btn.textContent = 'Analyze';
            btn.classList.remove('analyzing');
            renderSelectedProduct();
        }

        // ========== GENERATE ==========
        function buildPrompt(shotType, product, selectedImgs, selectedModels = []) {
            // Get consistent product color from any analyzed image
            let productColor = product.color;
            if (selectedImgs.length > 0) {
                const firstAnalysis = imageAnalysis[selectedImgs[0]];
                if (firstAnalysis?.productColor) {
                    productColor = firstAnalysis.productColor;
                }
            }

            // Build detailed descriptions for each selected image
            const imageDescriptions = selectedImgs.map(img => {
                const analysis = imageAnalysis[img];
                const shotName = getShotType(img);

                if (analysis) {
                    const details = analysis.details?.join(', ') || '';
                    const part = analysis.part || shotName;
                    return `${part} shot showing ${analysis.description || shotName}${details ? ` with ${details}` : ''}`;
                }
                return `${shotName} reference`;
            });

            // Model descriptions for face/3-4 shots
            const modelDescriptions = selectedModels.map(model => `Model portrait reference (${model.name})`);

            const basePrompts = {
                'flat_lay': `Professional e-commerce flat lay photograph. Bird's eye view on light warm gray studio background. Garment laid perfectly flat with clean, refined presentation. Fabric smooth and unwrinkled. Professional soft studio lighting with even, diffused illumination. High-end fashion e-commerce aesthetic.`,
                'eyelet': `Close-up detail shot of eyelet/stitching. Macro photography. Light gray studio background. Highlighting texture and craftsmanship. Professional soft lighting.`,
                'collar': `Detail shot of collar/neckline area. Clean composition. Light gray studio background. Professional soft lighting.`,
                'fabrics': `Texture/fabric detail shot. Close-up showing weave and material quality. Light gray background. Professional soft lighting.`,
                'sleeves': `Detail shot of sleeve construction. Clean composition. Light gray studio background. Professional soft lighting.`,
                'face': `Front-facing model shot wearing the garment. Male model. Clean studio background. Professional soft studio lighting with even illumination.`,
                '3/4': `3/4 angle model shot wearing the garment. Male model. Clean studio background. Professional soft studio lighting with even illumination.`,
                'back': `Back view flat lay. Clean presentation. Light warm gray studio background. Professional soft lighting.`,
                'print': `Detail shot of print/graphic. Clean composition highlighting design. Light gray background. Professional soft lighting.`,
                'belt': `Detail shot of waistband/belt area. Clean composition. Light gray studio background. Professional soft lighting.`
            };

            const allDescriptions = [...modelDescriptions, ...imageDescriptions];
            const totalCount = allDescriptions.length;

            return `Create a ${shotType.replace('_', ' ')} shot for Ron Dorff ${product.name} (${productColor}, ${product.material}).

Using ${totalCount} reference image${totalCount > 1 ? 's' : ''}:
${allDescriptions.map((desc, i) => `${i + 1}. ${desc}`).join('\n')}

${basePrompts[shotType] || 'Professional e-commerce photograph.'}

High-end fashion e-commerce aesthetic. Minimal, clean, sophisticated.`;
        }

        // ========== NAMING CONVENTION ==========
        function generateFilename(product, shotType, index, poseType = null) {
            const now = new Date();
            const yy = String(now.getFullYear()).slice(-2);
            const mm = String(now.getMonth() + 1).padStart(2, '0');
            const dd = String(now.getDate()).padStart(2, '0');
            const hh = String(now.getHours()).padStart(2, '0');
            const min = String(now.getMinutes()).padStart(2, '0');
            const xx = String(index + 1).padStart(2, '0');

            const cleanSku = product.sku.replace(/\./g, '').toUpperCase();
            // For on-model shots, use poseType (front/34) instead of generic "onmodel"
            let cleanShotType;
            if (shotType === 'on-model' && poseType) {
                cleanShotType = poseType === '3/4' ? '34' : poseType;
            } else {
                cleanShotType = shotType.replace(/[^a-zA-Z0-9]/g, '');
            }

            return `Setset_RonDorff_Ecomm_${cleanSku}_${cleanShotType}_${yy}${mm}${dd}_${hh}${min}_${xx}`;
        }

        // Add to queue and start processing
        // Add tasks to queue for a shot type. If autoProcess=true, starts processing immediately.
        function generateCategory(shotType, autoProcess = true) {
            if (selectedProductIndex === null) return;

            const product = PRODUCTS[selectedProductIndex];
            const productImages = getProductImages(product.sku);
            const state = categoryState[shotType];
            const selectedImgs = productImages.filter((_, i) => state.selectedImages[i]);
            const selectedModels = SHOT_TYPES_WITH_MODELS.includes(shotType)
                ? MODEL_PORTRAITS.filter((_, i) => state.selectedModels[i])
                : [];
            // Get selected footwear for on-model shots
            const hasFootwearOption = shotType === 'on-model' && CATEGORIES_WITH_FOOTWEAR.includes(product.category);
            const selectedFootwear = hasFootwearOption && state.selectedFootwear
                ? FOOTWEAR.filter((_, i) => state.selectedFootwear[i])
                : [];

            if (selectedImgs.length === 0 && selectedModels.length === 0) return;

            // Get selected guides (filtered by product)
            const relevantGuides = getRelevantGuides(shotType, product);
            const selectedGuideObjects = relevantGuides.filter((_, i) => state.selectedGuides[i]);
            const noneSelected = state.noneGuideSelected || false;

            // Create tasks for "None" AND/OR selected guides (can be combined)
            // For on-model shots: create separate task for EACH model Ã— guide Ã— pose mode combination
            const isModelShot = SHOT_TYPES_WITH_MODELS.includes(shotType) && selectedModels.length > 0;

            // Get selected pose modes (can be both copy AND dynamic)
            const selectedPoseModes = state.poseModes
                ? Object.entries(state.poseModes).filter(([_, selected]) => selected).map(([mode]) => mode)
                : [null]; // No pose mode for non-model shots

            // Skip if model shot but no pose modes selected
            if (isModelShot && selectedPoseModes.length === 0) return;

            if (isModelShot) {
                // Each model Ã— pose mode combination gets its own generation request
                selectedModels.forEach(model => {
                    selectedPoseModes.forEach(poseMode => {
                        if (noneSelected) {
                            generationQueue.push({
                                shotType,
                                product: { ...product },
                                selectedImgs: [...selectedImgs],
                                selectedModels: [model], // Single model per task
                                selectedFootwear: [...selectedFootwear],
                                guide: null,
                                poseMode, // Include pose mode
                                settings: { ...settings }
                            });
                        }
                        if (selectedGuideObjects.length > 0) {
                            selectedGuideObjects.forEach(guide => {
                                generationQueue.push({
                                    shotType,
                                    product: { ...product },
                                    selectedImgs: [...selectedImgs],
                                    selectedModels: [model], // Single model per task
                                    selectedFootwear: [...selectedFootwear],
                                    guide: { ...guide },
                                    poseMode, // Include pose mode
                                    settings: { ...settings }
                                });
                            });
                        }
                    });
                });
            } else {
                // Non-model shots: original behavior (no pose mode needed)
                if (noneSelected) {
                    generationQueue.push({
                        shotType,
                        product: { ...product },
                        selectedImgs: [...selectedImgs],
                        selectedModels: [...selectedModels],
                        selectedFootwear: [...selectedFootwear],
                        guide: null,
                        poseMode: null,
                        settings: { ...settings }
                    });
                }
                if (selectedGuideObjects.length > 0) {
                    selectedGuideObjects.forEach(guide => {
                        generationQueue.push({
                            shotType,
                            product: { ...product },
                            selectedImgs: [...selectedImgs],
                            selectedModels: [...selectedModels],
                            selectedFootwear: [...selectedFootwear],
                            guide: { ...guide },
                            poseMode: null,
                            settings: { ...settings }
                        });
                    });
                }
            }
            // If neither guides nor "None" selected, no task is created

            // Update button to show queued
            const btn = document.querySelector(`.category-row[data-shot-type="${shotType}"] .category-generate-btn`);
            if (btn) btn.textContent = 'Queued...';

            // Update queue display
            updateQueueStatus();

            // Start processing if requested and not already running
            if (autoProcess && !isProcessingQueue) {
                processQueue();
            }
        }

        // Generate all shot types that have selections - adds ALL tasks first, then processes once
        function generateAllCategories() {
            if (selectedProductIndex === null) return;

            const product = PRODUCTS[selectedProductIndex];

            // First, add all tasks to the queue WITHOUT starting processing
            product.shotTypes.forEach(shotType => {
                const state = categoryState[shotType];
                if (!state) return;

                const productImages = getProductImages(product.sku);
                const selectedImgs = productImages.filter((_, i) => state.selectedImages[i]);
                const selectedModels = SHOT_TYPES_WITH_MODELS.includes(shotType)
                    ? MODEL_PORTRAITS.filter((_, i) => state.selectedModels[i])
                    : [];

                // Skip if nothing selected
                if (selectedImgs.length === 0 && selectedModels.length === 0) return;

                // Add tasks for this shot type (don't auto-process yet)
                generateCategory(shotType, false);
            });

            // Now start processing ALL tasks together
            if (generationQueue.length > 0 && !isProcessingQueue) {
                processQueue();
            }
        }

        // Update Generate All button state based on selections
        function updateGenerateAllButton() {
            const btn = document.getElementById('generate-all-btn');
            if (!btn) return;

            if (selectedProductIndex === null) {
                btn.disabled = true;
                btn.textContent = 'Generate';
                return;
            }

            const product = PRODUCTS[selectedProductIndex];
            let taskCount = 0; // Number of generation tasks (each produces seeds images)

            product.shotTypes.forEach(shotType => {
                const state = categoryState[shotType];
                if (!state) return;

                const productImages = getProductImages(product.sku);
                const selectedImgs = productImages.filter((_, i) => state.selectedImages[i]);
                const selectedModels = SHOT_TYPES_WITH_MODELS.includes(shotType)
                    ? MODEL_PORTRAITS.filter((_, i) => state.selectedModels[i])
                    : [];

                // Skip if nothing selected
                if (selectedImgs.length === 0 && selectedModels.length === 0) return;

                // Count guides selected for this shot type (filtered by product)
                const relevantGuides = getRelevantGuides(shotType, product);
                const selectedGuideCount = relevantGuides.filter((_, i) => state.selectedGuides[i]).length;
                const noneSelected = state.noneGuideSelected || false;

                // Count pose modes for model shots
                const isModelShot = SHOT_TYPES_WITH_MODELS.includes(shotType) && selectedModels.length > 0;
                const selectedPoseModeCount = state.poseModes
                    ? Object.values(state.poseModes).filter(Boolean).length
                    : 0;

                // Skip if model shot but no pose modes selected
                if (isModelShot && selectedPoseModeCount === 0) return;

                // Calculate guide count
                let guideMultiplier = 0;
                if (noneSelected) guideMultiplier += 1;
                if (selectedGuideCount > 0) guideMultiplier += selectedGuideCount;

                if (guideMultiplier === 0) return; // No guides selected

                // Model shots: multiply by model count and pose mode count
                if (isModelShot) {
                    taskCount += selectedModels.length * guideMultiplier * selectedPoseModeCount;
                } else {
                    taskCount += guideMultiplier;
                }
            });

            const seedCount = parseInt(settings.seeds) || 1;
            const totalImages = taskCount * seedCount;

            if (taskCount === 0) {
                btn.disabled = true;
                btn.textContent = 'Generate';
            } else {
                btn.disabled = false;
                const seedText = seedCount > 1 ? ` (${seedCount} seeds)` : '';
                btn.textContent = `Generate ${totalImages} image${totalImages !== 1 ? 's' : ''}${seedText}`;
            }
        }

        function updateQueueStatus() {
            const count = document.getElementById('global-results-count');
            if (generationQueue.length > 0) {
                count.textContent = `${globalResults.length} images | ${generationQueue.length} in queue`;
            } else {
                count.textContent = `${globalResults.length} image${globalResults.length !== 1 ? 's' : ''}`;
            }
        }

        async function processQueue() {
            if (generationQueue.length === 0) {
                isProcessingQueue = false;
                return;
            }

            isProcessingQueue = true;

            // Show results section
            document.getElementById('global-results-section').classList.add('has-results');

            // Setup loader if not already
            if (!ecomGlobalLoader) {
                ecomGlobalLoader = new StudioLoader({
                    loaderElement: document.getElementById('global-loader'),
                    messageElement: document.getElementById('global-loader-message'),
                    progressElement: document.getElementById('global-loader-progress')
                });
            }

            // Grab all tasks and clear queue
            const allTasks = [...generationQueue];
            generationQueue.length = 0;
            updateQueueStatus();

            // Increment batch counter and get product name for this batch
            batchCounter++;
            const currentBatch = batchCounter;
            const batchProduct = allTasks[0]?.product?.name || 'Unknown Product';
            const batchImageCount = allTasks.reduce((sum, t) => sum + (parseInt(t.settings.seeds) || 1), 0);

            // Count total requests for progress
            const totalRequests = batchImageCount;
            let completedCount = 0;

            const updateProgress = () => {
                if (ecomGlobalLoader.progressElement) {
                    ecomGlobalLoader.progressElement.textContent = `${completedCount}/${totalRequests} complete`;
                }
                const count = document.getElementById('global-results-count');
                count.textContent = `${globalResults.length} images | ${completedCount}/${totalRequests} generating`;
            };

            ecomGlobalLoader.start(`Generating ${totalRequests} images...`);
            updateProgress();

            // Timestamp helper for logging
            const ts = () => new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' }) + '.' + String(Date.now() % 1000).padStart(3, '0');

            // Process tasks with controlled concurrency (MAX_CONCURRENT at a time)
            let activeCount = 0;
            let taskIndex = 0;
            const results = [];

            const processTask = async (task) => {
                const { shotType, product, selectedImgs, selectedModels, selectedFootwear = [], selectedBottoms = [], selectedTops = [], guide, poseMode, settings: taskSettings } = task;
                const startTime = new Date();
                const shortGuide = guide ? guide.file.replace('.png', '').slice(0, 20) : 'None';

                try {
                    // Helper to fetch an image and convert to base64
                    const fetchImageBase64 = async (url) => {
                        const response = await fetch(url);
                        const blob = await response.blob();
                        return { url, base64: await blobToBase64(blob) };
                    };

                    // Build all image URLs to fetch in parallel (maintaining order)
                    const imageFetchPromises = [];
                    const imageOrder = []; // Track order: 'model', 'product', 'footwear', 'bottoms', 'guide'

                    // For belt shots, put guide FIRST (reference image gets more weight)
                    const isBeltShot = shotType === 'belt';
                    if (isBeltShot && guide) {
                        let guideUrl;
                        if (guide.isPhotoRef) {
                            guideUrl = guide.folder === 'canny'
                                ? `/assets/brand/rondorff/canny/refs/${guide.file}`
                                : `/assets/brand/rondorff/refs/${guide.folder}/${guide.file}`;
                        } else {
                            guideUrl = `/assets/brand/rondorff/canny/guides/${guide.file}`;
                        }
                        imageFetchPromises.push(fetchImageBase64(guideUrl));
                        imageOrder.push('guide');
                    }

                    // Queue model portraits first (but not for belt shots)
                    if (!isBeltShot) {
                        for (const model of selectedModels) {
                            imageFetchPromises.push(fetchImageBase64(model.full));
                            imageOrder.push('model');
                        }
                    }

                    // Queue product images
                    for (const img of selectedImgs) {
                        const imgUrl = `/assets/brand/rondorff/ecom/originals/${img}`;
                        imageFetchPromises.push(fetchImageBase64(imgUrl));
                        imageOrder.push('product');
                    }

                    // Queue footwear images (for bottoms 3/4 shots)
                    for (const shoe of selectedFootwear) {
                        imageFetchPromises.push(fetchImageBase64(shoe.full));
                        imageOrder.push('footwear');
                    }

                    // Queue bottoms images (for tops like shirts, tank tops)
                    for (const bottom of selectedBottoms) {
                        imageFetchPromises.push(fetchImageBase64(bottom.full));
                        imageOrder.push('bottoms');
                    }

                    // Queue tops images (for accessories like tote bags)
                    for (const top of selectedTops) {
                        imageFetchPromises.push(fetchImageBase64(top.full));
                        imageOrder.push('tops');
                    }

                    // Queue guide if selected (canny or photo ref)
                    // Skip if belt shot - guide was already added first
                    if (guide && !isBeltShot) {
                        let guideUrl;
                        if (guide.isPhotoRef) {
                            guideUrl = guide.folder === 'canny'
                                ? `/assets/brand/rondorff/canny/refs/${guide.file}`
                                : `/assets/brand/rondorff/refs/${guide.folder}/${guide.file}`;
                        } else {
                            guideUrl = `/assets/brand/rondorff/canny/guides/${guide.file}`;
                        }
                        imageFetchPromises.push(fetchImageBase64(guideUrl));
                        imageOrder.push('guide');
                    }

                    // Fetch ALL images in parallel
                    const fetchedImages = await Promise.all(imageFetchPromises);

                    // Collect in order
                    const imageBase64s = fetchedImages.map(img => img.base64);
                    const inputImageUrls = fetchedImages.map(img => img.url);

                    // Use V2 prompt builder for V2 tasks, otherwise use the regular builder
                    const prompt = task.isV2
                        ? buildPromptV2(shotType, product, selectedImgs, guide)
                        : buildPromptWithGuide(shotType, product, selectedImgs, selectedModels, guide, selectedFootwear, selectedBottoms, selectedTops, poseMode);
                    const numSeeds = parseInt(taskSettings.seeds) || 1;
                    const provider = taskSettings.provider || 'gemini';

                    // Log generation start (concise with timestamp)
                    console.log(`[${ts()}] ðŸš€ START | ${product.sku} | ${shotType} | ${shortGuide} | ${imageBase64s.length} imgs`);

                    // Send all seed requests in parallel
                    const seedPromises = [];
                    for (let seed = 0; seed < numSeeds; seed++) {
                        let fetchPromise;

                        if (provider === 'gemini') {
                            // Gemini uses base64 directly
                            fetchPromise = fetch('/api/remix-gemini', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    model: 'gemini-3-pro',
                                    prompt: prompt,
                                    image_base64s: imageBase64s,
                                    aspect_ratio: taskSettings.aspect,
                                    resolution: taskSettings.resolution,
                                    num_images: 1
                                })
                            }).then(res => res.json());
                        } else {
                            // FAL needs URLs - upload ALL base64 images in PARALLEL
                            fetchPromise = (async () => {
                                console.log(`[FAL Upload] Starting PARALLEL upload of ${imageBase64s.length} images...`);

                                // Upload all images in parallel
                                const uploadPromises = imageBase64s.map(async (base64, i) => {
                                    try {
                                        const uploadRes = await fetch('/api/upload-base64', {
                                            method: 'POST',
                                            headers: { 'Content-Type': 'application/json' },
                                            body: JSON.stringify({ dataUrl: base64 })
                                        });
                                        if (!uploadRes.ok) {
                                            console.error(`[FAL Upload] Upload ${i + 1} failed: ${uploadRes.status}`);
                                            return null;
                                        }
                                        const uploadData = await uploadRes.json();
                                        if (uploadData.url) {
                                            console.log(`[FAL Upload] âœ… Image ${i + 1} uploaded`);
                                            return uploadData.url;
                                        }
                                        return null;
                                    } catch (uploadErr) {
                                        console.error(`[FAL Upload] âŒ Exception uploading image ${i + 1}:`, uploadErr);
                                        return null;
                                    }
                                });

                                const uploadResults = await Promise.all(uploadPromises);
                                const imageUrls = uploadResults.filter(url => url !== null);
                                console.log(`[FAL Upload] Upload complete: ${imageUrls.length}/${imageBase64s.length} images`);

                                const res = await fetch('/api/remix', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        model: 'nano-pro',
                                        prompt: prompt,
                                        image_urls: imageUrls,
                                        aspect_ratio: taskSettings.aspect,
                                        resolution: taskSettings.resolution,
                                        num_images: 1,
                                        output_format: 'png'
                                    })
                                });
                                return res.json();
                            })();
                        }

                        seedPromises.push(fetchPromise);
                    }

                    // Wait for this task's seeds
                    const results = await Promise.all(seedPromises);
                    const elapsed = ((new Date() - startTime) / 1000).toFixed(1);
                    const successCount = results.filter(r => r.images?.length > 0).length;
                    console.log(`[${ts()}] âœ… DONE  | ${product.sku} | ${shotType} | ${successCount}/${numSeeds} ok | ${elapsed}s`);

                    // Collect results and add to grid immediately
                    const taskResults = [];
                    results.forEach((data, seed) => {
                        completedCount++;
                        updateProgress();

                        if (data.images?.length > 0) {
                            data.images.forEach((img) => {
                                const result = {
                                    url: img.url || `data:image/png;base64,${img.base64}`,
                                    shotType: shotType,
                                    poseType: guide?.poseType || null,
                                    product: product.name,
                                    sku: product.sku,
                                    prompt: prompt,
                                    inputImages: [...inputImageUrls],
                                    _product: product
                                };
                                // Add to global results immediately and render
                                globalResults.push({
                                    ...result,
                                    filename: generateFilename(result._product, result.shotType, globalResults.length, result.poseType),
                                    batch: currentBatch,
                                    batchProduct: batchProduct,
                                    batchTotal: batchImageCount
                                });
                                renderGlobalResults();
                                taskResults.push(result);
                            });
                        }
                    });
                    return taskResults;

                } catch (error) {
                    const elapsed = startTime ? ((new Date() - startTime) / 1000).toFixed(1) : '?';
                    console.error(`[${ts()}] âŒ ERROR | ${product.sku} | ${shotType} | ${elapsed}s | ${error.message}`);
                    return [];
                }
            };

            // Process tasks with MAX_CONCURRENT limit
            const runWithConcurrency = () => {
                return new Promise((resolve) => {
                    let completed = 0;

                    const startNext = () => {
                        while (activeCount < MAX_CONCURRENT && taskIndex < allTasks.length) {
                            const task = allTasks[taskIndex++];
                            activeCount++;
                            processTask(task).then((result) => {
                                results.push(result);
                                activeCount--;
                                completed++;
                                if (completed === allTasks.length) {
                                    resolve();
                                } else {
                                    startNext();
                                }
                            });
                        }
                    };

                    startNext();
                });
            };

            // Wait for ALL tasks to complete with concurrency limit
            await runWithConcurrency();

            // Final render to ensure everything is up to date
            renderGlobalResults();

            // Reset all buttons
            allTasks.forEach(task => {
                const btn = document.querySelector(`.category-row[data-shot-type="${task.shotType}"] .category-generate-btn`);
                if (btn) {
                    btn.textContent = `Generate ${task.shotType.replace('_', ' ')}`;
                }
            });

            ecomGlobalLoader.stop();
            isProcessingQueue = false;
            updateQueueStatus();

            // Check if more items were added to queue during processing
            if (generationQueue.length > 0) {
                processQueue();
            }
        }

        // Render global results
        function renderGlobalResults() {
            const section = document.getElementById('global-results-section');
            const grid = document.getElementById('global-results-grid');
            const count = document.getElementById('global-results-count');
            count.textContent = `${globalResults.length} image${globalResults.length !== 1 ? 's' : ''}`;

            // Show/hide section based on results
            if (globalResults.length > 0) {
                section.classList.add('has-results');
            } else {
                section.classList.remove('has-results');
            }

            // Initialize shared lightbox if not already (with PNG download handler)
            if (!ecomLightbox) {
                ecomLightbox = new Lightbox({
                    onDownload: async (url, filename) => {
                        // Convert to PNG using canvas
                        const img = new Image();
                        img.crossOrigin = 'anonymous';
                        img.onload = () => {
                            const canvas = document.createElement('canvas');
                            canvas.width = img.naturalWidth;
                            canvas.height = img.naturalHeight;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0);
                            canvas.toBlob((blob) => {
                                const a = document.createElement('a');
                                a.href = URL.createObjectURL(blob);
                                a.download = filename.endsWith('.png') ? filename : filename + '.png';
                                a.click();
                                URL.revokeObjectURL(a.href);
                            }, 'image/png');
                        };
                        img.onerror = () => window.open(url, '_blank');
                        img.src = url;
                    }
                });
            }

            // Group results by batch and render with headers
            let html = '';
            let currentBatchNum = null;
            globalResults.forEach((r, i) => {
                // Add batch header if this is a new batch
                if (r.batch !== currentBatchNum) {
                    currentBatchNum = r.batch;
                    const batchResults = globalResults.filter(res => res.batch === r.batch);
                    html += `<div class="batch-header" style="grid-column: 1 / -1; padding: 12px 0 8px 0; border-top: ${r.batch > 1 ? '1px solid #e5e5e5' : 'none'}; margin-top: ${r.batch > 1 ? '12px' : '0'};">
                        <span style="font-weight: 600; font-size: 13px;">Batch ${r.batch}</span>
                        <span style="color: #666; font-size: 12px; margin-left: 8px;">${batchResults.length} images - ${r.batchProduct}</span>
                    </div>`;
                }
                html += `
                <div class="global-result-item" data-index="${i}">
                    <img src="${r.url}" alt="${r.shotType}">
                    <div class="global-result-info">
                        <div>
                            <div class="global-result-label">${r.shotType.replace('_', ' ')}</div>
                            <div class="global-result-meta">${r.sku}</div>
                        </div>
                        <div class="global-result-actions">
                            <button class="btn" onclick="event.stopPropagation(); downloadResult('${r.url}', '${r.filename}')">DL</button>
                        </div>
                    </div>
                </div>`;
            });
            grid.innerHTML = html;

            // Add click handlers for lightbox
            grid.querySelectorAll('.global-result-item').forEach(item => {
                item.addEventListener('click', () => {
                    const index = parseInt(item.dataset.index);
                    const lightboxResults = globalResults.map(r => ({
                        url: r.url,
                        prompt: r.prompt || '',
                        modelName: 'Ron Dorff Ecom',
                        filename: r.filename,
                        inputImages: r.inputImages || []
                    }));
                    ecomLightbox.setResults(lightboxResults);
                    ecomLightbox.open(index);
                });
            });
        }

        function clearGlobalResults() {
            globalResults = [];
            renderGlobalResults();
        }

        async function downloadResult(url, filename) {
            // Convert to PNG using canvas
            const img = new Image();
            img.crossOrigin = 'anonymous';

            img.onload = () => {
                const canvas = document.createElement('canvas');
                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);

                canvas.toBlob((blob) => {
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = filename + '.png';
                    a.click();
                    URL.revokeObjectURL(a.href);
                }, 'image/png');
            };

            img.src = url;
        }

        // Build eyelet detail prompt
        function buildEyeletPrompt(product, hasGuide = false) {
            const productDesc = `Ron Dorff ${product.name} in ${product.color}, ${product.material}`;

            if (hasGuide) {
                return `Eyelet detail shot of ${productDesc}.

LINE DRAWING GUIDE (last image) shows the composition - follow it exactly.

GARMENT: Laid completely flat on white surface like a flat-lay product photo. NOT folded, NOT bunched. The hem/edge of garment visible at bottom. Fabric smooth and fills most of frame.

EYELETS: Copy the EXACT Ron Dorff metal eyelets from the product images. Two eyelets positioned as shown in guide.

${product.color} fabric texture (${product.material}). White studio background. Macro photography.`;
            }

            return `Macro detail shot of the metal eyelets on ${productDesc}.

GARMENT: Laid FLAT and SPREAD OUT on white surface, not folded. Fabric fills bottom of frame.

Copy the EXACT eyelets from the reference images. Two eyelets visible. Show the ${product.color} fabric texture.

Clean white studio background. Professional macro photography.`;
        }

        // Build prompt for PHOTO REFERENCE (not canny line drawing)
        // Get product-specific clothing details for on-model prompts
        function getProductClothingDetails(product) {
            const name = product.name.toLowerCase();
            const sku = product.sku;

            // Crochet Knit Shirt
            if (name.includes('crochet') && name.includes('shirt')) {
                return `CRITICAL GARMENT DETAILS - MUST BE EXACT:
- STYLE: Short-sleeve button-up SHIRT with CAMP COLLAR (Cuban collar - open, relaxed neckline)
- BUTTONS: 5 visible buttons down the center front placket
- TEXTURE: Open-weave CROCHET KNIT - airy texture with visible holes in the weave
- EYELETS: Two small black metal Ron Dorff eyelets near the bottom hem
- FIT: Relaxed, casual fit
DO NOT generate a sweater, polo, or t-shirt. This is a BUTTON-UP SHIRT with a collar.`;
            }

            // Crochet Knit Tank Top
            if (name.includes('crochet') && name.includes('tank')) {
                return `CRITICAL GARMENT DETAILS - MUST BE EXACT:
- STYLE: Sleeveless TANK TOP with scoop neckline
- TEXTURE: Open-weave CROCHET KNIT - airy texture with visible holes in the weave
- LABEL: Ron Dorff label visible at inside neckline
- EYELETS: Two small black metal Ron Dorff eyelets near the bottom hem
- FIT: Relaxed fit`;
            }

            // Swim Briefs
            if (name.includes('swim briefs') || name.includes('slim swim')) {
                return `CRITICAL GARMENT DETAILS - MUST BE EXACT:
- STYLE: Low-rise swim briefs / speedo style
- WAISTBAND: Elastic waistband with drawstring
- EYELETS: Two small black metal Ron Dorff eyelets on the side
- FIT: Fitted, athletic cut`;
            }

            // Swim Shorts
            if (name.includes('swim shorts')) {
                return `CRITICAL GARMENT DETAILS - MUST BE EXACT:
- STYLE: Mid-thigh swim shorts
- WAISTBAND: Elastic waistband with drawstring
- EYELETS: Two small black metal Ron Dorff eyelets near hem
- FIT: Regular fit`;
            }

            // Tennis/Sports Shorts
            if (name.includes('tennis') || name.includes('corduroy')) {
                return `CRITICAL GARMENT DETAILS - MUST BE EXACT:
- STYLE: Tennis shorts / sports shorts
- TEXTURE: Fine corduroy fabric with vertical ribs
- WAISTBAND: With belt loops or elastic
- EYELETS: Two small black metal Ron Dorff eyelets near hem
- FIT: Athletic fit`;
            }

            // T-Shirts
            if (name.includes('t-shirt') || name.includes('tee')) {
                return `CRITICAL GARMENT DETAILS - MUST BE EXACT:
- STYLE: Crew neck T-shirt
- TEXTURE: Smooth cotton fabric
- EYELETS: Two small black metal Ron Dorff eyelets near bottom hem
- FIT: Regular fit`;
            }

            // Sweatshirt / Sleeveless
            if (name.includes('sweatshirt') || name.includes('sleeveless')) {
                return `CRITICAL GARMENT DETAILS - MUST BE EXACT:
- STYLE: Sleeveless top
- NECKLINE: As shown in product images
- CONSTRUCTION: Quality stitching and finishing
- FIT: As shown in product images`;
            }

            // Minimal coverage briefs/underwear
            if (name.includes('briefs') || name.includes('underwear') || name.includes('Briefs')) {
                return `CRITICAL GARMENT DETAILS - MUST BE EXACT:
- STYLE: Minimal coverage - thin side straps, high-cut leg openings, V-front design
- NOT regular briefs - this is a minimal/string style
- WAISTBAND: Thin elastic waistband
- Copy the EXACT garment shape from product input images`;
            }

            // Default
            return `Copy the EXACT garment construction, style, and details from product input images.
Match every visible detail: collar type, buttons, seams, pockets, texture.`;
        }

        function buildPhotoRefPrompt(product, guideType, guideInfo, selectedFootwear = [], selectedBottoms = [], poseMode = 'copy', shotType = null) {
            // Simplified product name
            const shortName = product.name.replace('Organic Cotton ', '').replace('100% ', '');
            const refDesc = guideInfo?.description || 'garment in reference photo';
            // Check if footwear is selected (for 3/4 shots)
            const hasFootwear = selectedFootwear.length > 0;
            const footwearDesc = hasFootwear ? selectedFootwear.map(f => f.description).join(', ') : null;
            // Check if bottoms are selected (for tops like shirts, tank tops)
            const hasBottoms = selectedBottoms.length > 0;
            const bottomsDesc = hasBottoms ? selectedBottoms.map(b => b.description).join(', ') : null;

            if (guideType === 'eyelet') {
                // Check if this is a small eyelet reference
                const isSmallEyelet = guideInfo?.smallEyelet === true;
                const eyeletSizeNote = isSmallEyelet
                    ? 'SMALLER sized BLACK metal Ron Dorff eyelets (smaller than standard size) with white "RON DORFF PARIS STOCKHOLM" text engraved'
                    : 'BLACK metal Ron Dorff eyelets with white "RON DORFF PARIS STOCKHOLM" text engraved around them';

                return `PHOTO REFERENCE - Match this exact composition.

The LAST image is a PHOTO showing an eyelet detail shot. Match this EXACT composition.

COMPOSITION - COPY FROM REFERENCE PHOTO:
- Fabric laid FLAT at 45-degree DIAGONAL angle (like the reference)
- Corner/edge of garment visible at bottom
- Two eyelets in diagonal arrangement
- Match the EXACT framing and crop

REPLACE with ${product.color} ${shortName}:
- Use the ${product.color} color from input images 1-2
- Use the exact fabric texture from input images
- ${eyeletSizeNote}

LIGHTING: BRIGHT, CLEAN, EVEN studio lighting. Well-lit exposure. NO dark shadows. NO moody lighting. NO dramatic lighting. Professional e-commerce product photo style.

BACKGROUND: Light warm gray studio surface.`;
            }

            if (guideType === 'collar') {
                return `PHOTO REFERENCE - Match this exact collar composition.

The LAST image is a PHOTO showing a collar/neckline shot. Copy this EXACT composition.

CRITICAL COMPOSITION from reference photo:
- SLIGHTLY ANGLED view (NOT flat top-down) - the camera should be at a slight angle showing depth
- Ron Dorff label/tag prominently visible at the neckline
- Neckline should be STRAIGHT and CLEAN - not wobbly or distorted
- Match the exact framing, crop, and perspective from the reference

REPLACE the garment with ${product.color} ${shortName}:
- Copy the EXACT ${product.color} color from input images 1-2
- Copy the EXACT fabric texture from input images (${product.material})
- Texture should be clean and precise - match the material appearance from the input

QUALITY:
- Fabric texture must be clean and match the input images exactly
- Neckline edge must be smooth and straight
- Professional e-commerce quality

Light warm gray studio background. Bright professional lighting.`;
            }

            if (guideType === 'belt') {
                return `PHOTO REFERENCE - Match this exact composition.

The LAST image is a PHOTO showing a waistband detail shot. Match this EXACT composition.

COMPOSITION - COPY FROM REFERENCE PHOTO:
- Camera at LOW, SHALLOW angle - almost parallel to fabric surface
- Waistband runs DIAGONALLY across TOP of frame
- NOT too close-up - match the framing from reference photo exactly
- Show waistband area with some fabric below, not extreme close-up
- Garment laid PERFECTLY FLAT - smooth, no wrinkles
- Drawstrings (if present) hanging straight down, perfectly parallel and symmetrical
- Match the EXACT framing, crop, and zoom level from reference

REPLACE with ${product.color} ${shortName}:
- Use the ${product.color} color from input images
- Use the exact fabric texture from input images (${product.material})

LIGHTING: BRIGHT, CLEAN, EVEN studio lighting. Well-lit exposure. NO dark shadows. NO moody lighting. NO dramatic lighting. Professional e-commerce product photo style.

BACKGROUND: Light warm gray studio surface.`;
            }

            if (guideType === 'sleeves') {
                return `PHOTO REFERENCE - Match this exact composition.

The LAST image is a PHOTO showing a sleeve detail shot. Match this EXACT composition.

COMPOSITION - COPY FROM REFERENCE PHOTO:
- Camera at TOP-DOWN 45-degree angle looking down at sleeve
- Sleeve spread naturally to the side from body
- Part of shoulder seam visible for context
- Match the EXACT framing, crop, and angle from reference

CRITICAL - FABRIC MUST BE:
- Laid PERFECTLY FLAT - completely smooth
- NO wrinkles, NO folds, NO bunching, NO puffiness
- Clean, crisp edges
- Fabric should look pressed and professional

REPLACE with ${product.color} ${shortName}:
- Use the ${product.color} color from input images
- Copy the exact fabric texture from input images
- Show sleeve construction and hem finishing

LIGHTING: BRIGHT, CLEAN, EVEN studio lighting. Well-lit exposure. NO dark shadows. NO moody lighting. NO dramatic lighting. This should look like a BRIGHT, clean product photo - NOT dark or underexposed.

BACKGROUND: LIGHT warm gray studio surface - bright and clean, NOT dark.`;
            }

            if (guideType === 'print') {
                return `REFERENCE PHOTO (last image) shows the EXACT print/graphic composition to recreate.

COMPOSITION - MATCH REFERENCE PHOTO EXACTLY:
- SLIGHTLY ANGLED view (NOT flat top-down) - camera at slight angle showing depth
- Match the EXACT camera angle from the reference photo
- Collar/neckline visible at top of frame
- Print area clearly visible on chest
- Garment laid flat but photographed at an ANGLE

CRITICAL - DO NOT copy the text/logo from the reference photo.
REPLACE it with the actual print from ${product.color} ${shortName} input images.

USE from product images 1-2:
- ${product.color} color and gradient
- The ACTUAL print/graphic from the product
- Fabric texture

BRIGHT, CLEAN, EVEN studio lighting. Light warm gray background.`;
            }

            if (guideType === 'fabrics') {
                return `REFERENCE PHOTO (last image) shows the EXACT fabric detail composition to recreate.

Create the SAME shot but with ${product.color} ${shortName} fabric instead.

COPY EXACTLY from reference:
- Camera angle (macro close-up)
- The framing and crop
- How the fabric fills the frame

USE from product images:
- ${product.color} fabric weave/texture (copy exactly)
- Material quality and construction

Extreme macro detail shot. Light warm gray background.`;
            }

            if (guideType === 'flatlay' || guideType === 'flat_lay') {
                return `PHOTO REFERENCE - Match this exact composition.

The LAST image is a PHOTO showing a flat lay. Match this EXACT composition.

COMPOSITION - COPY FROM REFERENCE PHOTO:
- Top-down flat lay angle
- Garment laid FLAT, fabric completely smooth
- Drawstrings (if present): Out and laid flat pointing down - match the EXACT LENGTH from reference photo, do NOT make them longer
- Match the EXACT framing and crop from reference

REPLACE with ${product.color} ${shortName}:
- Use the ${product.color} color from input images
- Use the exact fabric texture from input images (${product.material})
- All product details (labels, eyelets, construction)

LIGHTING: BRIGHT, CLEAN, EVEN studio lighting. Well-lit exposure. NO dark shadows. NO moody lighting. NO dramatic lighting. Professional e-commerce product photo style.

BACKGROUND: Light warm gray studio surface.`;
            }

            if (guideType === 'face' || guideType === '3/4' || guideType === 'on-model') {
                // For on-model shots, use poseType from guideInfo to determine framing
                // For legacy face/3/4, use guideType directly
                const poseType = guideInfo?.poseType || (guideType === 'face' ? 'front' : guideType === '3/4' ? '3/4' : 'front');
                const isFaceShot = poseType === 'front';
                const is34Shot = poseType === '3/4';

                // Check product categories
                const isShorts = product.category.toLowerCase().includes('shorts');
                const isBriefs = product.category.toLowerCase().includes('briefs') ||
                                 product.category.toLowerCase().includes('underwear') ||
                                 product.category.toLowerCase().includes('y-front');
                const isBottoms = isShorts || isBriefs;
                const isSwimwear = product.category.toLowerCase().includes('swim');
                const isAccessory = product.category.toLowerCase().includes('accessories');
                const isBag = product.name.toLowerCase().includes('bag') || product.name.toLowerCase().includes('tote');
                const isCap = product.name.toLowerCase().includes('cap');

                // Only shorts (non-swim) need a t-shirt - briefs/underwear should be shirtless
                const needsTop = isShorts && !isSwimwear;

                // Footwear note (for shorts/bottoms)
                const footwearNote = hasFootwear ? `FOOTWEAR: ${footwearDesc} (copy from footwear input image)` : '';

                // Bottoms note (for tops like shirts, tank tops)
                const isTop = !isBottoms && !isAccessory && !isBag && !isCap;
                const bottomsNote = hasBottoms && isTop ? `BOTTOMS: ${bottomsDesc} (copy from bottoms input image)` : '';

                // Upper body clothing for non-swim shorts only
                const topNote = needsTop ? 'UPPER BODY: Model wears plain white t-shirt.' : '';

                // Framing - briefs = thighs up (like reference), shorts = waist-down
                let framingNote;
                if (isBriefs) {
                    framingNote = 'FRAMING: THIGHS UP. Match reference photo - show briefs, thighs, and lower torso. Follow reference composition.';
                } else if (isShorts) {
                    framingNote = 'FRAMING: WAIST-DOWN ONLY. Crop at waist - show legs and feet only. Do NOT show face or upper body.';
                } else {
                    framingNote = 'FRAMING: Match reference photo crop exactly.';
                }

                // Pose and direction based on shot type
                const directionNote = isFaceShot
                    ? 'DIRECTION: Model facing STRAIGHT toward camera. Front view.'
                    : 'DIRECTION: Body turned 45Â° but facing camera. Three-quarter angle, NOT back.';

                const poseNote = poseMode === 'copy'
                    ? 'POSE: Copy EXACT pose from reference.'
                    : 'POSE: Dynamic variation of reference pose.';

                // Special handling for accessories (bags, caps)
                if (isAccessory || isBag || isCap) {
                    const productNote = isBag
                        ? `PRODUCT: Copy the EXACT ${product.color} ${shortName} from images 2+.
CRITICAL - BAG MUST BE PRISTINE:
- NO wrinkles, NO creases, NO folds
- Canvas/fabric looks brand new, smooth, clean
- Colors and print clearly visible`
                        : `PRODUCT: Copy the EXACT ${product.color} ${shortName} from images 2+.
- Product must look pristine, clean, brand new`;

                    return `PROFESSIONAL STUDIO ON-MODEL PHOTO.

IMAGES: 1=Model, 2+=Product, Last=Reference

MODEL: Copy the EXACT model from image 1 - same face, same body, same skin tone.
${productNote}

${poseNote}
${framingNote}
${directionNote}

STUDIO QUALITY: High-end e-commerce catalog photography.
LIGHTING & BACKGROUND: Copy EXACTLY from reference photo.`;
                }

                return `E-COMMERCE ON-MODEL PHOTO.

IMAGES: 1=Model, 2+=Product (${shortName}), Last=Reference

CRITICAL - MODEL IDENTITY:
- MODEL: Copy the EXACT person from image 1 - SAME FACE, same hair color, same skin tone, same body type.
- Do NOT change the model's appearance. The generated person must look IDENTICAL to image 1.

CRITICAL - COMPOSITION:
- ${framingNote}
- ${directionNote}
- LIGHTING & BACKGROUND: Copy EXACTLY from reference photo (last image). Match the gray tone and lighting.

${poseNote}
CLOTHING: ${product.color} ${shortName} - copy garment EXACTLY from images 2+. Match all details: color, texture, construction.
${topNote}
${footwearNote}
${bottomsNote}`;
            }

            // Default photo ref prompt
            return `REFERENCE PHOTO (last image) shows the EXACT composition to recreate.

Create the SAME shot but with ${product.color} ${shortName} instead of the garment in reference.

COPY EXACTLY from reference:
- Camera angle and perspective
- Composition and framing
- How the garment is positioned

USE from product images:
- ${product.color} color and texture (copy exactly)

White/grey studio background.`;
        }

        // Build prompt with optional canny guide
        function buildPromptWithGuide(shotType, product, selectedImgs, selectedModels, guideInfo, selectedFootwear = [], selectedBottoms = [], selectedTops = [], poseMode = 'copy') {
            const productDesc = `Ron Dorff ${product.name} in ${product.color}, ${product.material}`;
            const guideType = guideInfo?.type || null;

            // For on-model shots (or legacy face/3/4) WITH photo reference:
            // First check for product-specific prompt, then fall back to generic photo ref prompt
            if ((shotType === 'face' || shotType === '3/4' || shotType === 'on-model') && guideInfo && guideInfo.isPhotoRef) {
                // Check for product-specific override first
                // For on-model, use poseType to determine the override key (front->front, 3/4->3/4)
                const effectiveShotType = shotType === 'on-model'
                    ? (guideInfo.poseType === 'front' ? 'front' : '3/4')
                    : shotType;
                const overridePrompt = getPromptOverride(product.sku, effectiveShotType, guideInfo?.type || null);
                if (overridePrompt) {
                    // Build context descriptions for all placeholders
                    const productDesc = `${product.color} ${product.name}`;
                    const shortProductName = product.name.replace('Organic Cotton ', '').replace('100% ', '');

                    // Model description from selectedModels (first model if multiple)
                    const modelDesc = selectedModels.length > 0
                        ? selectedModels[0].description
                        : 'athletic male model';

                    // Bottoms description - combine all selected
                    const bottomsDesc = selectedBottoms.length > 0
                        ? selectedBottoms.map(b => b.description).join(' and ')
                        : 'neutral bottoms';

                    // Footwear description - combine all selected
                    const footwearDesc = selectedFootwear.length > 0
                        ? selectedFootwear.map(f => f.description).join(' and ')
                        : 'barefoot';

                    // Replace all placeholders
                    let finalPrompt = overridePrompt
                        .replace(/\{\{productDesc\}\}/g, productDesc)
                        .replace(/\{\{shortProductName\}\}/g, shortProductName)
                        .replace(/\{\{modelDesc\}\}/g, modelDesc)
                        .replace(/\{\{bottomsDesc\}\}/g, bottomsDesc)
                        .replace(/\{\{footwearDesc\}\}/g, footwearDesc)
                        .replace(/\{\{productColor\}\}/g, product.color)
                        .replace(/\{\{productMaterial\}\}/g, product.material);

                    return finalPrompt;
                }
                // No fallback for on-model - throw error so we know prompt is missing
                throw new Error(`MISSING PROMPT: No '${effectiveShotType}' prompt in ${product.sku}.json`);
            }

            // For BACK shots with flatlay guides/refs - same as flatlay but specify BACK view
            if (shotType === 'back' && guideInfo && guideInfo.isPhotoRef) {
                const shortName = product.name.replace('Organic Cotton ', '').replace('100% ', '');
                return `PHOTO REFERENCE - Back view flat lay matching reference photo composition.

The LAST image is a PHOTO showing a flat lay composition. COPY this EXACT composition but show the BACK of the garment.

CRITICAL: Show the BACK of ${product.color} ${shortName} (reverse side), NOT the front.

COMPOSITION - COPY FROM REFERENCE PHOTO:
- Camera angle: Top-down flat lay
- Garment laid completely FLAT on surface
- Fabric smooth, no wrinkles or bunching
- Match garment positioning and layout from reference
- Match the overall framing and crop

USE from product images:
- ${product.color} color - match precisely from input images
- ${product.material} fabric texture - copy exactly
- Show back construction: seams, stitching, any back labels
- Drawstrings (if present): laid flat, pointing down, symmetrical

LIGHTING: BRIGHT, CLEAN, EVEN studio lighting. Well-lit exposure. NO dark shadows. NO moody lighting.

BACKGROUND: LIGHT warm gray studio surface. Clean, seamless backdrop.`;
            }

            // ALWAYS check for product-specific override FIRST (for both photo ref and canny guides)
            // This ensures each product's unique prompts take precedence over generic fallbacks
            const overridePrompt = getPromptOverride(product.sku, shotType, guideType);
            if (overridePrompt) {
                // Replace {{productDesc}} placeholder if used in override
                return overridePrompt.replace(/\{\{productDesc\}\}/g, productDesc);
            }

            // PHOTO REFERENCE - use generic photo ref prompts if no product-specific override
            if (guideInfo && guideInfo.isPhotoRef) {
                return buildPhotoRefPrompt(product, guideType, guideInfo, selectedFootwear, selectedBottoms, poseMode, shotType);
            }

            // If canny guide is selected, use guide-aware prompts
            if (guideInfo) {

                // CANNY GUIDE prompts
                if (guideType === 'flatlay') {
                    // Check if this is a BACK shot
                    const isBackShot = shotType === 'back';
                    const viewNote = isBackShot ? ' Show the BACK of the garment (reverse side).' : '';

                    // Add label visibility for tank tops (only for front)
                    const labelNote = !isBackShot && product.name.toLowerCase().includes('tank')
                        ? ' Ron Dorff label visible at neckline.'
                        : '';
                    // Add eyelet visibility for products with eyelets (only for front)
                    const eyeletNote = !isBackShot && product.shotTypes?.includes('eyelet')
                        ? ' Two metal Ron Dorff eyelets visible at bottom hem.'
                        : '';

                    return `Professional e-commerce flat lay photograph of ${productDesc}.${viewNote}

COMPOSITION: Follow the line drawing guide (last image) for garment placement and layout.

STYLING: Garment laid perfectly flat with clean, refined presentation. Fabric smooth and unwrinkled. Natural sleeve/armhole positioning.${isBackShot ? '' : ' Collar neatly shaped.'}${labelNote}${eyeletNote}

LIGHTING: Professional soft studio lighting with even, diffused illumination. No harsh shadows. Clean, consistent exposure across the garment.

BACKGROUND: Light warm gray studio surface (not pure white). Seamless, clean backdrop.

High-end fashion e-commerce aesthetic. Minimal and sophisticated.`;
                } else if (guideType === 'eyelet') {
                    return buildEyeletPrompt(product, true);
                } else if (guideType === 'collar') {
                    return `E-commerce collar/neckline detail shot of ${productDesc}.

CRITICAL - CANNY GUIDE (last image):
The LAST image is a BLACK AND WHITE LINE DRAWING showing the EXACT composition. You MUST:
- Position the garment EXACTLY as shown in the line drawing
- Match the same camera angle (top-down 45-degree)
- Match the same garment layout, collar shape, and positioning
- The line drawing is your composition blueprint - follow it PRECISELY

COPY FROM PRODUCT INPUT IMAGES (images 1-2):
- EXACT color from the input images - match the garment color precisely
- EXACT fabric texture from the input images
- All garment details (labels, construction)

STYLING: Garment laid COMPLETELY FLAT on the surface. NO bunching, NO wrinkles, NO 3D folds.

LIGHTING: BRIGHT professional studio lighting. Clean, even exposure.

BACKGROUND: Light warm gray studio surface.`;
                } else if (guideType === 'fabrics') {
                    return `Macro texture close-up of the fabric on ${productDesc}.

CRITICAL: Use the last image (black and white line drawing) as the EXACT composition guide for camera angle and framing.

Extreme close-up showing the weave pattern, material texture, and fabric quality. Top-down 45-degree angle. Clean white studio background. Professional macro photography highlighting craftsmanship.`;
                } else if (guideType === 'sleeves') {
                    return `Detail shot of the sleeve construction on ${productDesc}.

CRITICAL: Use the last image (black and white line drawing) as the EXACT composition guide. Match the angle and framing precisely.

Close-up of sleeve with visible stitching and construction details. Top-down 45-degree angle. Garment arranged as shown in guide. Clean white studio background. Professional e-commerce detail photography.`;
                } else if (guideType === 'belt') {
                    return `Detail shot of the waistband/belt area on ${productDesc}.

CRITICAL: Use the last image (black and white line drawing) as the EXACT composition guide. Match the framing precisely.

Top-down 45-degree angle. Focus on waistband construction, drawstring, or elastic details. Garment arranged as shown in guide. Clean white studio background. Professional detail photography.`;
                }
            }

            // No guide selected - use standard prompts
            // Build flat lay prompt with product-specific details
            const labelNote = product.name.toLowerCase().includes('tank')
                ? ' Ron Dorff label visible at neckline.'
                : '';
            const eyeletNote = product.shotTypes?.includes('eyelet')
                ? ' Two metal Ron Dorff eyelets visible at bottom hem.'
                : '';
            const flatLayPrompt = `Professional e-commerce flat lay photograph of ${productDesc}. Bird's eye view on light warm gray studio background. Garment laid perfectly flat with clean, refined presentation. Fabric smooth and unwrinkled.${labelNote}${eyeletNote} Professional soft studio lighting with even, diffused illumination. High-end fashion e-commerce aesthetic.`;

            const basePrompts = {
                'flat_lay': flatLayPrompt,
                'eyelet': buildEyeletPrompt(product),
                'collar': `Detail shot of collar/neckline area of ${productDesc}. Top-down 45-degree angle. Close-up of collar construction. Clean white studio background. Professional macro photography.`,
                'fabrics': `Macro texture close-up of the fabric on ${productDesc}. Extreme close-up showing weave pattern and material quality. Top-down 45-degree angle. Clean white studio background.`,
                'sleeves': `Detail shot of sleeve construction on ${productDesc}. Close-up showing stitching and construction. Top-down 45-degree angle. Clean white studio background.`,
                'back': `Back view flat lay of ${productDesc}. Clean presentation. White studio floor.`,
                'print': `Detail shot of print/graphic on ${productDesc}. Clean composition highlighting design. White background.`,
                'belt': `Detail shot of waistband/belt area on ${productDesc}. Top-down 45-degree angle. Focus on construction details. Clean white studio background.`
            };

            return basePrompts[shotType] || `Professional e-commerce photograph of ${productDesc}.`;
        }

        // ========== UTILITIES ==========
        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }

        // Lightbox handled by shared/js/lightbox.js

        // ========== CANNY TAB ==========
        function setupCannySettings() {
            ['aspect', 'resolution', 'seeds'].forEach(setting => {
                const container = document.getElementById(`canny-${setting}-buttons`);
                if (!container) return;
                container.addEventListener('click', (e) => {
                    if (e.target.tagName !== 'BUTTON') return;
                    container.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    cannySettings[setting] = e.target.dataset.value;
                });
            });
        }

        function initCannyGrid() {
            const grid = document.getElementById('canny-upload-grid');
            let html = '';
            for (let i = 0; i < CANNY_GRID_SIZE; i++) {
                const img = cannyImages[i];
                if (img) {
                    const selectedClass = img.selected !== false ? 'selected' : '';
                    html += `
                        <div class="canny-slot filled ${selectedClass}" data-index="${i}" onclick="toggleCannySelection(${i})">
                            <img src="${img.url}" alt="${img.name}">
                            <button class="remove-btn" onclick="event.stopPropagation(); removeCannyImage(${i})">&times;</button>
                            <div class="slot-label">${img.name}</div>
                        </div>
                    `;
                } else {
                    html += `
                        <div class="canny-slot" data-index="${i}" onclick="document.getElementById('canny-file-input').click()">
                            <span style="color: var(--ash-grey); font-size: var(--text-xs);">+</span>
                        </div>
                    `;
                }
            }
            grid.innerHTML = html;
            updateCannyGenerateBtn();
        }

        function toggleCannySelection(index) {
            if (cannyImages[index]) {
                cannyImages[index].selected = cannyImages[index].selected === false ? true : false;
                initCannyGrid();
            }
        }

        function updateCannyGenerateBtn() {
            const btn = document.getElementById('canny-generate-btn');
            const selectedCount = cannyImages.filter(img => img.selected !== false).length;
            btn.disabled = selectedCount === 0;
        }

        function removeCannyImage(index) {
            cannyImages.splice(index, 1);
            initCannyGrid();
        }

        function clearCannyGrid() {
            cannyImages = [];
            document.getElementById('canny-results').innerHTML = '';
            initCannyGrid();
        }

        // Handle file uploads for Canny tab
        document.getElementById('canny-file-input').addEventListener('change', async (e) => {
            const files = Array.from(e.target.files);
            for (const file of files) {
                if (cannyImages.length >= CANNY_GRID_SIZE) break;
                const url = URL.createObjectURL(file);
                cannyImages.push({ file, url, name: file.name.replace(/\.[^/.]+$/, ''), selected: true });
            }
            e.target.value = ''; // Reset input
            initCannyGrid();
        });

        // Drag and drop for Canny grid
        const cannyGrid = document.getElementById('canny-upload-grid');
        cannyGrid.addEventListener('dragover', (e) => {
            e.preventDefault();
            cannyGrid.classList.add('drag-over');
        });
        cannyGrid.addEventListener('dragleave', () => {
            cannyGrid.classList.remove('drag-over');
        });
        cannyGrid.addEventListener('drop', async (e) => {
            e.preventDefault();
            cannyGrid.classList.remove('drag-over');
            const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
            for (const file of files) {
                if (cannyImages.length >= CANNY_GRID_SIZE) break;
                const url = URL.createObjectURL(file);
                cannyImages.push({ file, url, name: file.name.replace(/\.[^/.]+$/, ''), selected: true });
            }
            initCannyGrid();
        });

        // Clipboard paste for Canny grid
        document.addEventListener('paste', async (e) => {
            // Only handle paste when Canny tab is active
            const cannyTab = document.getElementById('canny-tab');
            if (!cannyTab || cannyTab.style.display === 'none') return;

            const items = Array.from(e.clipboardData?.items || []);
            for (const item of items) {
                if (item.type.startsWith('image/')) {
                    const file = item.getAsFile();
                    if (file && cannyImages.length < CANNY_GRID_SIZE) {
                        const url = URL.createObjectURL(file);
                        const timestamp = new Date().toISOString().slice(0, 19).replace(/[-:T]/g, '').slice(2);
                        cannyImages.push({ file, url, name: `pasted_${timestamp}`, selected: true });
                    }
                }
            }
            if (items.some(i => i.type.startsWith('image/'))) {
                initCannyGrid();
            }
        });

        // Canny loader instance
        let cannyLoader = null;

        async function generateCanny() {
            if (cannyImages.length === 0) return;

            const btn = document.getElementById('canny-generate-btn');
            const resultsContainer = document.getElementById('canny-results');
            btn.disabled = true;
            btn.textContent = 'Generating...';

            // Setup loader
            cannyLoader = new StudioLoader({
                loaderElement: document.getElementById('canny-loader'),
                messageElement: document.getElementById('canny-loader-message'),
                progressElement: document.getElementById('canny-loader-progress')
            });

            const numSeeds = parseInt(cannySettings.seeds) || 1;
            const selectedImages = cannyImages.map((img, i) => ({ ...img, originalIndex: i })).filter(img => img.selected !== false);
            const totalTasks = selectedImages.length * numSeeds;
            let completed = 0;

            if (selectedImages.length === 0) return;

            cannyLoader.start(`Analyzing images...`);

            // Process all selected images in parallel
            const tasks = [];
            for (let i = 0; i < selectedImages.length; i++) {
                const img = selectedImages[i];
                const slot = document.querySelector(`.canny-slot[data-index="${img.originalIndex}"]`);
                slot?.classList.add('processing');

                for (let seed = 0; seed < numSeeds; seed++) {
                    tasks.push((async () => {
                        try {
                            const base64DataUrl = await blobToBase64(img.file);
                            const fileName = img.name.toLowerCase();

                            // First, analyze the image to understand what it is and the camera angle
                            const analyzeRes = await fetch('/api/analyze-gemini', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    image: base64DataUrl,
                                    prompt: `Describe this image briefly in one sentence. Include: 1) What garment/detail is shown, 2) The camera angle (e.g., "top-down 45 degree angle", "straight-on front view", "angled from above"). Example: "Polo shirt collar, photographed from a 45-degree angle above."`
                                })
                            });
                            const analyzeData = await analyzeRes.json();
                            const analysis = analyzeData.description || analyzeData.text || '';
                            console.log(`Analysis for ${img.name}:`, analysis);

                            // Extract angle info from analysis
                            const angleMatch = analysis.match(/(45.degree|top.down|from above|angled|straight.on|front view|side view|overhead)/i);
                            const angleDesc = angleMatch ? `, from the same ${angleMatch[0].toLowerCase()} perspective` : '';

                            // Combine filename hints + image analysis to build smart prompt
                            const lowerAnalysis = analysis.toLowerCase();
                            let cannyPrompt;

                            // Check filename first for hints, then combine with analysis
                            if (fileName.includes('collar')) {
                                // Collar close-up
                                const garmentType = lowerAnalysis.includes('polo') ? 'polo' :
                                                   lowerAnalysis.includes('t-shirt') || lowerAnalysis.includes('tshirt') ? 't-shirt' :
                                                   lowerAnalysis.includes('tank') ? 'tank top' : 'garment';
                                cannyPrompt = `Create a minimal black and white line drawing of this ${garmentType} collar/neckline${angleDesc}. Thin black outlines only on pure white background. Trace the collar shape and seams. No logos, no text, no shading. Just clean thin black lines showing the collar edges and construction.`;
                            } else if (fileName.includes('eyelet')) {
                                // Eyelet detail
                                cannyPrompt = `Create a minimal black and white line drawing${angleDesc}. Thin black outlines on pure white background. IMPORTANT: Show the eyelets/grommets as solid black filled circles. Include any visible fabric edges as thin lines. No texture, no shading.`;
                            } else if (fileName.includes('belt')) {
                                // Belt/waistband of shorts
                                cannyPrompt = `Create a minimal black and white line drawing of this shorts waistband/belt area${angleDesc}. Thin black outlines only on pure white background. Show the waistband edge, any drawstring or elastic details, and seams as clean thin black lines. No texture, no shading.`;
                            } else if (fileName.includes('flatlay') || lowerAnalysis.includes('flat lay') || lowerAnalysis.includes('full')) {
                                // Full garment flat lay
                                const hasEyelets = lowerAnalysis.includes('eyelet') || lowerAnalysis.includes('grommet');
                                if (hasEyelets) {
                                    cannyPrompt = `Create a minimal black and white line drawing${angleDesc}. Thin black outlines only on pure white background. Show the garment silhouette outline. Include any eyelets as solid black circles. No logos, no text, no patterns, no shading.`;
                                } else {
                                    cannyPrompt = `Create a minimal black and white line drawing${angleDesc}. Thin black outlines only on pure white background. No logos, no text, no patterns, no shading, no fills, no texture. Just the basic silhouette outline of the garment shape.`;
                                }
                            } else {
                                // Default: use analysis to determine
                                if (lowerAnalysis.includes('collar') || lowerAnalysis.includes('neckline')) {
                                    cannyPrompt = `Create a minimal black and white line drawing of this collar/neckline${angleDesc}. Thin black outlines on pure white background. Trace the collar shape and seams. No shading, no texture.`;
                                } else if (lowerAnalysis.includes('waist') || lowerAnalysis.includes('drawstring')) {
                                    cannyPrompt = `Create a minimal black and white line drawing of this waistband area${angleDesc}. Thin black outlines on pure white background. Show edges and seams. No shading, no texture.`;
                                } else {
                                    cannyPrompt = `Create a minimal black and white line drawing${angleDesc}. Thin black outlines only on pure white background. No logos, no text, no patterns, no shading. Just clean thin black lines tracing the visible edges and shapes.`;
                                }
                            }

                            console.log(`Prompt for ${img.name}:`, cannyPrompt);
                            cannyLoader.updateProgress(`${completed}/${totalTasks} generating...`);

                            const provider = settings.provider || 'gemini';
                            let generateData;

                            if (provider === 'gemini') {
                                const generateRes = await fetch('/api/remix-gemini', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        model: 'gemini-3-pro',
                                        prompt: cannyPrompt,
                                        image_base64s: [base64DataUrl],
                                        aspect_ratio: cannySettings.aspect,
                                        resolution: cannySettings.resolution,
                                        num_images: 1
                                    })
                                });
                                generateData = await generateRes.json();
                            } else {
                                // FAL - upload first then remix
                                const uploadRes = await fetch('/api/upload-base64', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ dataUrl: base64DataUrl })
                                });
                                const uploadData = await uploadRes.json();

                                const generateRes = await fetch('/api/remix', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        model: 'nano-pro',
                                        prompt: cannyPrompt,
                                        image_urls: [uploadData.url],
                                        aspect_ratio: cannySettings.aspect,
                                        resolution: cannySettings.resolution,
                                        num_images: 1,
                                        output_format: 'png'
                                    })
                                });
                                generateData = await generateRes.json();
                            }
                            completed++;
                            cannyLoader.updateProgress(`${completed}/${totalTasks} images`);

                            if (generateData.error) {
                                console.error(`Generation error: ${generateData.error}`);
                                return null;
                            }
                            if (generateData.images?.length > 0) {
                                const resultImg = generateData.images[0];
                                const resultUrl = resultImg.url || `data:image/png;base64,${resultImg.base64}`;
                                const seedSuffix = numSeeds > 1 ? `_${String(seed + 1).padStart(2, '0')}` : '';
                                return {
                                    original: img.url,
                                    canny: resultUrl,
                                    name: `${img.name}${seedSuffix}`,
                                    index: i,
                                    seed: seed
                                };
                            }
                        } catch (error) {
                            console.error(`Failed to process ${img.name}:`, error);
                            completed++;
                            cannyLoader.updateProgress(`${completed}/${totalTasks} images`);
                        }
                        return null;
                    })());
                }
            }

            // Wait for all parallel tasks
            const results = (await Promise.all(tasks)).filter(r => r !== null);

            // Sort results by original index and seed
            results.sort((a, b) => a.index - b.index || a.seed - b.seed);

            // Clear processing states
            selectedImages.forEach(img => {
                const slot = document.querySelector(`.canny-slot[data-index="${img.originalIndex}"]`);
                slot?.classList.remove('processing');
            });

            cannyLoader.stop();

            // Render results
            resultsContainer.innerHTML = results.map(r => `
                <div class="canny-result">
                    <img src="${r.canny}" alt="${r.name} canny" onclick="openLightbox(this)" data-full="${r.canny}" data-name="${r.name}" data-shot="Canny Guide">
                    <div class="canny-result-info">
                        <span>${r.name}</span>
                        <div class="canny-result-actions">
                            <button class="btn" onclick="downloadCannyResult('${r.canny}', '${r.name}')">Download</button>
                        </div>
                    </div>
                </div>
            `).join('');

            btn.textContent = 'Generate Canny Guides';
            updateCannyGenerateBtn();
        }

        async function downloadCannyResult(url, name) {
            // Convert to PNG using canvas
            const img = new Image();
            img.crossOrigin = 'anonymous';

            img.onload = () => {
                const canvas = document.createElement('canvas');
                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);

                canvas.toBlob((blob) => {
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = `${name}.png`;
                    a.click();
                    URL.revokeObjectURL(a.href);
                }, 'image/png');
            };

            img.src = url;
        }

        // ========== PRODUCTS V3 FUNCTIONS ==========

        // Get products for V3 shot type
        function getProductsForV3ShotType(shotType) {
            return PRODUCTS.map((p, i) => ({ ...p, index: i }))
                .filter(p => p.shotTypes.includes(shotType));
        }

        // Render shot type selector for Products V3
        function renderProductV3Selector() {
            const container = document.getElementById('product-v3-selector');
            let html = '';
            V3_SHOT_TYPES.forEach(type => {
                const count = getProductsForV3ShotType(type).length;
                const selected = selectedV3ShotType === type ? 'selected' : '';
                const displayName = type.replace('_', ' ');
                html += `<div class="pose-tab ${selected}" onclick="selectV3ShotType('${type}')">${displayName}<span class="count">(${count})</span></div>`;
            });
            container.innerHTML = html;
        }

        // Select a shot type for Products V3
        function selectV3ShotType(shotType) {
            selectedV3ShotType = shotType;
            renderProductV3Selector();
            renderProductV3Products();
        }

        // Render products for selected V3 shot type (similar to V2 but uses V3 state and settings)
        function renderProductV3Products() {
            const container = document.getElementById('product-v3-area');
            if (!selectedV3ShotType) {
                container.innerHTML = '<div class="no-product-selected">Select a shot type above</div>';
                return;
            }

            const products = getProductsForV3ShotType(selectedV3ShotType);
            const shotType = selectedV3ShotType;

            // Initialize state for each product
            products.forEach(product => {
                const stateKey = `${product.index}_${shotType}_v3`;
                if (!productV3State[stateKey]) {
                    const productImages = getProductImages(product.sku);
                    productV3State[stateKey] = {
                        expanded: true,
                        selectedImages: productImages.map((_, i) => i < 2),
                        selectedGuides: [],
                        noneGuideSelected: true
                    };
                }
            });

            // Count total tasks using V3 settings
            const seeds = settingsV3.seeds;
            let totalImages = 0;

            products.forEach(p => {
                const stateKey = `${p.index}_${shotType}_v3`;
                const state = productV3State[stateKey];
                if (!state?.selectedImages?.some(Boolean)) return;

                const relevantGuides = getV2Guides(shotType, p);
                const selectedGuideCount = state.selectedGuides?.filter(Boolean).length || 0;
                const guideMultiplier = (state.noneGuideSelected ? 1 : 0) + selectedGuideCount;
                const effectiveGuideMultiplier = Math.max(1, guideMultiplier);

                totalImages += effectiveGuideMultiplier * seeds;
            });

            const selectedCount = products.filter(p => {
                const stateKey = `${p.index}_${shotType}_v3`;
                return productV3State[stateKey]?.selectedImages?.some(Boolean);
            }).length;

            let html = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--space-sm); padding: var(--space-sm); background: var(--white); border: 1px solid var(--jet);">
                    <div>
                        <strong>${shotType.toUpperCase()}</strong> - ${selectedCount}/${products.length} products ready
                        <span style="margin-left: 8px; font-size: 10px; color: #666;">[${settingsV3.provider} | ${settingsV3.resolution} | ${settingsV3.aspect}]</span>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button onclick="deselectAllV3Products()" style="padding: 4px 12px; font-size: 11px;">Deselect All</button>
                        <button onclick="expandAllV3Products(true)" style="padding: 4px 12px; font-size: 11px;">Expand All</button>
                        <button onclick="expandAllV3Products(false)" style="padding: 4px 12px; font-size: 11px;">Collapse All</button>
                        <button onclick="generateSelectedV3Products()" style="padding: 6px 16px; font-size: 12px; background: var(--jet); color: white; font-weight: 500;">Generate All (${totalImages} images)</button>
                    </div>
                </div>
            `;

            products.forEach(product => {
                const stateKey = `${product.index}_${shotType}_v3`;
                const state = productV3State[stateKey];
                const productImages = getProductImages(product.sku);
                const frontImg = getFrontImage(product.sku);
                const hasSelection = state.selectedImages.some(Boolean);
                const expandedClass = state.expanded ? 'expanded' : '';
                const selectedClass = hasSelection ? 'selected' : '';

                const relevantGuides = getV2Guides(shotType, product);

                if (!state.selectedGuides || state.selectedGuides.length !== relevantGuides.length) {
                    state.selectedGuides = relevantGuides.map(() => false);
                }

                const noneSelected = state.noneGuideSelected || false;
                let guidesHtml = '';
                if (relevantGuides.length > 0) {
                    guidesHtml = `
                        <div style="margin-top: 8px;">
                            <div style="font-size: 10px; color: #666; margin-bottom: 4px;">Guides & References:</div>
                            <div class="pose-product-images-row">
                                <div class="pose-image-option ${noneSelected ? 'selected' : ''}"
                                     onclick="toggleV3NoneGuide(${product.index}, '${shotType}')" title="Generate without guide" style="display: flex; align-items: center; justify-content: center; background: #f5f5f5; min-width: 48px; min-height: 48px;">
                                    <span style="font-size: 10px; font-weight: 600; color: #666;">None</span>
                                    <span class="check">âœ“</span>
                                </div>
                                ${relevantGuides.map((guide, i) => {
                                    let guidePath;
                                    if (!guide.isPhotoRef) {
                                        guidePath = '/assets/brand/rondorff/canny/guides/' + guide.file;
                                    } else if (guide.folder === 'canny') {
                                        guidePath = '/assets/brand/rondorff/canny/refs/' + guide.file;
                                    } else {
                                        guidePath = '/assets/brand/rondorff/refs/' + guide.folder + '/' + guide.file;
                                    }
                                    const badgeColor = guide.isPhotoRef ? '#f59e0b' : '#3b82f6';
                                    const badgeText = guide.isPhotoRef ? 'R' : 'C';
                                    return `
                                        <div class="pose-image-option ${state.selectedGuides[i] ? 'selected' : ''}"
                                             onclick="toggleV3Guide(${product.index}, '${shotType}', ${i})" title="${guide.label}">
                                            <img src="${guidePath}" alt="${guide.label}">
                                            <span class="check">âœ“</span>
                                            <span style="position: absolute; top: 2px; left: 2px; background: ${badgeColor}; color: white; padding: 1px 4px; font-size: 8px; border-radius: 2px;">${badgeText}</span>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    `;
                }

                html += `
                    <div class="pose-product-card ${expandedClass} ${selectedClass}" data-product-index="${product.index}">
                        <div class="pose-product-header" onclick="toggleV3ProductExpand(${product.index}, '${shotType}')">
                            <img class="pose-product-thumb" src="/assets/brand/rondorff/ecom/thumbs/${frontImg}" alt="${product.name}">
                            <div class="pose-product-info">
                                <div class="pose-product-name">${product.name}</div>
                                <div class="pose-product-sku">${product.sku} â€¢ ${product.color} â€¢ ${state.selectedImages.filter(Boolean).length}/${productImages.length} images</div>
                            </div>
                            <div class="pose-product-actions">
                                <button onclick="event.stopPropagation(); selectAllV3Images(${product.index}, '${shotType}', true)" style="padding: 4px 8px; font-size: 10px;">All</button>
                                <button onclick="event.stopPropagation(); selectAllV3Images(${product.index}, '${shotType}', false)" style="padding: 4px 8px; font-size: 10px;">None</button>
                                <button onclick="event.stopPropagation(); generateSingleV3Product(${product.index})" style="padding: 4px 12px; font-size: 11px; background: var(--jet); color: white;">Generate</button>
                            </div>
                        </div>
                        <div class="pose-product-images">
                            <div class="pose-product-images-row">
                                ${productImages.map((img, i) => `
                                    <div class="pose-image-option ${state.selectedImages[i] ? 'selected' : ''}"
                                         onclick="toggleV3ProductImage(${product.index}, '${shotType}', ${i})" title="${getShotType(img)}">
                                        <img src="/assets/brand/rondorff/ecom/thumbs/${img}" alt="${getShotType(img)}">
                                        <span class="check">âœ“</span>
                                    </div>
                                `).join('')}
                            </div>
                            ${guidesHtml}
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        // Toggle V3 product expand/collapse
        function toggleV3ProductExpand(productIndex, shotType) {
            const stateKey = `${productIndex}_${shotType}_v3`;
            if (productV3State[stateKey]) {
                productV3State[stateKey].expanded = !productV3State[stateKey].expanded;
                renderProductV3Products();
            }
        }

        // Toggle V3 product image selection
        function toggleV3ProductImage(productIndex, shotType, imageIndex) {
            const stateKey = `${productIndex}_${shotType}_v3`;
            if (productV3State[stateKey]) {
                productV3State[stateKey].selectedImages[imageIndex] = !productV3State[stateKey].selectedImages[imageIndex];
                renderProductV3Products();
            }
        }

        // Toggle V3 guide selection
        function toggleV3Guide(productIndex, shotType, guideIndex) {
            const stateKey = `${productIndex}_${shotType}_v3`;
            if (productV3State[stateKey]) {
                productV3State[stateKey].selectedGuides[guideIndex] = !productV3State[stateKey].selectedGuides[guideIndex];
                renderProductV3Products();
            }
        }

        // Toggle V3 "None" guide option
        function toggleV3NoneGuide(productIndex, shotType) {
            const stateKey = `${productIndex}_${shotType}_v3`;
            if (productV3State[stateKey]) {
                productV3State[stateKey].noneGuideSelected = !productV3State[stateKey].noneGuideSelected;
                renderProductV3Products();
            }
        }

        // Expand/collapse all V3 products
        function expandAllV3Products(expand) {
            const products = getProductsForV3ShotType(selectedV3ShotType);
            products.forEach(product => {
                const stateKey = `${product.index}_${selectedV3ShotType}_v3`;
                if (productV3State[stateKey]) {
                    productV3State[stateKey].expanded = expand;
                }
            });
            renderProductV3Products();
        }

        // Deselect all V3 products
        function deselectAllV3Products() {
            const products = getProductsForV3ShotType(selectedV3ShotType);
            products.forEach(product => {
                const stateKey = `${product.index}_${selectedV3ShotType}_v3`;
                if (productV3State[stateKey]) {
                    productV3State[stateKey].selectedImages = productV3State[stateKey].selectedImages.map(() => false);
                }
            });
            renderProductV3Products();
        }

        // Select all/none V3 images for a product
        function selectAllV3Images(productIndex, shotType, selectAll) {
            const stateKey = `${productIndex}_${shotType}_v3`;
            if (productV3State[stateKey]) {
                productV3State[stateKey].selectedImages = productV3State[stateKey].selectedImages.map(() => selectAll);
                renderProductV3Products();
            }
        }

        // Generate single V3 product
        // V3 loader state
        let v3CompletedCount = 0;
        let v3TotalCount = 0;

        function showV3Loader(total) {
            v3CompletedCount = 0;
            v3TotalCount = total;
            const loader = document.getElementById('v3-loader');
            const message = document.getElementById('v3-loader-message');
            const progress = document.getElementById('v3-loader-progress');
            loader.classList.add('visible');
            message.textContent = 'Generating...';
            progress.textContent = `0 / ${total}`;
        }

        function updateV3Progress() {
            v3CompletedCount++;
            const progress = document.getElementById('v3-loader-progress');
            progress.textContent = `${v3CompletedCount} / ${v3TotalCount}`;
        }

        function hideV3Loader() {
            const loader = document.getElementById('v3-loader');
            loader.classList.remove('visible');
        }

        async function generateSingleV3Product(productIndex) {
            const tasks = await prepareV3ProductTasks(productIndex);
            if (tasks.length === 0) return;

            showV3Loader(tasks.length);
            await Promise.all(tasks.map(task => executeV3Task(task)));
            hideV3Loader();
        }

        // Generate all selected V3 products - ALL IN PARALLEL
        async function generateSelectedV3Products() {
            const products = getProductsForV3ShotType(selectedV3ShotType);
            const shotType = selectedV3ShotType;

            const productsToGenerate = products.filter(p => {
                const stateKey = `${p.index}_${shotType}_v3`;
                return productV3State[stateKey]?.selectedImages?.some(Boolean);
            });

            if (productsToGenerate.length === 0) {
                alert('Please select at least one image for at least one product');
                return;
            }

            console.log(`ðŸš€ V3 Starting ${productsToGenerate.length} products in PARALLEL`);

            // Collect ALL task promises from all products
            const allTasks = [];
            for (const product of productsToGenerate) {
                const tasks = await prepareV3ProductTasks(product.index);
                allTasks.push(...tasks);
            }

            console.log(`ðŸš€ V3 Firing ${allTasks.length} API requests in PARALLEL`);

            // Show loader
            showV3Loader(allTasks.length);

            // Execute ALL tasks in parallel
            await Promise.all(allTasks.map(task => executeV3Task(task)));

            // Hide loader
            hideV3Loader();
            console.log(`âœ… V3 All tasks complete`);
        }

        // Prepare V3 product tasks (returns array of task configs, doesn't execute)
        async function prepareV3ProductTasks(productIndex) {
            const product = PRODUCTS[productIndex];
            const shotType = selectedV3ShotType;
            const stateKey = `${productIndex}_${shotType}_v3`;
            const state = productV3State[stateKey];

            if (!state || !state.selectedImages.some(Boolean)) return [];

            const productImages = getProductImages(product.sku);
            const selectedProductImages = productImages.filter((_, i) => state.selectedImages[i]);
            const relevantGuides = getV2Guides(shotType, product);

            // Collect guide configurations to generate
            const guideConfigs = [];

            // Add "None" guide if selected
            if (state.noneGuideSelected) {
                guideConfigs.push(null);
            }

            // Add selected guides
            state.selectedGuides.forEach((selected, i) => {
                if (selected && relevantGuides[i]) {
                    guideConfigs.push(relevantGuides[i]);
                }
            });

            // If no guides selected at all, add at least one "none" generation
            if (guideConfigs.length === 0) {
                guideConfigs.push(null);
            }

            // Map provider names to API models
            let apiModel = 'gemini-3-pro';  // Default: Nano Pro
            if (settingsV3.provider === 'nano-pro-flash') {
                apiModel = 'gemini-3.1-flash';
            } else if (settingsV3.provider === 'fal') {
                apiModel = 'fal';
            }

            const taskSettings = {
                provider: settingsV3.provider,
                aspect: settingsV3.aspect,
                resolution: settingsV3.resolution,
                seeds: settingsV3.seeds,
                apiModel: apiModel
            };

            // Pre-load product images once (shared across all tasks for this product)
            const imageBase64s = await loadImagesAsBase64(selectedProductImages.map(img => `/assets/brand/rondorff/ecom/originals/${img}`));

            // Create task configs for each guide and seed
            const tasks = [];
            for (const guideInfo of guideConfigs) {
                for (let seed = 0; seed < taskSettings.seeds; seed++) {
                    tasks.push({
                        product,
                        shotType,
                        guideInfo,
                        taskSettings,
                        imageBase64s: [...imageBase64s], // Copy base images
                        seed
                    });
                }
            }

            return tasks;
        }

        // Helper to load images as base64 in parallel
        async function loadImagesAsBase64(imagePaths) {
            const promises = imagePaths.map(async (imgPath) => {
                try {
                    const response = await fetch(imgPath);
                    const blob = await response.blob();
                    return await new Promise(resolve => {
                        const reader = new FileReader();
                        reader.onloadend = () => resolve(reader.result);
                        reader.readAsDataURL(blob);
                    });
                } catch (err) {
                    console.error('Failed to load image:', imgPath, err);
                    return null;
                }
            });
            const results = await Promise.all(promises);
            return results.filter(Boolean);
        }

        // Queue V3 product generation tasks (legacy wrapper for single product)
        async function queueV3ProductTasks(productIndex) {
            const tasks = await prepareV3ProductTasks(productIndex);
            await Promise.all(tasks.map(task => executeV3Task(task)));
        }

        // Execute a single V3 task (receives pre-prepared task object)
        async function executeV3Task(task) {
            const { product, shotType, guideInfo, taskSettings, imageBase64s, seed } = task;

            try {
                // Build prompt
                const prompt = buildPromptV3(shotType, product, [], guideInfo);

                // Add guide image if present
                const finalImages = [...imageBase64s];
                if (guideInfo) {
                    let guidePath;
                    if (!guideInfo.isPhotoRef) {
                        guidePath = '/assets/brand/rondorff/canny/guides/' + guideInfo.file;
                    } else if (guideInfo.folder === 'canny') {
                        guidePath = '/assets/brand/rondorff/canny/refs/' + guideInfo.file;
                    } else {
                        guidePath = '/assets/brand/rondorff/refs/' + guideInfo.folder + '/' + guideInfo.file;
                    }

                    try {
                        const guideBase64 = await loadImagesAsBase64([guidePath]);
                        if (guideBase64.length > 0) {
                            finalImages.push(guideBase64[0]);
                        }
                    } catch (err) {
                        console.error('Failed to load guide image:', guidePath, err);
                    }
                }

                console.log(`ðŸŽ¨ V3 Generating: ${product.sku} ${shotType} [seed ${seed + 1}] (${taskSettings.provider}, ${taskSettings.resolution})`);

                if (taskSettings.provider === 'fal') {
                    console.log('FAL generation not yet implemented for V3');
                    return;
                }

                // Use Gemini API (Nano Pro or Nano Pro Flash)
                const response = await fetch('/api/remix-gemini', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: taskSettings.apiModel,
                        prompt: prompt,
                        image_base64s: finalImages,
                        aspect_ratio: taskSettings.aspect,
                        resolution: taskSettings.resolution
                    })
                });

                const data = await response.json();

                if (data.images && data.images.length > 0) {
                    const imageUrl = data.images[0].url;
                    console.log(`âœ… V3 Generated image for ${product.sku} ${shotType}`);

                    // Add to results display
                    const resultsContainer = document.getElementById('product-v3-area');
                    const resultHtml = `
                        <div style="display: inline-block; margin: 4px; position: relative;">
                            <img src="${imageUrl}" style="max-width: 200px; border-radius: 4px;" onclick="openLightbox(this.src)">
                            <div style="font-size: 9px; text-align: center; margin-top: 2px;">${product.sku} - ${shotType}</div>
                        </div>
                    `;
                    resultsContainer.insertAdjacentHTML('beforeend', resultHtml);
                } else {
                    console.error('No image in response:', data);
                }

                // Update progress
                updateV3Progress();
            } catch (err) {
                console.error(`Failed to generate ${product.sku} ${shotType}:`, err);
                updateV3Progress(); // Still update progress on error
            }
        }

        // Initialize V3 settings button handlers
        function initV3SettingsHandlers() {
            // Provider buttons
            document.querySelectorAll('#v3-provider-buttons button').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#v3-provider-buttons button').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    settingsV3.provider = btn.dataset.value;
                    renderProductV3Products();
                });
            });

            // Aspect ratio buttons
            document.querySelectorAll('#v3-aspect-buttons button').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#v3-aspect-buttons button').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    settingsV3.aspect = btn.dataset.value;
                    renderProductV3Products();
                });
            });

            // Resolution buttons
            document.querySelectorAll('#v3-resolution-buttons button').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#v3-resolution-buttons button').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    settingsV3.resolution = btn.dataset.value;
                    renderProductV3Products();
                });
            });

            // Seeds buttons
            document.querySelectorAll('#v3-seeds-buttons button').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#v3-seeds-buttons button').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    settingsV3.seeds = parseInt(btn.dataset.value);
                    renderProductV3Products();
                });
            });
        }

        // ========== COPY TAB ==========
        // Copy tab products - only Corduroy Tennis Shorts for now
        const COPY_PRODUCTS = [
            { category: 'Sports Shorts', sku: '21SS21.BE', name: 'Corduroy Tennis Shorts', color: 'Beige', material: '97% cotton, 3% spandex', shotTypes: ['flatlay', 'eyelet', 'belt', 'fabrics', 'on-model', 'back'], video: true }
        ];

        let copySelectedProductIndex = 0; // Default to first (and only) product
        const copyCategoryState = {};
        const copyImageAnalysis = {}; // Cache for image analysis
        let copyResults = [];
        let copyLoader = null;

        const copySettings = {
            provider: 'gemini',
            aspect: '3:4',
            resolution: '2K',
            seeds: 1
        };

        // Analysis prompts
        const PRODUCT_ANALYSIS_PROMPT = `Analyze this garment image. Provide a concise description:

TYPE: [garment type]
COLOR: [colors]
MATERIAL: [texture/fabric]
KEY DETAILS: [eyelets, buttons, pockets, waistband, logos - be specific]

Keep it factual and brief.`;

        const REFERENCE_ANALYSIS_PROMPT = `Analyze this product photo's style. Be concise:

SHOT: [flat lay/detail/on-model]
ANGLE: [overhead/45-degree/straight-on]
BACKGROUND: [color and type]
LIGHTING: [quality and direction]
STYLING: [position, fold, arrangement]

Be precise and technical.`;

        function setupCopySettings() {
            // Provider buttons
            document.querySelectorAll('#copy-provider-buttons button').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#copy-provider-buttons button').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    copySettings.provider = btn.dataset.value;
                });
            });
            // Aspect buttons
            document.querySelectorAll('#copy-aspect-buttons button').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#copy-aspect-buttons button').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    copySettings.aspect = btn.dataset.value;
                });
            });
            // Resolution buttons
            document.querySelectorAll('#copy-resolution-buttons button').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#copy-resolution-buttons button').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    copySettings.resolution = btn.dataset.value;
                });
            });
            // Seeds buttons
            document.querySelectorAll('#copy-seeds-buttons button').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#copy-seeds-buttons button').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    copySettings.seeds = parseInt(btn.dataset.value);
                    updateCopyGenerateAllButton(); // Update image count
                });
            });
        }

        function renderCopyProductSelector() {
            const container = document.getElementById('copy-product-selector');
            let html = '<div class="product-thumbs">';
            COPY_PRODUCTS.forEach((product, index) => {
                const frontImg = getFrontImage(product.sku);
                const selected = copySelectedProductIndex === index ? 'selected' : '';
                html += `<div class="product-thumb ${selected}" onclick="selectCopyProduct(${index})">
                    <img src="/assets/brand/rondorff/ecom/thumbs/${frontImg}" alt="${product.name}">
                    <div class="product-thumb-label">${product.sku.split('.')[0]}</div>
                </div>`;
            });
            html += '</div>';
            container.innerHTML = html;
        }

        function selectCopyProduct(index) {
            copySelectedProductIndex = index;
            const product = COPY_PRODUCTS[index];
            const productImages = getProductImages(product.sku);

            // Initialize category state for each shot type
            product.shotTypes.forEach(shotType => {
                if (!copyCategoryState[shotType]) {
                    const relevantGuides = getRelevantGuides(shotType, product);
                    const canUseFootwear = shotType === 'on-model' && CATEGORIES_WITH_FOOTWEAR.includes(product.category);
                    const canUseBottoms = shotType === 'on-model' && CATEGORIES_WITH_BOTTOMS.includes(product.category);
                    const needsPoseMode = SHOT_TYPES_WITH_MODELS.includes(shotType);
                    copyCategoryState[shotType] = {
                        selectedGuides: relevantGuides.map(() => false),
                        noneGuideSelected: false,
                        selectedImages: productImages.map(() => false),
                        selectedModels: needsPoseMode ? MODEL_PORTRAITS.map(() => false) : [],
                        selectedFootwear: canUseFootwear ? FOOTWEAR.map(() => false) : [],
                        selectedBottoms: canUseBottoms ? BOTTOMS.map(() => false) : [],
                        poseModes: needsPoseMode ? { copy: true, dynamic: false } : null,
                        results: []
                    };
                }
            });

            renderCopyProductSelector();
            renderCopySelectedProduct();
        }

        function renderCopySelectedProduct() {
            const container = document.getElementById('copy-selected-product-area');
            if (copySelectedProductIndex === null) {
                container.innerHTML = `<div class="no-product-selected">Select a product above to start generating</div>`;
                return;
            }

            const product = COPY_PRODUCTS[copySelectedProductIndex];
            const productImages = getProductImages(product.sku);

            let html = `
                <div class="selected-product-header">
                    <div>
                        <div class="selected-product-title">${product.name}</div>
                        <div class="selected-product-sku">${product.sku} - ${product.color}</div>
                    </div>
                    <button class="header-btn" id="copy-generate-all-btn" onclick="generateAllCopyCategories()" disabled>Generate</button>
                </div>
                <div class="category-rows">
            `;

            product.shotTypes.forEach(shotType => {
                html += renderCopyCategoryRow(shotType, product, productImages);
            });

            html += `</div>`;
            container.innerHTML = html;
            updateCopyGenerateAllButton();
        }

        function renderCopyCategoryRow(shotType, product, productImages) {
            const state = copyCategoryState[shotType];
            if (!state) return '';

            const hasModels = SHOT_TYPES_WITH_MODELS.includes(shotType);
            const hasPoseMode = hasModels;
            const hasFootwear = shotType === 'on-model' && CATEGORIES_WITH_FOOTWEAR.includes(product.category);
            const selectedCount = state.selectedImages.filter(Boolean).length + (hasModels ? state.selectedModels.filter(Boolean).length : 0);
            const totalCount = productImages.length + (hasModels ? MODEL_PORTRAITS.length : 0);

            const relevantGuides = getRelevantGuides(shotType, product);

            // Model portraits
            const modelImagesHtml = hasModels ? MODEL_PORTRAITS.map((model, i) => `
                <div class="image-option ${state.selectedModels[i] ? 'selected' : ''}"
                     onclick="toggleCopyModelImage('${shotType}', ${i})" title="${model.name}" style="position: relative;">
                    <img src="${model.thumb}" alt="${model.name}">
                    <span class="check">âœ“</span>
                    <span class="model-badge" style="position: absolute; bottom: 2px; left: 2px; width: 14px; height: 14px; background: #3b82f6; color: white; font-size: 8px; font-weight: 700; display: flex; align-items: center; justify-content: center;">M</span>
                </div>
            `).join('') : '';

            // Footwear
            const footwearImagesHtml = hasFootwear ? FOOTWEAR.map((shoe, i) => `
                <div class="image-option ${state.selectedFootwear[i] ? 'selected' : ''}"
                     onclick="toggleCopyFootwearImage('${shotType}', ${i})" title="${shoe.name}" style="position: relative;">
                    <img src="${shoe.thumb}" alt="${shoe.name}">
                    <span class="check">âœ“</span>
                    <span class="model-badge" style="position: absolute; bottom: 2px; left: 2px; width: 14px; height: 14px; background: #8b5cf6; color: white; font-size: 8px; font-weight: 700; display: flex; align-items: center; justify-content: center;">F</span>
                </div>
            `).join('') : '';

            // Canny guides and photo refs
            const cannyGuides = relevantGuides.filter(g => !g.isPhotoRef);
            const photoRefs = relevantGuides.filter(g => g.isPhotoRef);

            const noneSelected = state.noneGuideSelected || false;
            const hasGuides = cannyGuides.length > 0;
            const guidesLabel = hasGuides ? 'Canny Guides' : 'Generation Mode';

            const cannyGuidesHtml = `
                <div class="section-label">${guidesLabel}</div>
                <div class="guides-row">
                    <div class="image-option guide-image-option ${noneSelected ? 'selected' : ''}"
                         onclick="selectCopyNoneGuide('${shotType}')" title="Generate without guide" style="position: relative; display: flex; align-items: center; justify-content: center; background: #f5f5f5; min-width: 60px; cursor: pointer;">
                        <span style="font-size: 11px; color: #666;">${hasGuides ? 'None' : 'Generate'}</span>
                        <span class="check">âœ“</span>
                    </div>
                    ${cannyGuides.map((guide, i) => {
                        const globalIndex = relevantGuides.indexOf(guide);
                        return `
                        <div class="image-option guide-image-option ${state.selectedGuides[globalIndex] ? 'selected' : ''}"
                             onclick="toggleCopyCategoryGuide('${shotType}', ${globalIndex})" title="${guide.label}" style="position: relative;">
                            <img src="/assets/brand/rondorff/canny/guides/${guide.file}" alt="${guide.label}">
                            <span class="check">âœ“</span>
                        </div>
                    `}).join('')}
                </div>
            `;

            const photoRefsHtml = photoRefs.length > 0 ? `
                <div class="section-label" style="margin-top: 8px;">Photo References (match this composition)</div>
                <div class="guides-row">
                    ${photoRefs.map((guide, i) => {
                        const globalIndex = relevantGuides.indexOf(guide);
                        const photoRefPath = guide.folder === 'canny'
                            ? `/assets/brand/rondorff/canny/refs/${guide.file}`
                            : `/assets/brand/rondorff/refs/${guide.folder}/${guide.file}`;
                        return `
                        <div class="image-option guide-image-option ${state.selectedGuides[globalIndex] ? 'selected' : ''}"
                             onclick="toggleCopyCategoryGuide('${shotType}', ${globalIndex})" title="${guide.label}" style="position: relative; border-color: #3b82f6;">
                            <img src="${photoRefPath}" alt="${guide.label}">
                            <span class="check">âœ“</span>
                        </div>
                    `}).join('')}
                </div>
            ` : '';

            const guidesHtml = cannyGuidesHtml + photoRefsHtml;

            const poseModeHtml = hasPoseMode && state.poseModes ? `
                <div class="pose-mode-toggle">
                    <button class="pose-mode-btn ${state.poseModes.copy ? 'active' : ''}" onclick="toggleCopyPoseMode('${shotType}', 'copy')">Copy</button>
                    <button class="pose-mode-btn ${state.poseModes.dynamic ? 'active' : ''}" onclick="toggleCopyPoseMode('${shotType}', 'dynamic')">Dynamic</button>
                </div>
            ` : '';

            return `
                <div class="category-row" data-shot-type="${shotType}">
                    <div class="category-row-header">
                        <div class="category-row-title">${shotType.replace('_', ' ')}</div>
                        <div class="category-row-actions">
                            ${poseModeHtml}
                            <button class="select-btn" onclick="selectAllCopyImages('${shotType}', true)">All</button>
                            <button class="select-btn" onclick="selectAllCopyImages('${shotType}', false)">None</button>
                            <span class="category-row-status">${selectedCount}/${totalCount}</span>
                        </div>
                    </div>
                    <div class="inputs-guides-section">
                        <div class="section-label">Input Images${hasModels ? ' (+ Models)' : ''}${hasFootwear ? ' (+ Footwear)' : ''}</div>
                        <div class="images-row">
                            ${modelImagesHtml}
                            ${footwearImagesHtml}
                            ${productImages.map((img, i) => `
                                <div class="image-option ${state.selectedImages[i] ? 'selected' : ''}"
                                     onclick="toggleCopyInputImage('${shotType}', ${i})" title="${getShotType(img)}" style="position: relative;">
                                    <img src="/assets/brand/rondorff/ecom/thumbs/${img}" alt="${getShotType(img)}">
                                    <span class="check">âœ“</span>
                                </div>
                            `).join('')}
                        </div>
                        ${guidesHtml}
                    </div>
                    <button class="category-generate-btn" onclick="generateCopyCategory('${shotType}')" ${selectedCount === 0 ? 'disabled' : ''}>
                        Generate ${shotType.replace('_', ' ')}
                    </button>
                </div>
            `;
        }

        // Copy tab interaction handlers
        function toggleCopyInputImage(shotType, index) {
            if (!copyCategoryState[shotType]) return;
            copyCategoryState[shotType].selectedImages[index] = !copyCategoryState[shotType].selectedImages[index];
            renderCopySelectedProduct();
        }

        function toggleCopyModelImage(shotType, index) {
            if (!copyCategoryState[shotType]) return;
            copyCategoryState[shotType].selectedModels[index] = !copyCategoryState[shotType].selectedModels[index];
            renderCopySelectedProduct();
        }

        function toggleCopyFootwearImage(shotType, index) {
            if (!copyCategoryState[shotType]) return;
            copyCategoryState[shotType].selectedFootwear[index] = !copyCategoryState[shotType].selectedFootwear[index];
            renderCopySelectedProduct();
        }

        function toggleCopyPoseMode(shotType, mode) {
            if (!copyCategoryState[shotType] || !copyCategoryState[shotType].poseModes) return;
            copyCategoryState[shotType].poseModes[mode] = !copyCategoryState[shotType].poseModes[mode];
            renderCopySelectedProduct();
        }

        function selectAllCopyImages(shotType, selectAll) {
            if (!copyCategoryState[shotType]) return;
            const product = COPY_PRODUCTS[copySelectedProductIndex];
            const productImages = getProductImages(product.sku);
            copyCategoryState[shotType].selectedImages = productImages.map(() => selectAll);
            if (SHOT_TYPES_WITH_MODELS.includes(shotType)) {
                copyCategoryState[shotType].selectedModels = MODEL_PORTRAITS.map(() => selectAll);
            }
            renderCopySelectedProduct();
        }

        function selectCopyNoneGuide(shotType) {
            if (!copyCategoryState[shotType]) return;
            copyCategoryState[shotType].noneGuideSelected = !copyCategoryState[shotType].noneGuideSelected;
            renderCopySelectedProduct();
        }

        function toggleCopyCategoryGuide(shotType, guideIndex) {
            if (!copyCategoryState[shotType]) return;
            copyCategoryState[shotType].selectedGuides[guideIndex] = !copyCategoryState[shotType].selectedGuides[guideIndex];
            renderCopySelectedProduct();
        }

        function updateCopyGenerateAllButton() {
            const btn = document.getElementById('copy-generate-all-btn');
            if (!btn) return;
            const product = COPY_PRODUCTS[copySelectedProductIndex];

            let taskCount = 0;
            product.shotTypes.forEach(shotType => {
                const state = copyCategoryState[shotType];
                if (!state) return;

                const hasImages = state.selectedImages.some(Boolean);
                const hasModels = state.selectedModels?.some(Boolean);
                if (!hasImages && !hasModels) return;

                // Count guides/refs selected
                const selectedGuideCount = state.selectedGuides?.filter(Boolean).length || 0;
                const noneSelected = state.noneGuideSelected || false;

                let guideMultiplier = 0;
                if (noneSelected) guideMultiplier += 1;
                if (selectedGuideCount > 0) guideMultiplier += selectedGuideCount;

                if (guideMultiplier > 0) {
                    taskCount += guideMultiplier;
                }
            });

            const seedCount = parseInt(copySettings.seeds) || 1;
            const totalImages = taskCount * seedCount;

            if (taskCount === 0) {
                btn.disabled = true;
                btn.textContent = 'Generate';
            } else {
                btn.disabled = false;
                const seedText = seedCount > 1 ? ` (${seedCount} seeds)` : '';
                btn.textContent = `Generate ${totalImages} image${totalImages !== 1 ? 's' : ''}${seedText}`;
            }
        }

        // Generate for Copy tab - uses dynamic analysis-based prompts
        async function generateCopyCategory(shotType) {
            const product = COPY_PRODUCTS[copySelectedProductIndex];
            const productImages = getProductImages(product.sku);
            const state = copyCategoryState[shotType];

            const selectedImgs = productImages.filter((_, i) => state.selectedImages[i]);
            const selectedModels = SHOT_TYPES_WITH_MODELS.includes(shotType)
                ? MODEL_PORTRAITS.filter((_, i) => state.selectedModels[i])
                : [];
            const selectedFootwear = shotType === 'on-model'
                ? FOOTWEAR.filter((_, i) => state.selectedFootwear?.[i])
                : [];

            // Get selected guides/refs (filtered by product)
            const relevantGuides = getRelevantGuides(shotType, product);
            const selectedGuideIndices = state.selectedGuides.map((sel, i) => sel ? i : -1).filter(i => i >= 0);
            const selectedGuideInfos = selectedGuideIndices.map(i => relevantGuides[i]);

            // Add "None" as a generation option if selected
            const generateWithNone = state.noneGuideSelected;

            if (selectedImgs.length === 0 && selectedModels.length === 0) {
                console.log('No images selected for', shotType);
                return;
            }

            // Initialize StudioLoader for Copy tab if not already
            if (!copyLoader) {
                copyLoader = new StudioLoader({
                    loaderElement: document.getElementById('copy-loader'),
                    messageElement: document.getElementById('copy-loader-message'),
                    progressElement: document.getElementById('copy-loader-progress')
                });
            }

            try {
                // Build tasks - one for each guide/ref combination
                const tasks = [];

                // If "None" is selected, generate without guide
                if (generateWithNone) {
                    tasks.push({ guide: null, isNone: true });
                }

                // Add tasks for each selected guide
                selectedGuideInfos.forEach(guide => {
                    tasks.push({ guide, isNone: false });
                });

                if (tasks.length === 0) {
                    copyLoader.updateProgress('Select a guide or "None" to generate');
                    return;
                }

                console.log(`\nðŸ“¦ COPY TOOL - Starting ${tasks.length} ${shotType} generation(s)`);
                console.log(`ðŸ“¦ Product: ${product.name} (${product.color})`);
                console.log(`ðŸ“¦ Selected images: ${selectedImgs.length} product, ${selectedModels.length} models, ${selectedFootwear.length} footwear`);

                copyLoader.start(`Generating ${tasks.length} ${shotType} images...`);

                for (let t = 0; t < tasks.length; t++) {
                    const task = tasks[t];
                    copyLoader.updateProgress(`Task ${t + 1} of ${tasks.length}`);

                    console.log(`\nðŸ”„ Task ${t + 1}/${tasks.length}: ${shotType} with guide: ${task.guide?.label || 'None'}`);

                    // Build the prompt (simple, no analysis needed)
                    const prompt = buildCopyDynamicPrompt(shotType, product, selectedImgs, selectedModels, task.guide, selectedFootwear);

                    console.log(`ðŸ“ PROMPT BUILT:\n${prompt}`);

                    // Collect image URLs
                    const imageUrls = [];

                    // Add model images first for face/3-4 shots
                    selectedModels.forEach(model => {
                        imageUrls.push(model.full);
                    });

                    // Add product images
                    selectedImgs.forEach(img => {
                        imageUrls.push(`/assets/brand/rondorff/ecom/originals/${img}`);
                    });

                    // Add footwear if selected
                    selectedFootwear.forEach(shoe => {
                        imageUrls.push(shoe.full);
                    });

                    // Add guide/ref image if not "None"
                    if (task.guide && !task.isNone) {
                        const guidePath = task.guide.isPhotoRef
                            ? (task.guide.folder === 'canny'
                                ? `/assets/brand/rondorff/canny/refs/${task.guide.file}`
                                : `/assets/brand/rondorff/refs/${task.guide.folder}/${task.guide.file}`)
                            : `/assets/brand/rondorff/canny/guides/${task.guide.file}`;
                        imageUrls.push(guidePath);
                    }

                    console.log(`ðŸ–¼ï¸ INPUT IMAGES (${imageUrls.length} total):`);
                    imageUrls.forEach((url, i) => console.log(`   ${i + 1}. ${url}`));

                    // Calculate dimensions
                    const [w, h] = copySettings.aspect.split(':').map(Number);
                    const baseRes = copySettings.resolution === '4K' ? 2048 : copySettings.resolution === '2K' ? 1536 : 1024;
                    const width = w > h ? baseRes : Math.round(baseRes * (w / h));
                    const height = h > w ? baseRes : Math.round(baseRes * (h / w));

                    // Convert relative URLs to absolute
                    const absoluteUrls = imageUrls.map(url =>
                        url.startsWith('http') ? url : window.location.origin + url
                    );

                    console.log(`ðŸš€ Sending to API: ${copySettings.seeds} seeds, ${copySettings.aspect}, ${copySettings.resolution}`);

                    const response = await fetch('/api/remix-gemini', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            prompt,
                            image_urls: absoluteUrls,
                            aspect_ratio: copySettings.aspect,
                            resolution: copySettings.resolution,
                            num_images: copySettings.seeds
                        })
                    });

                    const data = await response.json();
                    console.log(`ðŸ“¥ API Response:`, data.error ? `Error: ${data.error}` : `${data.images?.length || 0} images returned`);

                    if (data.images && data.images.length > 0) {
                        data.images.forEach(img => {
                            copyResults.push({
                                url: img.url || img, // Handle both {url: '...'} and direct URL string
                                shotType,
                                guide: task.guide?.label || 'None',
                                product: product.sku,
                                prompt: prompt, // Store the prompt for lightbox
                                inputImages: absoluteUrls // Store input images for lightbox
                            });
                        });
                        // Render results
                        renderCopyResults();
                        console.log(`âœ… Generated ${shotType} with guide: ${task.guide?.label || 'None'} - ${data.images.length} images added`);
                    } else {
                        console.log(`âš ï¸ No images returned for ${shotType}`);
                    }
                }

                copyLoader.updateProgress('Done!');
            } catch (err) {
                console.error('Generation error:', err);
                copyLoader.updateProgress('Error: ' + err.message);
            } finally {
                copyLoader.stop();
            }
        }

        function buildCopyDynamicPrompt(shotType, product, selectedImgs, selectedModels, guideInfo, selectedFootwear) {
            // Build descriptive prompts with product details and strong flat/graphical emphasis
            const productName = `${product.color} ${product.name}`;

            // Product-specific details
            const productDetails = getProductDetails(product);

            // Shot-type descriptions for what the reference shows
            const shotDescriptions = {
                'flatlay': 'flat lay photograph with garment laid completely flat from above',
                'belt': 'waistband/belt detail shot showing the closure and waistband construction',
                'eyelet': 'diagonal corner detail showing the metal eyelets',
                'fabrics': 'extreme macro of the fabric texture',
                'back': 'back view flat lay showing the reverse side',
                'collar': 'collar/neckline detail shot',
                '3/4': '3/4 body model shot',
                'face': 'face/upper body model shot'
            };

            const shotDesc = shotDescriptions[shotType] || `${shotType} shot`;

            // Strong flat/graphical emphasis
            const flatNote = `CRITICAL: The garment must look PRESSED and PRISTINE - completely flat like it's floating on the surface, no wrinkles, no shadows underneath, no floor texture visible. Clean, graphical, high-end e-commerce catalog quality.`;

            if (guideInfo && guideInfo.isPhotoRef) {
                // Photo reference mode - describe what the reference shows
                const refDesc = guideInfo.description || shotDesc;
                const hasModel = selectedModels.length > 0;

                // Check if this is a small eyelet reference - add emphasis on smaller eyelet size
                const smallEyeletNote = guideInfo.smallEyelet ? ' IMPORTANT: Use SMALLER sized eyelets as shown in the reference - these are smaller than standard eyelets.' : '';

                if (hasModel) {
                    return `Recreate this ${shotDesc} with ${productName}. The reference photo shows the exact composition and lighting to match. Use the model's face and body from the model image. Product details: ${productDetails}.${smallEyeletNote} ${flatNote}`;
                } else {
                    return `Recreate this ${shotDesc} - the reference photo shows exactly how to position and light the garment. Replace with ${productName}. Product details: ${productDetails}.${smallEyeletNote} Light gray seamless background. ${flatNote}`;
                }
            } else if (guideInfo && !guideInfo.isPhotoRef) {
                // Canny guide mode
                return `Create a ${shotDesc} of ${productName} following the line drawing guide for exact positioning. Product details: ${productDetails}. Light gray seamless background. ${flatNote}`;
            } else {
                // No guide - standard generation
                return `Professional e-commerce ${shotDesc} of ${productName}. Product details: ${productDetails}. Light gray seamless background, bright even studio lighting. ${flatNote}`;
            }
        }

        // Get product-specific details for prompts
        function getProductDetails(product) {
            const details = {
                '21SS21.BE': 'tan/beige corduroy with visible wales texture, elastic waistband with black button, black metal RON DORFF eyelets with white engraved text, diagonal pocket seams, NO drawstrings',
                '21SS20.RW': 'natural/beige open-weave crochet knit texture, elastic waistband with drawstrings, black metal RON DORFF eyelets, NO pockets',
                '21SR20DD.SO': 'sunset orange ombre gradient (pink at waist to orange at bottom), drawstrings with RON DORFF text and black tips, black metal eyelets, white lining visible',
                '21SR21B.S': 'sand/beige body with WHITE contrasting waistband, drawstrings with black tips, black metal RON DORFF eyelets, tan contrast stitching',
                '21SR23DD.SO': 'sunset orange ombre gradient swim shorts (longer length), drawstrings with black tips, black metal RON DORFF eyelets'
            };
            return details[product.sku] || `${product.color} ${product.material || ''}`;
        }

        async function generateAllCopyCategories() {
            const product = COPY_PRODUCTS[copySelectedProductIndex];
            for (const shotType of product.shotTypes) {
                const state = copyCategoryState[shotType];
                if (state && (state.selectedImages.some(Boolean) || state.selectedModels?.some(Boolean))) {
                    await generateCopyCategory(shotType);
                }
            }
        }

        function renderCopyResults() {
            // Add results section if it doesn't exist
            let resultsSection = document.getElementById('copy-results-section');
            if (!resultsSection) {
                const container = document.getElementById('copy-selected-product-area');
                resultsSection = document.createElement('div');
                resultsSection.id = 'copy-results-section';
                resultsSection.className = 'copy-results-section';
                resultsSection.style.cssText = 'margin-top: 20px; padding-top: 20px; border-top: 1px solid var(--gainsboro);';
                container.appendChild(resultsSection);
            }

            resultsSection.innerHTML = `
                <h3 style="margin-bottom: 12px;">Results (${copyResults.length})</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 12px;">
                    ${copyResults.map((r, i) => `
                        <div class="canny-result-card" style="border: 1px solid var(--gainsboro); padding: 8px;">
                            <img src="${r.url}" alt="Result ${i+1}" style="width: 100%; cursor: pointer;"
                                 onclick="openCopyResultLightbox(${i})">
                            <div style="font-size: 11px; color: var(--slate); margin-top: 4px;">${r.shotType} - ${r.guide}</div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        // Copy results lightbox using shared Lightbox class
        let copyResultsLightbox = null;
        function openCopyResultLightbox(index) {
            if (!copyResultsLightbox) {
                copyResultsLightbox = new Lightbox({
                    onDownload: async (url, filename) => {
                        try {
                            const response = await fetch(url);
                            const blob = await response.blob();
                            const blobUrl = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = blobUrl;
                            a.download = filename;
                            a.click();
                            URL.revokeObjectURL(blobUrl);
                        } catch (e) {
                            window.open(url, '_blank');
                        }
                    }
                });
            }

            // Convert copyResults to format expected by Lightbox
            const lightboxResults = copyResults.map((r, i) => ({
                url: r.url,
                prompt: r.prompt || 'No prompt stored',
                modelName: `${r.shotType} - ${r.guide}`,
                filename: `Copy_${r.shotType}_${r.guide}_${i + 1}.png`,
                inputImages: r.inputImages || [] // Show input images in lightbox
            }));

            copyResultsLightbox.setResults(lightboxResults);
            copyResultsLightbox.open(index);
        }

        function initCopyGrids() {
            // Initialize Copy tab
            selectCopyProduct(0);
        }

        // ========== VIDEO TAB ==========
        // Video tab products - only those with video: true
        const VIDEO_PRODUCTS = PRODUCTS.filter(p => p.video === true);

        // Video tab state
        let videoSettings = {
            provider: 'gemini',
            aspect: '3:4',
            resolution: '2K',
            seeds: 1
        };

        // State for each video product: { [sku]: { frontImage, threeQuarterImage, selectedBackImages, poseMode } }
        let videoProductState = {};

        // Video results
        let videoResults = [];
        let videoLoader = null;

        // Initialize video product state
        // Pre-populated on-model images for video products
        const VIDEO_ONMODEL_IMAGES = {
            '21TS1505.RW': { front: 'Setset_RonDorff_Ecomm_21TS1505RW_front.png', threeQuarter: 'Setset_RonDorff_Ecomm_21TS1505RW_34.png' },
            '21TK189.RW': { front: 'Setset_RonDorff_Ecomm_21TK189RW_front.png', threeQuarter: 'Setset_RonDorff_Ecomm_21TK189RW_34.png' },
            '21SR20DD.SO': { front: 'Setset_RonDorff_Ecomm_21SR20DDSO_front.png', threeQuarter: 'Setset_RonDorff_Ecomm_21SR20DDSO_34.png' },
            '21SS21.BE': { front: 'Setset_RonDorff_Ecomm_21SS21BE_front.png', threeQuarter: 'Setset_RonDorff_Ecomm_21SS21BE_34.png', shoes: '/assets/brand/rondorff/accessories/rondorff_sneakers_white.png' },
            '21UR30.W': { front: 'Setset_RonDorff_Ecomm_21UR30W_front.png', threeQuarter: 'Setset_RonDorff_Ecomm_21UR30W_34.png' }
        };

        function initVideoProductState() {
            VIDEO_PRODUCTS.forEach(product => {
                const onmodel = VIDEO_ONMODEL_IMAGES[product.sku];
                const backImages = getVideoBackImages(product.sku);

                // Pre-select all back images
                const selectedBackImages = {};
                backImages.forEach(img => {
                    selectedBackImages[img] = true;
                });

                videoProductState[product.sku] = {
                    frontImage: onmodel ? `/assets/brand/rondorff/onmodel/${onmodel.front}` : null,
                    threeQuarterImage: onmodel ? `/assets/brand/rondorff/onmodel/${onmodel.threeQuarter}` : null,
                    shoesImage: onmodel?.shoes || null,
                    selectedBackImages: selectedBackImages,
                    poseModes: { static: true, dynamic: true } // Both selected by default
                };
            });
        }

        // Setup video settings buttons
        function setupVideoSettings() {
            // Provider buttons
            document.querySelectorAll('#video-provider-buttons button').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#video-provider-buttons button').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    videoSettings.provider = btn.dataset.value;
                });
            });

            // Aspect buttons
            document.querySelectorAll('#video-aspect-buttons button').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#video-aspect-buttons button').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    videoSettings.aspect = btn.dataset.value;
                });
            });

            // Resolution buttons
            document.querySelectorAll('#video-resolution-buttons button').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#video-resolution-buttons button').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    videoSettings.resolution = btn.dataset.value;
                    updateVideoCostDisplay();
                });
            });

            // Seeds buttons
            document.querySelectorAll('#video-seeds-buttons button').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#video-seeds-buttons button').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    videoSettings.seeds = parseInt(btn.dataset.value);
                    updateVideoCostDisplay();
                });
            });
        }

        // Get back images for a product SKU
        function getVideoBackImages(sku) {
            // SKU: "21TS1505.RW" -> "21ts1505.rw"
            const skuLower = sku.toLowerCase();
            const backImages = [];
            ALL_IMAGES.forEach(img => {
                // img: "21ts1505.rw_back.jpg" -> imgSku: "21ts1505.rw"
                const imgSku = img.split('_')[0];
                if (imgSku === skuLower && img.includes('_back')) {
                    backImages.push(img);
                }
            });
            return backImages;
        }

        // Render video products grid
        function renderVideoProducts() {
            const container = document.getElementById('video-products-grid');
            if (!container) return;

            let html = '';

            VIDEO_PRODUCTS.forEach((product, index) => {
                const state = videoProductState[product.sku];
                const backImages = getVideoBackImages(product.sku);
                const hasInputs = state.frontImage || state.threeQuarterImage;
                const hasBackSelected = Object.values(state.selectedBackImages).some(Boolean);
                const hasPoseMode = state.poseModes?.static || state.poseModes?.dynamic;
                const canGenerate = hasInputs && hasBackSelected && hasPoseMode;
                const hasAnyImage = state.frontImage || state.threeQuarterImage;

                html += `
                <div class="video-product-card">
                    <div class="video-product-header">
                        <div>
                            <div class="video-product-title">${product.name}</div>
                            <div class="video-product-sku">${product.sku} - ${product.color}</div>
                        </div>
                        <button class="video-generate-btn" onclick="generateVideoBack('${product.sku}')" ${canGenerate ? '' : 'disabled'}>
                            Generate
                        </button>
                    </div>

                    <div class="video-upload-zone"
                         onclick="triggerVideoUploadMultiple('${product.sku}')"
                         ondrop="handleVideoDropMultiple(event, '${product.sku}')"
                         ondragover="handleVideoDragOver(event)"
                         ondragleave="handleVideoDragLeave(event)"
                         id="video-zone-${product.sku}">
                        ${hasAnyImage ? `
                            <div class="video-upload-zone-grid">
                                ${state.frontImage ? `
                                    <div class="video-upload-slot">
                                        <img src="${state.frontImage}" alt="Front">
                                        <button class="remove-btn" onclick="event.stopPropagation(); removeVideoImage('${product.sku}', 'front')">Ã—</button>
                                        <div class="slot-label">Front</div>
                                    </div>
                                ` : ''}
                                ${state.threeQuarterImage ? `
                                    <div class="video-upload-slot">
                                        <img src="${state.threeQuarterImage}" alt="3/4">
                                        <button class="remove-btn" onclick="event.stopPropagation(); removeVideoImage('${product.sku}', 'threeQuarter')">Ã—</button>
                                        <div class="slot-label">3/4</div>
                                    </div>
                                ` : ''}
                            </div>
                        ` : `
                            <div class="video-upload-zone-empty">
                                <span class="slot-icon">+</span>
                                <span>Drop front & 3/4 images</span>
                            </div>
                        `}
                    </div>

                    <div class="video-back-images">
                        <div class="video-back-images-label">Back Reference</div>
                        <div class="video-back-images-grid">
                            ${backImages.map((img, i) => `
                                <div class="video-back-thumb ${state.selectedBackImages[img] ? 'selected' : ''}"
                                     onclick="toggleVideoBackImage('${product.sku}', '${img}')">
                                    <img src="/assets/brand/rondorff/ecom/thumbs/${img}" alt="Back ${i+1}">
                                </div>
                            `).join('')}
                            ${state.shoesImage ? `
                                <div class="video-back-thumb selected" style="border-color: #4CAF50;" title="Ron Dorff Sneakers">
                                    <img src="${state.shoesImage}" alt="Shoes">
                                    <span style="position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%); font-size: 8px; color: #4CAF50; background: rgba(255,255,255,0.9); padding: 1px 4px; border-radius: 2px;">Shoes</span>
                                </div>
                            ` : ''}
                            ${backImages.length === 0 && !state.shoesImage ? '<span style="color: var(--slate); font-size: 10px;">No back images</span>' : ''}
                        </div>
                    </div>

                    <input type="text" class="video-product-note" id="video-note-${product.sku}"
                           placeholder="Note (e.g. hairy back, tattoo on arm...)"
                           value="${state.note || ''}"
                           onchange="updateVideoProductNote('${product.sku}', this.value)">

                    <div class="video-pose-toggle">
                        <button class="video-pose-btn ${state.poseModes?.static ? 'active' : ''}"
                                onclick="toggleVideoPoseMode('${product.sku}', 'static')">Static</button>
                        <button class="video-pose-btn ${state.poseModes?.dynamic ? 'active' : ''}"
                                onclick="toggleVideoPoseMode('${product.sku}', 'dynamic')">Dynamic</button>
                    </div>
                </div>
                `;
            });

            container.innerHTML = html;
            updateVideoCostDisplay();
        }

        // Toggle video back image selection
        function toggleVideoBackImage(sku, img) {
            if (!videoProductState[sku]) return;
            videoProductState[sku].selectedBackImages[img] = !videoProductState[sku].selectedBackImages[img];
            renderVideoProducts();
        }

        // Toggle video pose mode (can select both)
        function toggleVideoPoseMode(sku, mode) {
            if (!videoProductState[sku]) return;
            if (!videoProductState[sku].poseModes) {
                videoProductState[sku].poseModes = { static: false, dynamic: false };
            }
            videoProductState[sku].poseModes[mode] = !videoProductState[sku].poseModes[mode];
            renderVideoProducts();
        }

        // Update video product note
        function updateVideoProductNote(sku, note) {
            if (!videoProductState[sku]) return;
            videoProductState[sku].note = note;
        }

        // Handle video upload trigger
        function triggerVideoUpload(sku, slot) {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        if (slot === 'front') {
                            videoProductState[sku].frontImage = ev.target.result;
                        } else {
                            videoProductState[sku].threeQuarterImage = ev.target.result;
                        }
                        renderVideoProducts();
                    };
                    reader.readAsDataURL(file);
                }
            };
            input.click();
        }

        // Trigger multiple file upload for video
        function triggerVideoUploadMultiple(sku) {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.multiple = true;
            input.onchange = (e) => {
                const files = Array.from(e.target.files).filter(f => f.type.startsWith('image/'));
                loadVideoFiles(sku, files);
            };
            input.click();
        }

        // Load multiple files into video slots
        function loadVideoFiles(sku, files) {
            if (!videoProductState[sku] || files.length === 0) return;

            let loadedCount = 0;
            const state = videoProductState[sku];

            files.forEach((file, i) => {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    // Fill front first, then 3/4
                    if (i === 0 && !state.frontImage) {
                        state.frontImage = ev.target.result;
                    } else if (i === 0 && state.frontImage && !state.threeQuarterImage) {
                        state.threeQuarterImage = ev.target.result;
                    } else if (i === 1 && !state.threeQuarterImage) {
                        state.threeQuarterImage = ev.target.result;
                    } else if (i === 1 && !state.frontImage) {
                        state.frontImage = ev.target.result;
                    }
                    loadedCount++;
                    if (loadedCount === files.length) {
                        renderVideoProducts();
                    }
                };
                reader.readAsDataURL(file);
            });
        }

        // Handle video drag over
        function handleVideoDragOver(e) {
            e.preventDefault();
            e.currentTarget.classList.add('drag-over');
        }

        // Handle video drag leave
        function handleVideoDragLeave(e) {
            e.currentTarget.classList.remove('drag-over');
        }

        // Handle video drop (single slot - legacy)
        function handleVideoDrop(e, sku, slot) {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');

            const files = e.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        if (slot === 'front') {
                            videoProductState[sku].frontImage = ev.target.result;
                        } else {
                            videoProductState[sku].threeQuarterImage = ev.target.result;
                        }
                        renderVideoProducts();
                    };
                    reader.readAsDataURL(file);
                }
            }
        }

        // Handle video drop (multiple files)
        function handleVideoDropMultiple(e, sku) {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');

            const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
            loadVideoFiles(sku, files);
        }

        // Remove video image
        function removeVideoImage(sku, slot) {
            if (!videoProductState[sku]) return;
            if (slot === 'front') {
                videoProductState[sku].frontImage = null;
            } else {
                videoProductState[sku].threeQuarterImage = null;
            }
            renderVideoProducts();
        }

        // Handle clipboard paste for video tab
        function handleVideoPaste(e) {
            // Check if we're on the video tab
            const videoTab = document.getElementById('tab-video');
            if (!videoTab || !videoTab.classList.contains('active')) return;

            const items = e.clipboardData?.items;
            if (!items) return;

            for (const item of items) {
                if (item.type.startsWith('image/')) {
                    const blob = item.getAsFile();
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        // Find the first product that needs an image
                        for (const product of VIDEO_PRODUCTS) {
                            const state = videoProductState[product.sku];
                            if (!state.frontImage) {
                                state.frontImage = ev.target.result;
                                renderVideoProducts();
                                return;
                            }
                            if (!state.threeQuarterImage) {
                                state.threeQuarterImage = ev.target.result;
                                renderVideoProducts();
                                return;
                            }
                        }
                    };
                    reader.readAsDataURL(blob);
                    break;
                }
            }
        }

        // Build prompt for video back generation
        function buildVideoBackPrompt(product, poseMode, hasShoes = false, userNote = '') {
            const shortName = product.name.replace('Organic Cotton ', '').replace('Crochet Knit ', '');

            // Determine framing based on product category
            const isShorts = product.category === 'Sports Shorts';
            const framingInstruction = isShorts
                ? 'FRAMING: Waist-down composition. Crop from waist to feet, matching the exact framing of the input images. Do NOT show face or upper body.'
                : 'FRAMING: Waist-up composition. Match the exact framing and crop of the input images.';

            const poseInstruction = poseMode === 'static'
                ? 'POSE: Model seen from DIRECTLY BEHIND, standing straight. Shoulders level, head facing forward away from camera.'
                : `POSE: DYNAMIC AND EXPRESSIVE - pick ONE of these creative poses:
- Walking away from camera, mid-stride with natural arm swing
- Looking over shoulder at camera, body turned 3/4 away
- Hands in pockets or on hips, weight shifted to one leg
- Arms crossed behind back or stretched above head
- Casual lean or contrapposto stance with movement
- Athletic stretch or reaching pose
Make it look CANDID and EDITORIAL, not stiff studio pose.`;

            // Build user note section if provided
            const noteSection = userNote ? `
IMPORTANT USER NOTE:
"${userNote}"
Take this note into account when generating the image. For example, if it mentions "hairy back", ensure the model's back shows natural body hair.
` : '';

            // Image order varies based on whether shoes are included
            let imageOrder;
            if (hasShoes) {
                imageOrder = `IMAGE ORDER:
- Image 1: Front view of model - COPY THIS PERSON EXACTLY
- Image 2: 3/4 view of model (if provided)
- Image 3: White Ron Dorff sneakers - use EXACT shoes from this reference
- Images 4+: Product back reference - use for garment details from behind`;
            } else {
                imageOrder = `IMAGE ORDER:
- Image 1: Front view of model - COPY THIS PERSON EXACTLY
- Image 2: 3/4 view of model (if provided)
- Images 3+: Product back reference - use for garment details from behind`;
            }

            // Product-specific details
            let productDetails = `${product.color} ${shortName}`;
            let footwearDetails = '';
            if (product.sku === '21SS21.BE') {
                productDetails = `Beige corduroy tennis shorts with vertical ribbed texture, elastic waistband, side pockets, Ron Dorff logo on left leg`;
                footwearDetails = `
FOOTWEAR - EXACT FROM REFERENCE:
- White leather Ron Dorff sneakers with "RON DORFF PARIS-STOCKHOLM" branding on heel
- Two black button details on outer side
- White laces, white sole
- Copy EXACTLY from the shoes reference image`;
            } else if (product.sku === '21SR20DD.SO' || product.sku === '21UR30.W') {
                productDetails = `${product.color} swim briefs - show the back of the briefs with exact fit and cut from product reference`;
            } else if (product.sku === '21TS1505.RW') {
                productDetails = `Natural colored crochet knit shirt - show open weave texture and fit from behind`;
            } else if (product.sku === '21TK189.RW') {
                productDetails = `Natural colored crochet knit tank top - show open weave texture, armholes, and fit from behind`;
            }

            return `E-commerce back view photograph. Generate the SAME MODEL from the input images, now seen from BEHIND.

${imageOrder}

${framingInstruction}

CRITICAL - PHOTOREALISTIC REQUIREMENTS:
- SAME person as input - match hair color, hair style, skin tone, body type, muscle definition EXACTLY
- Preserve natural body hair on back, shoulders, arms, legs - match the input images
- Realistic skin texture with pores and natural imperfections - NOT smooth or airbrushed
- Match exact muscle definition and body contours from input images
- This must look like an actual photograph, not CGI
${noteSection}
PRODUCT - BACK VIEW:
- ${productDetails}
- Copy EXACT garment fit, color, and construction from product reference images
${footwearDetails}
${poseInstruction}

LIGHTING & BACKGROUND:
- Match EXACTLY the lighting and gray background from the input images
- Same studio setup, same shadows

PHOTOREALISTIC E-COMMERCE CATALOG PHOTOGRAPHY. Must match the quality and style of input images exactly.`;
        }

        // Generate video back view
        async function generateVideoBack(sku) {
            const product = VIDEO_PRODUCTS.find(p => p.sku === sku);
            if (!product) return;

            const state = videoProductState[sku];
            if (!state.frontImage && !state.threeQuarterImage) {
                alert('Please upload at least one input image (front or 3/4 view)');
                return;
            }

            const selectedBackImages = Object.entries(state.selectedBackImages)
                .filter(([img, selected]) => selected)
                .map(([img]) => img);

            if (selectedBackImages.length === 0) {
                alert('Please select at least one back product reference image');
                return;
            }

            // Get selected pose modes
            const selectedModes = [];
            if (state.poseModes?.static) selectedModes.push('static');
            if (state.poseModes?.dynamic) selectedModes.push('dynamic');

            if (selectedModes.length === 0) {
                alert('Please select at least one pose mode (Static or Dynamic)');
                return;
            }

            // Initialize loader
            if (!videoLoader) {
                videoLoader = new StudioLoader('video-loader', 'video-loader-message', 'video-loader-progress');
            }

            videoLoader.start('Generating back views...');

            try {
                // Build image URLs
                const imageUrls = [];

                // Add front image if available (convert relative to absolute)
                if (state.frontImage) {
                    const url = state.frontImage.startsWith('/') ? window.location.origin + state.frontImage : state.frontImage;
                    imageUrls.push(url);
                }

                // Add 3/4 image if available
                if (state.threeQuarterImage) {
                    const url = state.threeQuarterImage.startsWith('/') ? window.location.origin + state.threeQuarterImage : state.threeQuarterImage;
                    imageUrls.push(url);
                }

                // Add shoes image if available (for corduroy shorts)
                if (state.shoesImage) {
                    const url = state.shoesImage.startsWith('/') ? window.location.origin + state.shoesImage : state.shoesImage;
                    imageUrls.push(url);
                }

                // Add selected back product images
                selectedBackImages.forEach(img => {
                    imageUrls.push(window.location.origin + `/assets/brand/rondorff/ecom/originals/${img}`);
                });

                // Calculate dimensions
                const [w, h] = videoSettings.aspect.split(':').map(Number);
                const baseRes = videoSettings.resolution === '4K' ? 2048 : videoSettings.resolution === '2K' ? 1536 : 1024;

                // Generate for each selected mode (in parallel)
                const hasShoes = !!state.shoesImage;
                // Get user note from input (in case changed since render)
                const noteEl = document.getElementById(`video-note-${product.sku}`);
                const userNote = noteEl ? noteEl.value.trim() : (state.note || '');
                state.note = userNote; // Store back

                await Promise.all(selectedModes.map(async (poseMode) => {
                    const prompt = buildVideoBackPrompt(product, poseMode, hasShoes, userNote);

                    console.log(`ðŸŽ¬ VIDEO BACK GENERATION - ${poseMode.toUpperCase()}`);
                    console.log(`ðŸ“‹ Product: ${product.sku} - ${product.name}`);
                    console.log(`ðŸ“¸ Input images: ${imageUrls.length}`);

                    const response = await fetch('/api/remix-gemini', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            model: 'gemini-3-pro',  // Use Pro model for better quality
                            prompt,
                            image_urls: imageUrls,
                            aspect_ratio: videoSettings.aspect,
                            resolution: videoSettings.resolution,
                            num_images: videoSettings.seeds
                        })
                    });

                    const data = await response.json();

                    if (data.images && data.images.length > 0) {
                        const now = new Date();
                        const timestamp = now.toISOString().slice(2, 10).replace(/-/g, '') + '_' +
                                         String(now.getHours()).padStart(2, '0') + String(now.getMinutes()).padStart(2, '0');
                        const skuClean = product.sku.replace(/\./g, '');

                        data.images.forEach((img, i) => {
                            const imageNum = String(videoResults.length + 1).padStart(2, '0');
                            const filename = `Setset_RonDorff_Ecomm_${skuClean}_back_${poseMode}_${timestamp}_${imageNum}.png`;

                            videoResults.push({
                                url: img.url || img,
                                sku: product.sku,
                                productName: product.name,
                                poseMode: poseMode,
                                prompt: prompt,
                                inputImages: imageUrls,
                                filename: filename
                            });
                        });
                        renderVideoResults();
                        console.log(`âœ… Generated ${data.images.length} ${poseMode} back view(s) for ${product.sku}`);
                    } else {
                        console.log(`âš ï¸ No images returned for ${poseMode}`);
                    }
                }))

                videoLoader.updateProgress('Done!');
            } catch (err) {
                console.error('Video generation error:', err);
                videoLoader.updateProgress('Error: ' + err.message);
            } finally {
                videoLoader.stop();
            }
        }

        // Deselect all video products (back refs and pose modes)
        function deselectAllVideoProducts() {
            VIDEO_PRODUCTS.forEach(product => {
                const state = videoProductState[product.sku];
                if (state) {
                    // Deselect all back images
                    Object.keys(state.selectedBackImages).forEach(key => {
                        state.selectedBackImages[key] = false;
                    });
                    // Deselect pose modes
                    state.poseModes = { static: false, dynamic: false };
                }
            });
            renderVideoProducts();
        }

        // Update video cost display
        function updateVideoCostDisplay() {
            const costDisplay = document.getElementById('video-cost-display');
            if (!costDisplay) return;

            // Count ready products and total images
            let totalImages = 0;
            VIDEO_PRODUCTS.forEach(product => {
                const state = videoProductState[product.sku];
                const hasInputs = state.frontImage || state.threeQuarterImage;
                const hasBackSelected = Object.values(state.selectedBackImages).some(Boolean);
                const poseCount = (state.poseModes?.static ? 1 : 0) + (state.poseModes?.dynamic ? 1 : 0);
                if (hasInputs && hasBackSelected && poseCount > 0) {
                    totalImages += poseCount * videoSettings.seeds;
                }
            });

            if (totalImages === 0) {
                costDisplay.textContent = '';
                return;
            }

            // Gemini pricing: ~$0.04 per image at 2K, ~$0.08 at 4K
            const pricePerImage = videoSettings.resolution === '4K' ? 0.08 : 0.04;
            const totalCost = (totalImages * pricePerImage).toFixed(2);
            costDisplay.textContent = `${totalImages} images â‰ˆ $${totalCost}`;
        }

        // Generate all video products (in parallel)
        async function generateAllVideoProducts() {
            // Find products that are ready to generate
            const readyProducts = VIDEO_PRODUCTS.filter(product => {
                const state = videoProductState[product.sku];
                const hasInputs = state.frontImage || state.threeQuarterImage;
                const hasBackSelected = Object.values(state.selectedBackImages).some(Boolean);
                const hasPoseMode = state.poseModes?.static || state.poseModes?.dynamic;
                return hasInputs && hasBackSelected && hasPoseMode;
            });

            if (readyProducts.length === 0) {
                alert('No products ready to generate. Please select back references and pose modes for at least one product.');
                return;
            }

            console.log(`ðŸŽ¬ GENERATE ALL (parallel): ${readyProducts.length} products ready`);

            // Run all in parallel
            await Promise.all(readyProducts.map(product => generateVideoBack(product.sku)));
        }

        // Render video results
        function renderVideoResults() {
            const container = document.getElementById('video-results');
            if (!container) return;

            if (videoResults.length === 0) {
                container.innerHTML = '';
                return;
            }

            let html = `
            <h4 style="margin-bottom: var(--space-sm);">Generated Back Views (${videoResults.length})</h4>
            <div class="video-results-grid">
            `;

            videoResults.forEach((r, i) => {
                html += `
                <div class="video-result-item">
                    <img src="${r.url}" alt="Back view ${i+1}" onclick="openVideoResultLightbox(${i})">
                    <div style="font-size: 11px; color: var(--slate); margin-top: 4px;">${r.sku} - ${r.poseMode}</div>
                </div>
                `;
            });

            html += '</div>';
            container.innerHTML = html;
        }

        // Video results lightbox
        let videoResultsLightbox = null;
        function openVideoResultLightbox(index) {
            if (!videoResultsLightbox) {
                // Use default onDownload handler from Lightbox which downloads front + back
                videoResultsLightbox = new Lightbox();
            }

            // Convert to format expected by Lightbox - use proper filename from results
            const lightboxResults = videoResults.map((r, i) => ({
                url: r.url,
                filename: r.filename || `Setset_RonDorff_Ecomm_${r.sku.replace(/\./g, '')}_back_${r.poseMode}_${String(i + 1).padStart(2, '0')}.png`,
                modelName: `${r.sku} - ${r.poseMode}`,
                prompt: r.prompt,
                inputImages: r.inputImages || []
            }));

            videoResultsLightbox.setResults(lightboxResults);
            videoResultsLightbox.open(index);
        }

        // Initialize video products
        function initVideoProducts() {
            initVideoProductState();
            setupVideoSettings();
            renderVideoProducts();

            // Add paste listener
            document.addEventListener('paste', handleVideoPaste);
        }

        // ========== VIDEO OUTPUT TAB ==========
        let voSettings = {
            quality: 'pro',
            aspect: 'as-is',
            duration: '6'
        };
        let voPairs = []; // Array of { baseName, frontUrl, backUrl, frontFile, backFile, prompt, status }
        let voResults = [];
        let voLoader = null;

        // Setup Video Output settings
        function setupVideoOutputSettings() {
            // Quality buttons
            document.querySelectorAll('#vo-quality-buttons button').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#vo-quality-buttons button').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    voSettings.quality = btn.dataset.value;
                    updateVoCostDisplay();
                });
            });

            // Aspect buttons
            document.querySelectorAll('#vo-aspect-buttons button').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#vo-aspect-buttons button').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    voSettings.aspect = btn.dataset.value;
                });
            });

            // Duration slider
            const voDurationSlider = document.getElementById('vo-duration-slider');
            const voDurationValue = document.getElementById('vo-duration-value');
            if (voDurationSlider) {
                voDurationSlider.addEventListener('input', () => {
                    voSettings.duration = voDurationSlider.value;
                    voDurationValue.textContent = voDurationSlider.value + 's';
                    updateVoCostDisplay();
                });
            }
        }

        // Handle folder drag over
        function handleVideoOutputDragOver(e) {
            e.preventDefault();
            e.currentTarget.classList.add('drag-over');
        }

        // Handle folder drag leave
        function handleVideoOutputDragLeave(e) {
            e.currentTarget.classList.remove('drag-over');
        }

        // Handle folder drop
        async function handleVideoOutputDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');

            const items = e.dataTransfer.items;
            const files = [];

            // Handle both folder and individual file drops
            for (const item of items) {
                if (item.kind === 'file') {
                    const entry = item.webkitGetAsEntry ? item.webkitGetAsEntry() : null;
                    if (entry && entry.isDirectory) {
                        await readDirectory(entry, files);
                    } else {
                        const file = item.getAsFile();
                        if (file && file.type.startsWith('image/')) {
                            files.push(file);
                        }
                    }
                }
            }

            if (files.length > 0) {
                processVideoOutputFiles(files);
            }
        }

        // Read directory recursively
        async function readDirectory(dirEntry, files) {
            return new Promise((resolve) => {
                const reader = dirEntry.createReader();
                reader.readEntries(async (entries) => {
                    for (const entry of entries) {
                        if (entry.isFile) {
                            const file = await getFile(entry);
                            if (file.type.startsWith('image/')) {
                                files.push(file);
                            }
                        } else if (entry.isDirectory) {
                            await readDirectory(entry, files);
                        }
                    }
                    resolve();
                });
            });
        }

        // Get file from entry
        function getFile(entry) {
            return new Promise((resolve) => {
                entry.file(resolve);
            });
        }

        // Process dropped files and pair them
        function processVideoOutputFiles(files) {
            // Group by base name (everything before _front.ext or _back.ext at the END of filename)
            const pairs = {};
            const skippedFiles = []; // Files without _front/_back pattern

            files.forEach(file => {
                const name = file.name;
                // Skip hidden files
                if (name.startsWith('.')) return;

                let baseName, type;

                // Check for _front or _back at the END of filename (before extension)
                // Pattern: name_front.png or name_back.png
                const frontMatch = name.match(/^(.+)_front\.[^.]+$/);
                const backMatch = name.match(/^(.+)_back\.[^.]+$/);

                if (frontMatch) {
                    baseName = frontMatch[1];
                    type = 'front';
                } else if (backMatch) {
                    baseName = backMatch[1];
                    type = 'back';
                } else {
                    skippedFiles.push(name);
                    return; // Skip files without _front or _back suffix
                }

                if (!pairs[baseName]) {
                    pairs[baseName] = { baseName, prompt: '', status: 'pending', selected: true };
                }

                if (type === 'front') {
                    pairs[baseName].frontFile = file;
                    pairs[baseName].frontUrl = URL.createObjectURL(file);
                } else {
                    pairs[baseName].backFile = file;
                    pairs[baseName].backUrl = URL.createObjectURL(file);
                }
            });

            // Log skipped files
            if (skippedFiles.length > 0) {
                console.log(`â­ï¸ ${skippedFiles.length} files skipped (no _front/_back suffix):`);
                skippedFiles.forEach(f => console.log(`   - ${f}`));
            }

            // Separate complete pairs from orphans
            const allPairs = Object.values(pairs);
            voPairs = allPairs
                .filter(p => p.frontUrl && p.backUrl)
                .sort((a, b) => a.baseName.localeCompare(b.baseName));

            // Find orphaned files (have one but not both)
            const orphans = allPairs.filter(p => (p.frontUrl && !p.backUrl) || (!p.frontUrl && p.backUrl));

            console.log(`ðŸ“ Found ${voPairs.length} complete pairs`);
            if (orphans.length > 0) {
                console.log(`âš ï¸ ${orphans.length} orphaned files (missing pair):`);
                orphans.forEach(o => {
                    const missing = o.frontUrl ? 'back' : 'front';
                    console.log(`   - ${o.baseName} (missing _${missing})`);
                });
            }

            // Update drop zone with summary
            const dropZone = document.getElementById('vo-drop-zone');
            if (dropZone && (voPairs.length > 0 || orphans.length > 0 || skippedFiles.length > 0)) {
                let summaryHtml = `<div class="vo-drop-zone-content">`;
                summaryHtml += `<span style="font-size: 14px; color: var(--jet);">âœ… ${voPairs.length} complete pairs</span>`;
                if (orphans.length > 0) {
                    summaryHtml += `<span style="font-size: 12px; color: #e67e22;">âš ï¸ ${orphans.length} missing pair:</span>`;
                    summaryHtml += `<div style="font-size: 11px; color: var(--slate); max-height: 50px; overflow-y: auto; text-align: left; width: 100%;">`;
                    orphans.forEach(o => {
                        const missing = o.frontUrl ? '_back' : '_front';
                        const shortName = o.baseName.split('_').slice(-4).join('_');
                        summaryHtml += `<div>â€¢ ${shortName} needs ${missing}</div>`;
                    });
                    summaryHtml += `</div>`;
                }
                if (skippedFiles.length > 0) {
                    summaryHtml += `<span style="font-size: 12px; color: var(--slate);">â­ï¸ ${skippedFiles.length} skipped (no _front/_back)</span>`;
                }
                summaryHtml += `<span class="vo-drop-hint">Drop another folder to replace</span>`;
                summaryHtml += `</div>`;
                dropZone.innerHTML = summaryHtml;
            }

            // Update UI
            renderVideoOutputPairs();
            updateVideoOutputButtons();
            updateVoCostDisplay();
        }

        // Render the pairs grid
        function renderVideoOutputPairs() {
            const grid = document.getElementById('vo-pairs-grid');
            if (!grid) return;

            if (voPairs.length === 0) {
                grid.innerHTML = '';
                return;
            }

            grid.innerHTML = voPairs.map((pair, i) => `
                <div class="vo-pair-card${pair.selected ? '' : ' deselected'}" data-index="${i}">
                    <input type="checkbox" class="vo-pair-checkbox" id="vo-check-${i}"
                        ${pair.selected ? 'checked' : ''} onchange="toggleVoPairSelection(${i}, this.checked)">
                    <div class="vo-pair-images">
                        <div class="vo-pair-image">
                            <img src="${pair.frontUrl}" alt="Front">
                            <span class="vo-image-label">Front</span>
                        </div>
                        <div class="vo-pair-image">
                            <img src="${pair.backUrl}" alt="Back">
                            <span class="vo-image-label">Back</span>
                        </div>
                    </div>
                    <div class="vo-pair-name" title="${pair.baseName}">${pair.baseName.split('_').slice(-3).join('_')}</div>
                    <input type="text" class="vo-pair-note" id="vo-note-${i}" placeholder="Note (e.g. hairy back, tattoo...)"
                        value="${pair.note || ''}" onchange="updateVoPairNote(${i}, this.value)">
                    <textarea class="vo-pair-prompt" id="vo-prompt-${i}" placeholder="Prompt will be generated..."
                        onchange="updateVoPairPrompt(${i}, this.value)">${pair.prompt}</textarea>
                    <div class="vo-pair-status ${pair.status}" id="vo-status-${i}">
                        ${getStatusLabel(pair.status)}
                    </div>
                </div>
            `).join('');
        }

        function getStatusLabel(status) {
            switch (status) {
                case 'pending': return 'â³ Pending';
                case 'analyzing': return 'ðŸ” Analyzing...';
                case 'ready': return 'âœ… Ready';
                case 'generating': return 'ðŸŽ¬ Generating...';
                case 'done': return 'âœ… Done';
                default: return status;
            }
        }

        // Update a pair's prompt
        function updateVoPairPrompt(index, prompt) {
            if (voPairs[index]) {
                voPairs[index].prompt = prompt;
                updateVideoOutputButtons();
            }
        }

        // Update a pair's note
        function updateVoPairNote(index, note) {
            if (voPairs[index]) {
                voPairs[index].note = note;
            }
        }

        // Toggle pair selection
        function toggleVoPairSelection(index, selected) {
            if (voPairs[index]) {
                voPairs[index].selected = selected;
                const card = document.querySelector(`.vo-pair-card[data-index="${index}"]`);
                if (card) {
                    card.classList.toggle('deselected', !selected);
                }
                updateVideoOutputButtons();
                updateVoCostDisplay();
            }
        }

        // Select all pairs
        function voSelectAll() {
            voPairs.forEach((pair, i) => {
                pair.selected = true;
                const checkbox = document.getElementById(`vo-check-${i}`);
                const card = document.querySelector(`.vo-pair-card[data-index="${i}"]`);
                if (checkbox) checkbox.checked = true;
                if (card) card.classList.remove('deselected');
            });
            updateVideoOutputButtons();
            updateVoCostDisplay();
        }

        // Deselect all pairs
        function voDeselectAll() {
            voPairs.forEach((pair, i) => {
                pair.selected = false;
                const checkbox = document.getElementById(`vo-check-${i}`);
                const card = document.querySelector(`.vo-pair-card[data-index="${i}"]`);
                if (checkbox) checkbox.checked = false;
                if (card) card.classList.add('deselected');
            });
            updateVideoOutputButtons();
            updateVoCostDisplay();
        }

        // Update analyze/generate buttons state
        // Calculate video cost based on settings
        function calculateVoCost() {
            // Kling V3 pricing: Pro = $0.224/sec, Standard = $0.084/sec
            const pricePerSec = voSettings.quality === 'pro' ? 0.224 : 0.084;
            const duration = parseInt(voSettings.duration);
            return pricePerSec * duration;
        }

        // Update cost display
        function updateVoCostDisplay() {
            const costInfo = document.getElementById('vo-cost-info');
            if (!costInfo) return;

            if (voPairs.length === 0) {
                costInfo.textContent = '';
                return;
            }

            // Only count selected pairs with prompts, or all selected pairs if no prompts yet
            const selectedPairs = voPairs.filter(p => p.selected);
            const selectedWithPrompts = selectedPairs.filter(p => p.prompt && p.prompt.trim()).length;
            const videoCount = selectedWithPrompts > 0 ? selectedWithPrompts : selectedPairs.length;

            if (videoCount === 0) {
                costInfo.textContent = 'No pairs selected';
                return;
            }

            const costPerVideo = calculateVoCost();
            const totalCost = (costPerVideo * videoCount).toFixed(2);
            const qualityLabel = voSettings.quality === 'pro' ? 'Pro' : 'Std';

            costInfo.textContent = `${videoCount} video${videoCount > 1 ? 's' : ''} Ã— ${voSettings.duration}s ${qualityLabel} = $${totalCost}`;
        }

        function updateVideoOutputButtons() {
            const analyzeBtn = document.getElementById('vo-analyze-btn');
            const generateBtn = document.getElementById('vo-generate-btn');

            if (analyzeBtn) {
                analyzeBtn.disabled = voPairs.length === 0;
            }

            if (generateBtn) {
                const hasPrompts = voPairs.some(p => p.prompt && p.prompt.trim());
                generateBtn.disabled = voPairs.length === 0 || !hasPrompts;
            }

            // Update cost display
            updateVoCostDisplay();
        }

        // Analyze pairs with Gemini to generate rotation prompts
        async function analyzeVideoOutputPairs() {
            const selectedPairs = voPairs.filter(p => p.selected);
            if (selectedPairs.length === 0) {
                alert('Please select at least one pair to analyze');
                return;
            }

            // Initialize loader
            if (!voLoader) {
                voLoader = new StudioLoader('vo-loader', 'vo-loader-message', 'vo-loader-progress');
            }

            voLoader.start(`Analyzing ${selectedPairs.length} image pairs...`);

            let completed = 0;
            let staggerIndex = 0;

            try {
                // Analyze only selected pairs in parallel with staggered start (200ms apart to avoid rate limits)
                await Promise.all(voPairs.map(async (pair, pairIndex) => {
                    if (!pair.selected) return;

                    // Stagger start times to avoid Gemini rate limiting
                    await new Promise(r => setTimeout(r, staggerIndex++ * 200));

                    pair.status = 'analyzing';
                    updatePairStatus(pairIndex, 'analyzing');

                    try {
                        // Convert images to base64
                        const frontBase64 = await fileToBase64(pair.frontFile);
                        const backBase64 = await fileToBase64(pair.backFile);

                        // Random variation index for this pair
                        const variationIndex = Math.floor(Math.random() * 5);
                        const variations = [
                            'turns clockwise to the right',
                            'turns counter-clockwise to the left',
                            'pivots smoothly around',
                            'rotates gracefully',
                            'spins slowly'
                        ];
                        const selectedVariation = variations[variationIndex];

                        // Get user note from input (in case changed since render)
                        const noteEl = document.getElementById(`vo-note-${pairIndex}`);
                        const userNote = noteEl ? noteEl.value.trim() : (pair.note || '');
                        pair.note = userNote; // Store back

                        // Build note section for prompt
                        const noteSection = userNote ? `
USER NOTE (important context to consider):
"${userNote}"
Take this note into account when writing the motion prompt. For example, if the note mentions physical features like "hairy back", acknowledge this is visible in the turn.

` : '';

                        // Call Gemini to analyze and generate prompt
                        const response = await fetch('/api/remix-gemini', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                model: 'gemini-3-pro',
                                prompt: `You are writing a video motion prompt for Kling AI. The video will show a male model turning 180 degrees from front view to back view.

Image 1: FRONT pose - model facing camera
Image 2: BACK pose - model facing away
${noteSection}
STEP 1 - ANALYZE THE FRAMING:
Look at the images and determine what body parts are VISIBLE:
- Is this full body (feet visible)?
- Waist up (cropped at waist/hips)?
- Chest up (cropped at chest)?
- Are hands/arms visible?
- Is the head fully visible?

STEP 2 - WRITE MOTION PROMPT:
Write a motion prompt that ONLY describes movement of body parts that are VISIBLE in the images.

TURNING DIRECTION: ${selectedVariation}

Rules:
- If feet are NOT visible: Do NOT mention feet, weight shifting between feet, heel-to-toe, etc.
- If it's waist-up: Focus on torso rotation, shoulder movement, arm positions, head turn
- If it's chest-up: Focus only on shoulder rotation, head movement, facial expression
- Only describe what the camera will actually capture based on the framing

Write 2-3 sentences describing:
1. The turning motion using "${selectedVariation}"
2. Natural body mechanics for ONLY the visible body parts
3. Smooth, confident pacing

FACE EXPRESSION:
- The model should maintain a neutral, composed expression throughout
- Mouth stays closed - no talking, no lip movement
- A subtle smile is okay, but keep it minimal
- Eyes can follow the turn naturally

DO NOT mention:
- Clothing or what they're wearing
- Body parts that are cropped out of frame
- Generic full-body descriptions if it's a cropped shot
- Any speaking, talking, or mouth movement

Output ONLY the motion prompt, nothing else.`,
                                image_base64s: [frontBase64, backBase64],
                                num_images: 0 // Text-only response
                            })
                        });

                        const data = await response.json();
                        console.log(`Pair ${pairIndex} Gemini response:`, data.text ? 'Generated prompt' : (data.error || 'No text returned'));

                        // Extract text from response - fail if no prompt generated
                        if (data.text) {
                            pair.prompt = data.text.trim();
                            pair.status = 'ready';
                        } else {
                            console.error(`Pair ${pairIndex} failed:`, data.error || 'No text returned');
                            pair.prompt = '';
                            pair.status = 'failed';
                        }

                        // Update UI
                        const promptEl = document.getElementById(`vo-prompt-${pairIndex}`);
                        if (promptEl) promptEl.value = pair.prompt;
                        updatePairStatus(pairIndex, pair.status);

                    } catch (err) {
                        console.error(`Error analyzing pair ${pairIndex}:`, err);
                        pair.prompt = '';
                        pair.status = 'failed';

                        const promptEl = document.getElementById(`vo-prompt-${pairIndex}`);
                        if (promptEl) promptEl.value = '';
                        updatePairStatus(pairIndex, 'failed');
                    }

                    completed++;
                    voLoader.updateProgress(`Analyzed ${completed} of ${selectedPairs.length} pairs`);
                }));

                updateVideoOutputButtons();
                voLoader.updateProgress('Done!');
            } catch (err) {
                console.error('Video output analysis error:', err);
                voLoader.updateProgress('Error: ' + err.message);
            } finally {
                voLoader.stop();
            }
        }

        // Update pair status in UI
        function updatePairStatus(index, status) {
            const statusEl = document.getElementById(`vo-status-${index}`);
            if (statusEl) {
                statusEl.className = `vo-pair-status ${status}`;
                statusEl.textContent = getStatusLabel(status);
            }
        }

        // Convert file to base64
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        // Generate videos using Kling first/last frame
        async function generateVideoOutputVideos() {
            // Only generate for selected pairs with prompts
            const pairsToGenerate = voPairs.filter(p => p.selected && p.prompt && p.prompt.trim());
            if (pairsToGenerate.length === 0) {
                alert('Please select pairs and analyze them first to generate prompts');
                return;
            }

            // Initialize loader
            if (!voLoader) {
                voLoader = new StudioLoader('vo-loader', 'vo-loader-message', 'vo-loader-progress');
            }

            voLoader.start('Generating rotation videos...');
            voResults = [];

            const totalStart = performance.now();
            let completed = 0;

            console.log(`ðŸŽ¬ Starting ${pairsToGenerate.length} video generations in parallel...`);

            try {
                // Generate only selected videos in parallel
                await Promise.all(voPairs.map(async (pair, i) => {
                    if (!pair.selected || !pair.prompt) return;

                    const videoStart = performance.now();
                    pair.status = 'generating';
                    updatePairStatus(i, 'generating');

                    try {
                        // Upload images first (Kling needs URLs)
                        const uploadStart = performance.now();
                        const [frontUrl, backUrl] = await Promise.all([
                            uploadToFal(pair.frontFile),
                            uploadToFal(pair.backFile)
                        ]);
                        console.log(`ðŸ“¤ Video ${i + 1} uploads: ${((performance.now() - uploadStart) / 1000).toFixed(1)}s`);

                        // Call Kling V3 first/last frame API
                        const klingStart = performance.now();
                        const response = await fetch('/api/video', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                model: voSettings.quality === 'pro' ? 'v3-pro' : 'v3-standard',
                                prompt: pair.prompt,
                                image_url: frontUrl,  // First frame
                                tail_image_url: backUrl,  // Last frame (becomes end_image_url for V3)
                                duration: voSettings.duration,
                                aspect_ratio: voSettings.aspect === 'as-is' ? '9:16' : voSettings.aspect,
                                generate_audio: false  // Always disable audio generation
                            })
                        });

                        const data = await response.json();
                        const klingTime = ((performance.now() - klingStart) / 1000).toFixed(1);

                        if (data.video?.url) {
                            voResults.push({
                                url: data.video.url,
                                baseName: pair.baseName,
                                prompt: pair.prompt,
                                frontUrl: pair.frontUrl,
                                backUrl: pair.backUrl
                            });
                            pair.status = 'done';
                            updatePairStatus(i, 'done');
                            renderVideoOutputResults();
                            console.log(`âœ… Video ${i + 1} done: Kling ${klingTime}s, Total ${((performance.now() - videoStart) / 1000).toFixed(1)}s`);
                        } else {
                            console.error(`âŒ Video ${i + 1} no URL (${klingTime}s):`, data);
                            pair.status = 'failed';
                            updatePairStatus(i, 'failed');
                        }
                    } catch (err) {
                        console.error(`âŒ Video ${i + 1} error:`, err);
                        pair.status = 'failed';
                        updatePairStatus(i, 'failed');
                    }

                    completed++;
                    voLoader.updateProgress(`Generated ${completed} of ${pairsToGenerate.length} videos...`);
                }));

                const totalTime = ((performance.now() - totalStart) / 1000).toFixed(1);
                console.log(`ðŸŽ¬ All ${pairsToGenerate.length} videos completed in ${totalTime}s`);
                voLoader.updateProgress('Done!');
            } catch (err) {
                console.error('Video generation error:', err);
                voLoader.updateProgress('Error: ' + err.message);
            } finally {
                voLoader.stop();
            }
        }

        // Upload file to fal.ai storage
        async function uploadToFal(file) {
            const formData = new FormData();
            formData.append('image', file);  // Server expects 'image' field name

            const response = await fetch('/api/upload', {
                method: 'POST',
                body: formData
            });

            const data = await response.json();
            if (!data.url) {
                throw new Error(data.error || 'Upload failed');
            }
            return data.url;
        }

        // Render video results
        function renderVideoOutputResults() {
            const container = document.getElementById('vo-results');
            if (!container) return;

            if (voResults.length === 0) {
                container.innerHTML = '';
                return;
            }

            container.innerHTML = `
                <h4 style="margin-bottom: var(--space-sm);">Generated Videos (${voResults.length})</h4>
                <div class="vo-results-grid">
                    ${voResults.map((r, i) => `
                        <div class="vo-result-item">
                            <video src="${r.url}" controls loop muted playsinline onclick="openVoResultLightbox(${i})"></video>
                            <div style="font-size: 10px; color: var(--slate); margin-top: 4px;">${r.baseName.split('_').slice(-3).join('_')}</div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        // Video output lightbox
        let voLightbox = null;

        // Convert input baseName to video output filename
        // Input: Setset_RonDorff_Ecomm_21SR20DDSO_back_dynamic_260226_2110_02
        // Output: Setset_RonDorff_Ecomm_21SR20DDSO_Video_260226_2110_02.mp4
        function getVideoOutputFilename(baseName) {
            const parts = baseName.split('_');
            // Find SKU (starts with digits, like 21SR20DDSO)
            const skuIndex = parts.findIndex(p => /^\d{2}[A-Z]/.test(p));
            if (skuIndex === -1) return `${baseName}.mp4`;

            const prefix = parts.slice(0, skuIndex).join('_'); // Setset_RonDorff_Ecomm
            const sku = parts[skuIndex]; // 21SR20DDSO
            // Date/time/seq are the last 3 parts: 260226_2110_02
            const dateTimeSeq = parts.slice(-3).join('_');

            return `${prefix}_${sku}_Video_${dateTimeSeq}.mp4`;
        }

        function openVoResultLightbox(index) {
            if (!voLightbox) {
                voLightbox = new Lightbox();
            }

            const lightboxResults = voResults.map(r => ({
                url: r.url,
                type: 'video',
                filename: getVideoOutputFilename(r.baseName),
                modelName: r.baseName,
                prompt: r.prompt
            }));

            voLightbox.setResults(lightboxResults);
            voLightbox.open(index);
        }

        // Initialize Video Output tab
        function initVideoOutput() {
            setupVideoOutputSettings();
        }

        // ========== SIMPLE LIGHTBOX ==========
        // Generic function for opening images in a new tab or using shared lightbox
        function openLightbox(elementOrUrl) {
            let url;
            if (typeof elementOrUrl === 'string') {
                url = elementOrUrl;
            } else if (elementOrUrl && elementOrUrl.src) {
                url = elementOrUrl.src;
            } else if (elementOrUrl && elementOrUrl.dataset && elementOrUrl.dataset.full) {
                url = elementOrUrl.dataset.full;
            }
            if (url) {
                window.open(url, '_blank');
            }
        }

        // ========== RESULTS TAB ==========
        const RESULTS_DIR = '/assets/brand/rondorff/results';
        let resultsImages = [];
        let resultsLightbox = null;

        // Open result image in lightbox
        function openResultLightbox(filename) {
            if (!resultsLightbox) {
                resultsLightbox = new Lightbox({
                    onDownload: async (url, filename) => {
                        // Convert to PNG using canvas
                        const img = new Image();
                        img.crossOrigin = 'anonymous';
                        img.onload = () => {
                            const canvas = document.createElement('canvas');
                            canvas.width = img.naturalWidth;
                            canvas.height = img.naturalHeight;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0);
                            canvas.toBlob((blob) => {
                                const a = document.createElement('a');
                                a.href = URL.createObjectURL(blob);
                                // Ensure .png extension
                                const pngFilename = filename.replace(/\.(webp|jpg|jpeg)$/i, '.png');
                                a.download = pngFilename.endsWith('.png') ? pngFilename : pngFilename + '.png';
                                a.click();
                                URL.revokeObjectURL(a.href);
                            }, 'image/png');
                        };
                        img.onerror = () => window.open(url, '_blank');
                        img.src = url;
                    }
                });
            }

            // Find index of this image
            const index = resultsImages.findIndex(img => img.filename === filename);
            if (index === -1) return;

            // Format shot type for display
            const formatShotType = (type) => {
                const formats = {
                    'flatlay': 'Flat Lay',
                    'flat_lay': 'Flat Lay',
                    'eyelet': 'Eyelet',
                    'belt': 'Belt / Waistband',
                    'back': 'Back',
                    'fabrics': 'Fabric Detail',
                    'collar': 'Collar',
                    'sleeves': 'Sleeves',
                    'print': 'Print Detail',
                    'face': 'Face / On-Model',
                    '34': '3/4 On-Model',
                    '3/4': '3/4 On-Model'
                };
                return formats[type?.toLowerCase()] || type || 'Unknown';
            };

            // Set all results for navigation
            resultsLightbox.setResults(resultsImages.map(img => ({
                url: img.url,
                filename: img.filename,
                model: 'Ron Dorff Ecom',
                prompt: formatShotType(img.shotType)
            })));

            resultsLightbox.open(index);
        }

        async function loadResultsImages() {
            try {
                // Fetch manifest of result images
                const response = await fetch(`${RESULTS_DIR}/manifest.json`);
                const filenames = await response.json();

                // Parse each filename
                resultsImages = filenames.map(filename => {
                    // Parse: Setset_RonDorff_Ecomm_21TK189RW_collar_260219_1542_05.webp
                    const parts = filename.replace('.webp', '').split('_');
                    const sku = parts[3]; // e.g., 21TK189RW
                    const shotType = parts[4]; // e.g., collar
                    const dateTime = `${parts[5]}_${parts[6]}`; // e.g., 260219_1542
                    const index = parts[7]; // e.g., 05

                    return {
                        filename,
                        url: `${RESULTS_DIR}/${filename}`,
                        sku,
                        shotType,
                        dateTime,
                        index,
                        // Map SKU back to product
                        product: PRODUCTS.find(p => p.sku.replace(/[.-]/g, '') === sku) || null
                    };
                });

                console.log(`ðŸ“¸ Loaded ${resultsImages.length} result images`);
                renderResultsTab();
            } catch (err) {
                console.error('Failed to load results:', err);
            }
        }

        function renderResultsTab() {
            const container = document.getElementById('results-grid');
            if (!container) return;

            // Group by product
            const byProduct = {};
            resultsImages.forEach(img => {
                const key = img.sku;
                if (!byProduct[key]) byProduct[key] = {};
                if (!byProduct[key][img.shotType]) byProduct[key][img.shotType] = [];
                byProduct[key][img.shotType].push(img);
            });

            // Calculate stats
            const totalImages = resultsImages.length;
            const productsWithResults = Object.keys(byProduct).length;

            // Calculate missing shots
            let totalExpected = 0;
            let totalHave = 0;
            PRODUCTS.forEach(p => {
                const skuKey = p.sku.replace(/[.-]/g, '');
                totalExpected += p.shotTypes.length;
                if (byProduct[skuKey]) {
                    // Count how many shot types have results (use cleaned shot type for matching)
                    p.shotTypes.forEach(st => {
                        const cleanSt = st.replace(/[^a-zA-Z0-9]/g, '');
                        if (byProduct[skuKey][cleanSt] || byProduct[skuKey][st]) {
                            totalHave++;
                        }
                    });
                }
            });
            const missing = totalExpected - totalHave;

            // Update stats
            document.getElementById('results-total-count').textContent = totalImages;
            document.getElementById('results-products-count').textContent = productsWithResults;
            document.getElementById('results-missing-count').textContent = missing;

            // Build HTML
            let html = '';

            // Show each product
            PRODUCTS.forEach(product => {
                const skuKey = product.sku.replace(/[.-]/g, '');
                const productResults = byProduct[skuKey] || {};
                const hasResults = Object.keys(productResults).length > 0;

                html += `
                    <div class="results-product ${hasResults ? '' : 'no-results'}">
                        <div class="results-product-header">
                            <span class="results-product-name">${product.name}</span>
                            <span class="results-product-sku">${product.sku}</span>
                            <span class="results-product-color">${product.color}</span>
                            ${product.video ? '<span class="results-video-badge">VIDEO</span>' : '<span class="results-video-badge no-video">â€”</span>'}
                        </div>
                        <div class="results-shots">
                `;

                // Show each shot type
                product.shotTypes.forEach(shotType => {
                    // Clean shot type to match filename format (e.g., "3/4" -> "34")
                    const cleanShotType = shotType.replace(/[^a-zA-Z0-9]/g, '');
                    const shots = productResults[cleanShotType] || productResults[shotType] || [];
                    const hasShots = shots.length > 0;

                    html += `
                        <div class="results-shot-group ${hasShots ? 'has-images' : 'missing'}">
                            <div class="results-shot-label">
                                ${shotType}
                                <span class="results-shot-count">${shots.length > 0 ? shots.length : 'â€”'}</span>
                            </div>
                            <div class="results-shot-images">
                    `;

                    if (hasShots) {
                        shots.forEach(img => {
                            html += `
                                <div class="results-thumb">
                                    <img src="${img.url}" alt="${img.filename}" loading="lazy" onclick="openResultLightbox('${img.filename}')">
                                    <div class="results-thumb-info">
                                        <div class="results-thumb-filename">${img.filename.replace('Setset_RonDorff_Ecomm_', '').replace('.webp', '').replace('.png', '')}</div>
                                        <button class="results-thumb-dl" onclick="event.stopPropagation(); downloadResult('${img.url}', '${img.filename}')">DL</button>
                                    </div>
                                </div>
                            `;
                        });
                    } else {
                        html += `<div class="results-missing-placeholder">No images yet</div>`;
                    }

                    html += `
                            </div>
                        </div>
                    `;
                });

                html += `
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        // ========== FINALS TAB ==========
        const FINALS_DIR = '/rondorff-finals';
        let finalsImages = [];
        let finalsLightbox = null;

        function openFinalsLightbox(folder, filename) {
            if (!finalsLightbox) {
                finalsLightbox = new Lightbox({
                    onDownload: async (url, filename) => {
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = filename;
                        a.click();
                    }
                });
            }
            const index = finalsImages.findIndex(img => img.filename === filename);
            if (index === -1) return;
            finalsLightbox.setResults(finalsImages.map(img => ({
                url: img.url,
                filename: img.filename,
                model: 'Ron Dorff Finals',
                prompt: img.shotType
            })));
            finalsLightbox.open(index);
        }

        async function loadFinalsImages() {
            try {
                const response = await fetch(`${FINALS_DIR}/manifest.json`);
                const manifest = await response.json();
                finalsImages = manifest.map(item => {
                    const parts = item.filename.replace('.png', '').split('_');
                    const sku = parts[3];
                    const shotType = parts[4];
                    return {
                        folder: item.folder,
                        filename: item.filename,
                        url: `${FINALS_DIR}/${item.folder}/${item.filename}`,
                        sku,
                        shotType,
                        product: PRODUCTS.find(p => p.sku.replace(/[.-]/g, '') === sku) || null
                    };
                });
                console.log(`ðŸ“¦ Loaded ${finalsImages.length} finals images`);
                renderFinalsTab();
            } catch (err) {
                console.error('Failed to load finals:', err);
            }
        }

        function renderFinalsTab() {
            const container = document.getElementById('finals-grid');
            if (!container) return;

            const byProduct = {};
            finalsImages.forEach(img => {
                if (!byProduct[img.sku]) byProduct[img.sku] = {};
                if (!byProduct[img.sku][img.shotType]) byProduct[img.sku][img.shotType] = [];
                byProduct[img.sku][img.shotType].push(img);
            });

            const totalImages = finalsImages.length;
            const productsWithFinals = Object.keys(byProduct).length;
            let totalExpected = 0, totalHave = 0;
            PRODUCTS.forEach(p => {
                const skuKey = p.sku.replace(/[.-]/g, '');
                totalExpected += p.shotTypes.length;
                if (byProduct[skuKey]) {
                    p.shotTypes.forEach(st => {
                        const cleanSt = st.replace(/[^a-zA-Z0-9]/g, '');
                        if (byProduct[skuKey][cleanSt] || byProduct[skuKey][st]) totalHave++;
                    });
                }
            });

            document.getElementById('finals-total-count').textContent = totalImages;
            document.getElementById('finals-products-count').textContent = productsWithFinals;
            document.getElementById('finals-missing-count').textContent = totalExpected - totalHave;

            let html = '';
            PRODUCTS.forEach(product => {
                const skuKey = product.sku.replace(/[.-]/g, '');
                const productFinals = byProduct[skuKey] || {};
                const hasFinals = Object.keys(productFinals).length > 0;

                html += `<div class="results-product ${hasFinals ? '' : 'no-results'}">
                    <div class="results-product-header">
                        <span class="results-product-name">${product.name}</span>
                        <span class="results-product-sku">${product.sku}</span>
                        <span class="results-product-color">${product.color}</span>
                        ${product.video ? '<span class="results-video-badge">VIDEO</span>' : '<span class="results-video-badge no-video">â€”</span>'}
                    </div>
                    <div class="results-shots">`;

                product.shotTypes.forEach(shotType => {
                    const cleanShotType = shotType.replace(/[^a-zA-Z0-9]/g, '');
                    const shots = productFinals[cleanShotType] || productFinals[shotType] || [];
                    html += `<div class="results-shot-group ${shots.length ? 'has-images' : 'missing'}">
                        <div class="results-shot-label">${shotType}<span class="results-shot-count">${shots.length || 'â€”'}</span></div>
                        <div class="results-shot-images">`;
                    if (shots.length) {
                        shots.forEach(img => {
                            html += `<div class="results-thumb">
                                <img src="${img.url}" alt="${img.filename}" loading="lazy" onclick="openFinalsLightbox('${img.folder}', '${img.filename}')">
                                <div class="results-thumb-info">
                                    <div class="results-thumb-filename">${img.filename.replace('Setset_RonDorff_Ecomm_', '').replace('.png', '')}</div>
                                </div>
                            </div>`;
                        });
                    } else {
                        html += `<div class="results-missing-placeholder">â€”</div>`;
                    }
                    html += `</div></div>`;
                });
                html += `</div></div>`;
            });
            container.innerHTML = html;
        }

        // ========== INIT ==========
        async function init() {
            // Load prompts from JSON files first
            await loadProductPrompts();
            await loadProductPromptsV2();
            await loadProductPromptsV3();

            // Then initialize the rest
            loadAnalysis();
            setupSettingsButtons();
            setupCannySettings();
            setupCopySettings();
            initV3SettingsHandlers();
            renderOverview();
            renderProductSelector();
            renderCopyProductSelector();
            initCannyGrid();
            initCopyGrids();
            initVideoProducts();
            initVideoOutput();

            // Load results tab images
            loadResultsImages();

            // Load finals tab images
            loadFinalsImages();

            // Initialize Products V3 view (default view)
            setViewMode('productsV3');
        }

        init();
    </script>
</body>
</html>
