<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LockGroup v002</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ˜Ž</text></svg>">
    <link rel="stylesheet" href="/shared/css/tokens.css">
    <link rel="stylesheet" href="/shared/css/base.css">
    <link rel="stylesheet" href="/shared/css/components.css">
    <style>
        .container {
            max-width: 1400px;
        }

        /* Step Sections */
        .step-section {
            margin-bottom: var(--space-lg);
            padding-bottom: var(--space-lg);
            border-bottom: 1px solid var(--gainsboro);
        }

        .step-header {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            margin-bottom: var(--space-md);
        }

        .step-number {
            width: 28px;
            height: 28px;
            background: var(--jet);
            color: var(--white);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: var(--text-sm);
            font-weight: 600;
        }

        .step-title {
            font-size: var(--text-lg);
            font-weight: 600;
            color: var(--jet);
        }

        .step-subtitle {
            font-size: var(--text-sm);
            color: var(--slate);
            margin-left: auto;
        }

        /* Model Upload - Compact */
        .model-upload-area {
            display: flex;
            gap: var(--space-md);
            align-items: flex-start;
        }

        .model-upload-slot {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--space-xs);
        }

        .model-slot-label {
            font-size: var(--text-xs);
            color: var(--slate);
        }

        .model-preview {
            width: 120px;
            aspect-ratio: 3/4;
            border: 2px dashed var(--gainsboro);
            border-radius: var(--radius-md);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            overflow: hidden;
            transition: all var(--transition-fast);
            background: var(--off-white);
        }

        .model-preview:hover {
            border-color: var(--jet);
        }

        .model-preview.has-image {
            border-style: solid;
            border-color: var(--jet);
        }

        .model-preview img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .model-preview-placeholder {
            text-align: center;
            color: var(--ash-grey);
            padding: var(--space-sm);
            font-size: var(--text-xs);
        }

        .model-preview-placeholder svg {
            width: 32px;
            height: 32px;
            margin-bottom: var(--space-2xs);
            opacity: 0.5;
        }

        /* Model Tabs */
        .model-tabs {
            display: flex;
            gap: 0;
            margin-bottom: var(--space-md);
            border-bottom: 1px solid var(--gainsboro);
        }

        .model-tab {
            padding: 10px 20px;
            font-size: var(--text-sm);
            font-weight: 500;
            background: none;
            border: none;
            border-bottom: 2px solid transparent;
            color: var(--slate);
            cursor: pointer;
            transition: all var(--transition-fast);
            margin-bottom: -1px;
        }

        .model-tab:hover {
            color: var(--jet);
        }

        .model-tab.active {
            color: var(--jet);
            border-bottom-color: var(--jet);
        }

        .model-tab-content {
            min-height: 100px;
        }

        .model-empty-message {
            color: var(--ash-grey);
            font-size: var(--text-sm);
            text-align: center;
            padding: var(--space-lg);
        }

        .model-discovered-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 4px;
        }

        .model-thumb {
            aspect-ratio: 3/4;
            border-radius: var(--radius-sm);
            overflow: hidden;
            cursor: pointer;
            position: relative;
            border: 2px solid var(--gainsboro);
            transition: all var(--transition-fast);
            background: var(--off-white);
        }

        .model-thumb:hover {
            border-color: var(--ash-grey);
        }

        .model-thumb.selected {
            border-color: var(--jet);
        }

        .model-thumb img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .model-thumb .check-mark {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 18px;
            height: 18px;
            background: var(--jet);
            color: var(--white);
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 11px;
        }

        .model-thumb.selected .check-mark {
            display: flex;
        }

        /* Folder Drop Zone */
        .folder-drop-zone {
            min-height: 150px;
            border: 2px dashed var(--gainsboro);
            border-radius: var(--radius-md);
            padding: var(--space-md);
            transition: all var(--transition-fast);
            background: var(--off-white);
        }

        .folder-drop-zone.drag-over {
            border-color: var(--jet);
            background: var(--white);
        }

        .folder-drop-zone.has-looks {
            border-style: solid;
            border-color: var(--gainsboro);
            background: var(--white);
        }

        .drop-placeholder {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 120px;
            color: var(--ash-grey);
            text-align: center;
        }

        .drop-placeholder svg {
            width: 48px;
            height: 48px;
            margin-bottom: var(--space-xs);
            opacity: 0.5;
        }

        .drop-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 120px;
            color: var(--slate);
            text-align: center;
            gap: var(--space-xs);
        }

        .drop-loading-spinner {
            width: 24px;
            height: 24px;
            border: 2px solid var(--gainsboro);
            border-top-color: #002FA7;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Studio message - sweep effect */
        .studio-message {
            font-size: var(--text-sm);
            font-weight: 500;
            background: linear-gradient(90deg,
                rgba(0, 47, 167, 0.4) 0%,
                rgba(0, 47, 167, 1) 50%,
                rgba(0, 47, 167, 0.4) 100%);
            background-size: 200% 100%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: sweep 1.8s ease-in-out infinite;
        }

        .studio-message.fade-out {
            animation: fade-out 0.25s ease-out forwards;
        }

        .studio-message.fade-in {
            animation: fade-in 0.25s ease-out forwards;
        }

        @keyframes sweep {
            0% { background-position: 100% 0; }
            100% { background-position: -100% 0; }
        }

        @keyframes fade-out {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        @keyframes fade-in {
            0% { opacity: 0; }
            100% { opacity: 1; }
        }

        /* Looks Grid - Main Display */
        .looks-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: var(--space-md);
        }

        .look-card {
            border: 2px solid var(--gainsboro);
            border-radius: var(--radius-md);
            overflow: hidden;
            background: var(--white);
            transition: all var(--transition-fast);
        }

        .look-card.selected {
            border-color: var(--jet);
        }

        .look-card-header {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            padding: var(--space-sm);
            background: var(--off-white);
            border-bottom: 1px solid var(--gainsboro);
            cursor: pointer;
        }

        .look-card-header:hover {
            background: var(--gainsboro);
        }

        .look-checkbox {
            width: 18px;
            height: 18px;
            accent-color: var(--jet);
        }

        .look-name {
            flex: 1;
            font-size: var(--text-sm);
            font-weight: 500;
            color: var(--jet);
        }

        .look-count {
            font-size: var(--text-xs);
            color: var(--slate);
            margin-right: var(--space-sm);
        }

        .look-columns {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-left: auto;
        }

        .look-columns-slider {
            width: 60px;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--gainsboro);
            border-radius: 2px;
            cursor: pointer;
        }

        .look-columns-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: var(--jet);
            border-radius: 50%;
            cursor: pointer;
        }

        .look-columns-slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: var(--jet);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .look-columns-value {
            font-size: 11px;
            color: var(--slate);
            min-width: 8px;
            text-align: center;
        }

        .look-card-images {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 4px;
            padding: 4px;
            max-height: 320px;
            overflow-y: auto;
        }

        .look-image-thumb {
            aspect-ratio: 3/4;
            overflow: hidden;
            cursor: pointer;
            position: relative;
            border: 2px solid var(--gainsboro);
            border-radius: var(--radius-sm);
            transition: all var(--transition-fast);
            background: var(--off-white);
        }

        .look-image-thumb:hover {
            border-color: var(--ash-grey);
            z-index: 10;
        }

        .look-image-thumb.front {
            border-color: #2563eb;
        }

        .look-image-thumb.back {
            border-color: #ea580c;
        }

        .look-image-thumb.all {
            border-color: #16a34a;
        }

        .look-image-thumb img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: center;
            transition: transform 0.15s ease-out;
            transform-origin: center center;
            display: block;
        }

        .look-image-thumb .image-type {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(255,255,255,0.5);
            color: var(--jet);
            font-size: 10px;
            padding: 4px 6px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
            z-index: 5;
        }

        .look-image-thumb .check-mark {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 18px;
            height: 18px;
            background: var(--jet);
            color: var(--white);
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            z-index: 5;
        }

        .look-image-thumb.front .check-mark,
        .look-image-thumb.back .check-mark,
        .look-image-thumb.all .check-mark {
            display: flex;
        }

        .look-image-thumb.front .check-mark {
            background: #2563eb;
        }

        .look-image-thumb.back .check-mark {
            background: #ea580c;
        }

        .look-image-thumb.all .check-mark {
            background: #16a34a;
        }

        .look-image-thumb .selection-label {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 3px 6px;
            text-align: center;
            font-size: 9px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            z-index: 5;
        }

        .look-image-thumb.front .selection-label {
            background: #2563eb;
            color: white;
        }

        .look-image-thumb.back .selection-label {
            background: #ea580c;
            color: white;
        }

        .look-image-thumb.all .selection-label {
            background: #16a34a;
            color: white;
        }

        .look-card-footer {
            padding: var(--space-sm);
            border-top: 1px solid var(--gainsboro);
            display: flex;
            flex-direction: column;
            gap: var(--space-xs);
        }

        .look-card-footer input[type="text"] {
            padding: var(--space-sm);
            font-size: var(--text-sm);
        }

        .look-card-actions {
            display: flex;
            gap: var(--space-xs);
            align-items: center;
        }

        .btn-analyze {
            padding: 8px 14px;
            font-size: var(--text-xs);
            font-weight: 500;
            border: 1px solid var(--jet);
            border-radius: var(--radius-sm);
            background: var(--jet);
            color: var(--white);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .btn-analyze:hover {
            background: var(--slate);
            border-color: var(--slate);
        }

        .btn-analyze:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-analyze.analyzed {
            background: var(--white);
            color: var(--jet);
        }

        .look-analysis {
            font-size: var(--text-xs);
            color: var(--slate);
            line-height: 1.5;
            padding: var(--space-xs);
            background: var(--off-white);
            border-radius: var(--radius-sm);
            max-height: 80px;
            overflow-y: auto;
        }

        .look-analysis-status {
            font-size: var(--text-xs);
            color: var(--ash-grey);
            font-style: italic;
        }

        .look-card-prompt input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-sm);
            font-size: var(--text-sm);
            background: var(--off-white);
        }

        .look-card-prompt input:focus {
            outline: none;
            border-color: var(--jet);
            background: var(--white);
        }

        .look-card-prompt input::placeholder {
            color: var(--ash-grey);
        }

        /* Poses Grid */
        .poses-container {
            display: flex;
            flex-direction: column;
            gap: var(--space-lg);
        }

        .pose-category-title {
            font-size: var(--text-xs);
            font-weight: 600;
            color: var(--slate);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: var(--space-sm);
        }

        .poses-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: var(--space-sm);
        }

        .pose-card {
            display: flex;
            flex-direction: column;
            border-radius: var(--radius-md);
            overflow: hidden;
            border: 2px solid var(--gainsboro);
            transition: all var(--transition-fast);
            background: var(--white);
            cursor: pointer;
        }

        .pose-card:hover {
            border-color: var(--ash-grey);
        }

        .pose-card.active {
            border-color: var(--jet);
        }

        .pose-card-image {
            aspect-ratio: 3/4;
            position: relative;
            overflow: hidden;
        }

        .pose-card-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .pose-card .pose-name {
            font-size: 10px;
            padding: 4px 2px;
            text-align: center;
            background: var(--off-white);
            color: var(--slate);
            border-top: 1px solid var(--gainsboro);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .pose-card .pose-count {
            position: absolute;
            top: 4px;
            right: 4px;
            min-width: 18px;
            height: 18px;
            background: var(--jet);
            color: var(--white);
            border-radius: 9px;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 600;
            padding: 0 4px;
        }

        .pose-card.active .pose-count {
            display: flex;
        }

        .pose-slider-row {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px 4px;
            background: var(--off-white);
        }

        .pose-slider {
            width: 95%;
            -webkit-appearance: none;
            height: 2px;
            background: var(--gainsboro);
            border-radius: 1px;
            outline: none;
            margin: 0;
        }

        .pose-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: var(--jet);
            border-radius: 50%;
            cursor: pointer;
        }

        /* Generate Section */
        .generate-section {
            background: var(--off-white);
            border-radius: var(--radius-md);
            padding: var(--space-md);
        }

        .calc-display {
            font-size: var(--text-sm);
            color: var(--slate);
            margin-bottom: var(--space-sm);
            text-align: center;
        }

        .generate-buttons {
            display: flex;
            gap: var(--space-sm);
            align-items: stretch;
        }

        .analyze-section {
            margin-bottom: var(--space-sm);
        }

        .analyze-progress {
            margin-top: var(--space-sm);
        }

        .analyze-progress-bar {
            height: 6px;
            background: var(--silver);
            border-radius: 3px;
            overflow: hidden;
        }

        .analyze-progress-fill {
            height: 100%;
            background: var(--jet);
            width: 0%;
            transition: width 0.3s ease;
        }

        .analyze-progress-text {
            font-size: var(--text-xs);
            color: var(--ash-grey);
            text-align: center;
            margin-top: var(--space-xs);
        }

        .btn--secondary {
            background: var(--white);
            border: 1px solid var(--jet);
            color: var(--jet);
            min-width: 160px;
            position: relative;
        }

        .btn--secondary:hover:not(:disabled) {
            background: var(--off-white);
        }

        .btn--secondary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn--secondary.analyzing {
            opacity: 1;
            min-width: 200px;
        }

        .btn--secondary.analyzing .btn-text {
            display: none;
        }

        .btn--secondary .btn-loader {
            display: none;
        }

        .btn--secondary.analyzing .btn-loader {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn-loader-spinner {
            width: 18px;
            height: 18px;
            border: 2px solid rgba(0, 47, 167, 0.2);
            border-top-color: #002FA7;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        .btn-loader-text {
            display: none;
        }

        /* Progress Section */
        .progress-section {
            display: none;
            margin-top: var(--space-lg);
            padding: var(--space-lg);
            background: var(--white);
            border-radius: var(--radius-lg);
            border: 1px solid var(--gainsboro);
        }

        .progress-section.visible {
            display: block;
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-sm);
        }

        .progress-title {
            font-size: var(--text-xs);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--slate);
        }

        .progress-count {
            font-size: var(--text-sm);
            font-weight: 600;
            color: var(--jet);
        }

        .progress-bar-container {
            height: 8px;
            background: var(--off-white);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: var(--space-md);
        }

        .progress-bar {
            height: 100%;
            background: var(--jet);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }

        /* Results */
        .results-section {
            margin-top: var(--space-lg);
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: var(--space-md);
        }

        .result-card {
            position: relative;
            border-radius: var(--radius-md);
            overflow: hidden;
            cursor: pointer;
            background: var(--off-white);
        }

        .result-card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .result-card .result-tag {
            position: absolute;
            bottom: var(--space-xs);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: var(--white);
            padding: 2px 8px;
            border-radius: var(--radius-sm);
            font-size: var(--text-2xs);
            text-align: center;
            white-space: nowrap;
        }

        /* Error */
        .error {
            display: none;
            background: #fef2f2;
            border: 1px solid #fecaca;
            padding: var(--space-sm);
            color: #991b1b;
            margin-bottom: var(--space-md);
            font-size: var(--text-base);
            text-align: center;
            border-radius: var(--radius-md);
        }

        .error.show {
            display: block;
        }

        input[type="file"] {
            display: none;
        }

        /* Lightbox nav - minimal arrows */
        .lightbox-nav {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background: transparent;
            border: none;
            padding: var(--space-md);
            font-size: 28px;
            cursor: pointer;
            color: rgba(255,255,255,0.6);
            z-index: 10;
            transition: color var(--transition-fast);
        }

        .lightbox-nav:hover {
            color: var(--white);
        }

        .lightbox-nav:disabled {
            opacity: 0.2;
            cursor: not-allowed;
        }

        .lightbox-nav.prev {
            left: var(--space-sm);
        }

        .lightbox-nav.next {
            right: calc(33.33% + var(--space-sm));
        }

        .lightbox-counter {
            font-size: var(--text-sm);
            color: var(--slate);
            margin-bottom: var(--space-sm);
            text-align: center;
        }

        .lightbox-source-images {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: var(--space-xs);
        }

        .lightbox-source-images img {
            width: 100%;
            aspect-ratio: 3/4;
            object-fit: cover;
            border-radius: var(--radius-sm);
            border: 1px solid rgba(255,255,255,0.2);
        }

        /* Collapsible prompt section */
        .lightbox-section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            user-select: none;
            padding: 10px 12px;
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.4);
            border-radius: var(--radius-sm);
            margin-bottom: var(--space-xs);
        }

        .lightbox-section-header:hover {
            background: rgba(255,255,255,0.15);
            border-color: rgba(255,255,255,0.6);
        }

        .lightbox-section-header:hover .lightbox-section-title {
            color: var(--white);
        }

        .lightbox-collapse-arrow {
            font-size: 10px;
            transition: transform 0.2s ease;
            color: rgba(255,255,255,0.6);
        }

        .lightbox-section.collapsed .lightbox-collapse-arrow {
            transform: rotate(-90deg);
        }

        .lightbox-section.collapsed .lightbox-collapsible {
            display: none;
        }

        .lightbox-collapsible {
            padding: var(--space-sm);
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: var(--radius-sm);
            margin-top: var(--space-xs);
        }

        /* Edit section */
        .lightbox-edit-section {
            margin-top: var(--space-md);
            padding-top: var(--space-md);
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        .lightbox-edit-input {
            width: 100%;
            padding: 12px 14px;
            border: 2px solid var(--white);
            border-radius: var(--radius-sm);
            font-size: var(--text-sm);
            background: rgba(255,255,255,0.1);
            color: var(--white);
            resize: vertical;
            min-height: 70px;
            font-family: inherit;
        }

        .lightbox-edit-input:focus {
            outline: none;
            border-color: var(--white);
            background: rgba(255,255,255,0.15);
        }

        .lightbox-edit-input::placeholder {
            color: rgba(255,255,255,0.6);
        }

        .lightbox-model-buttons {
            display: flex;
            gap: var(--space-xs);
            margin: var(--space-sm) 0;
        }

        .lightbox-model-btn {
            flex: 1;
            padding: 10px 12px;
            font-size: var(--text-xs);
            font-weight: 600;
            border: 2px solid var(--white);
            border-radius: var(--radius-sm);
            background: transparent;
            color: var(--white);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .lightbox-model-btn:hover {
            background: rgba(255,255,255,0.1);
        }

        .lightbox-model-btn.active {
            background: var(--white);
            color: var(--jet);
            border-color: var(--white);
        }

        .lightbox-remix-btn {
            width: 100%;
            padding: 14px;
            font-size: var(--text-sm);
            font-weight: 600;
            border: 2px solid var(--white);
            border-radius: var(--radius-sm);
            background: var(--white);
            color: var(--jet);
            cursor: pointer;
            transition: all var(--transition-fast);
            margin-top: var(--space-sm);
        }

        .lightbox-remix-btn:hover {
            background: transparent;
            color: var(--white);
        }

        .lightbox-remix-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Loading overlay on image - white with opacity */
        .lightbox-left {
            position: relative;
        }

        .lightbox-image-loader {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255,255,255,0.5);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: var(--space-sm);
        }

        .lightbox-image-loader.visible {
            display: flex;
        }

        .lightbox-image-loader .loader-spinner {
            width: 36px;
            height: 36px;
            border: 3px solid rgba(0,47,167,0.2);
            border-top-color: #002FA7;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        .lightbox-image-loader .loader-text {
            font-size: var(--text-sm);
            font-weight: 600;
            color: #002FA7;
        }

        /* History section */
        .lightbox-history {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: var(--space-xs);
            margin-top: var(--space-sm);
        }

        .lightbox-history-item {
            aspect-ratio: 3/4;
            border-radius: var(--radius-sm);
            overflow: hidden;
            cursor: pointer;
            border: 2px solid rgba(255,255,255,0.2);
            opacity: 0.7;
            transition: all var(--transition-fast);
        }

        .lightbox-history-item:hover {
            opacity: 1;
            border-color: rgba(255,255,255,0.5);
            transform: scale(1.05);
        }

        .lightbox-history-item.selected {
            opacity: 1;
            border-color: var(--white);
            box-shadow: 0 0 0 2px rgba(255,255,255,0.3);
        }

        .lightbox-history-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .lightbox-history-label {
            font-size: var(--text-xs);
            color: var(--slate);
            margin-bottom: var(--space-2xs);
        }

        /* Batch info */
        .batch-info {
            display: flex;
            gap: var(--space-md);
            margin-top: var(--space-sm);
            padding: var(--space-sm);
            background: var(--white);
            border-radius: var(--radius-sm);
            font-size: var(--text-xs);
            color: var(--slate);
        }

        .batch-info-item {
            display: flex;
            gap: var(--space-2xs);
        }

        .batch-info-item strong {
            color: var(--jet);
        }

        /* Action Buttons */
        .btn-mini {
            padding: 8px 16px;
            font-size: var(--text-sm);
            font-weight: 500;
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-sm);
            background: var(--white);
            color: var(--jet);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .btn-mini:hover {
            background: var(--off-white);
            border-color: var(--jet);
        }

        /* Actions bar */
        .looks-actions {
            display: flex;
            gap: var(--space-sm);
            margin-bottom: var(--space-md);
        }

        /* Setset Models Grid */
        .setset-models-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: var(--space-sm);
        }

        .setset-model-card {
            position: relative;
            aspect-ratio: 3/4;
            border-radius: var(--radius-md);
            overflow: hidden;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all var(--transition-fast);
        }

        .setset-model-card:hover {
            border-color: var(--ash-grey);
        }

        .setset-model-card.selected {
            border-color: var(--jet);
        }

        .setset-model-card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .setset-model-card .model-name {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 4px 6px;
            background: linear-gradient(transparent, rgba(0,0,0,0.7));
            color: white;
            font-size: var(--text-xs);
            text-align: center;
        }

        .setset-model-card .model-check {
            position: absolute;
            top: 6px;
            right: 6px;
            width: 20px;
            height: 20px;
            background: var(--jet);
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
        }

        .setset-model-card.selected .model-check {
            display: flex;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="hero">
            <h1>LockGroup</h1>
            <p class="hero-subtitle">Batch generate styled looks from product folders</p>
        </div>

        <div class="error" id="error"></div>

        <!-- Step 1: Model Reference (hidden until folder is dropped) -->
        <div class="step-section" id="modelSection" style="display: none;">
            <div class="step-header">
                <span class="step-number">1</span>
                <span class="step-title">Model Reference</span>
            </div>
            <div class="model-tabs">
                <button class="model-tab" data-tab="discovered">Discovered</button>
                <button class="model-tab" data-tab="upload">Upload</button>
                <button class="model-tab active" data-tab="setset">Setset Models</button>
            </div>
            <div class="model-tab-content" id="tabDiscovered" style="display: none;">
                <div class="model-discovered-grid" id="modelDiscoveredGrid"></div>
                <p class="model-empty-message" id="modelEmptyMessage">Drop a folder with model images to auto-detect</p>
            </div>
            <div class="model-tab-content" id="tabUpload" style="display: none;">
                <div class="model-upload-area" id="modelUploadArea">
                    <div class="model-upload-slot">
                        <div class="model-preview" id="modelPreview" data-type="fullbody">
                            <div class="model-preview-placeholder">
                                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                                </svg>
                                <div>Full Body</div>
                            </div>
                        </div>
                        <div class="model-slot-label">Full Body</div>
                    </div>
                    <div class="model-upload-slot">
                        <div class="model-preview" id="modelPreviewPortrait" data-type="portrait">
                            <div class="model-preview-placeholder">
                                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                                </svg>
                                <div>Portrait</div>
                            </div>
                        </div>
                        <div class="model-slot-label">Portrait</div>
                    </div>
                    <input type="file" id="modelInput" accept="image/*">
                    <input type="file" id="modelInputPortrait" accept="image/*">
                </div>
            </div>
            <div class="model-tab-content" id="tabSetset">
                <div class="setset-models-grid" id="setsetModelsGrid"></div>
            </div>
        </div>

        <!-- Step 1/2: Products Folder (starts as step 1, becomes step 2 after model section appears) -->
        <div class="step-section" id="folderSection">
            <div class="step-header">
                <span class="step-number" id="folderStepNumber">1</span>
                <span class="step-title">Drop Product Folder</span>
            </div>
            <p style="font-size: var(--text-sm); color: var(--slate); margin-bottom: var(--space-md);">
                Drop the parent folder containing product subfolders (each with <strong>Hero_Product</strong> and <strong>Looks</strong> inside)
            </p>
            <div class="folder-drop-zone" id="folderDropZone">
                <div class="drop-placeholder" id="dropPlaceholder">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" />
                    </svg>
                    <div>Drop product folder here<br><small>e.g., "Set Set SMC Products - JPEG"</small></div>
                </div>
                <div class="drop-loading" id="dropLoading" style="display: none;">
                    <div class="drop-loading-spinner"></div>
                    <div class="studio-message" id="drop-studio-message">Setting up studio...</div>
                </div>
                <div id="looksContainer" style="display: none;">
                    <div class="looks-actions">
                        <button class="btn-mini" onclick="selectAllLooks()">Select All</button>
                        <button class="btn-mini" onclick="deselectAllLooks()">Deselect All</button>
                    </div>
                    <div class="looks-grid" id="looksGrid"></div>
                    <div class="batch-info" id="batchInfo">
                        <div class="batch-info-item"><strong id="lookCountDisplay">0</strong> Looks detected</div>
                        <div class="batch-info-item"><strong id="selectedCountDisplay">0</strong> selected</div>
                        <div class="batch-info-item"><strong id="imageCountDisplay">0</strong> images total</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Step 3: Poses -->
        <div class="step-section">
            <div class="step-header">
                <span class="step-number">3</span>
                <span class="step-title">Select Poses</span>
            </div>
            <div class="poses-container" id="posesContainer"></div>
        </div>

        <!-- Step 4: Generate -->
        <div class="step-section" style="border-bottom: none;">
            <div class="step-header">
                <span class="step-number">4</span>
                <span class="step-title">Generate Images</span>
            </div>
            <div class="generate-section">
                <div class="settings-row" style="margin-bottom: var(--space-md);">
                    <div class="setting-group">
                        <label class="setting-label">Model</label>
                        <div class="btn-group" id="model-buttons">
                            <button class="btn btn--toggle" data-value="nano">Nano</button>
                            <button class="btn btn--toggle active" data-value="nano-pro">Nano Pro</button>
                        </div>
                    </div>
                    <div class="setting-group">
                        <label class="setting-label">Lighting</label>
                        <div class="btn-group" id="lighting-buttons">
                            <button class="btn btn--toggle active" data-value="default">Default</button>
                            <button class="btn btn--toggle" data-value="stella">Stella</button>
                        </div>
                    </div>
                    <div class="setting-group">
                        <label class="setting-label">Aspect Ratio</label>
                        <div class="btn-group" id="aspect-buttons">
                            <button class="btn btn--toggle active" data-value="3:4">3:4</button>
                            <button class="btn btn--toggle" data-value="1:1">1:1</button>
                            <button class="btn btn--toggle" data-value="4:3">4:3</button>
                        </div>
                    </div>
                    <div class="setting-group">
                        <label class="setting-label">Resolution</label>
                        <div class="btn-group" id="resolution-buttons">
                            <button class="btn btn--toggle" data-value="1K">1K</button>
                            <button class="btn btn--toggle active" data-value="2K">2K</button>
                        </div>
                    </div>
                </div>

                <div class="calc-display" id="calc-display">Drop folder and select poses to generate</div>

                <!-- Analyze Section -->
                <div class="analyze-section">
                    <button class="btn btn--secondary btn--lg" id="analyzeAllBtn" disabled style="width: 100%;">
                        <span class="btn-text">Analyze Products</span>
                        <span class="btn-loader">
                            <span class="btn-loader-spinner"></span>
                            <span class="btn-loader-text" id="analyzeLoaderText">Analyzing...</span>
                        </span>
                    </button>
                    <div class="analyze-progress" id="analyzeProgress" style="display: none;">
                        <div class="analyze-progress-bar">
                            <div class="analyze-progress-fill" id="analyzeProgressFill"></div>
                        </div>
                        <div class="analyze-progress-text" id="analyzeProgressText">Analyzing 0 / 0</div>
                    </div>
                </div>

                <!-- Generate Button -->
                <div class="generate-buttons">
                    <button class="btn btn--primary btn--lg" id="generateBtn" disabled style="width: 100%;">
                        Generate Images <span class="btn-cost" id="cost-value">$0.00</span>
                    </button>
                </div>
            </div>
        </div>

        <!-- Progress -->
        <div class="progress-section" id="progress-section">
            <div class="progress-header">
                <span class="progress-title">Generating</span>
                <span class="progress-count" id="progress-count">0 / 0</span>
            </div>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
            <div class="studio-message" id="progress-studio-message">Setting up studio...</div>
        </div>

        <!-- Results -->
        <div class="results-section" id="results-section">
            <div class="results-header">
                <h2>Results</h2>
                <p class="results-subtitle">Click to view details</p>
            </div>
            <div class="results-grid" id="results-grid"></div>
        </div>
    </div>

    <!-- Lightbox -->
    <div class="lightbox" id="lightbox">
        <div class="lightbox-content">
            <button class="lightbox-close" id="lightbox-close">&times;</button>
            <button class="lightbox-nav prev" id="lightbox-prev">&larr;</button>
            <button class="lightbox-nav next" id="lightbox-next">&rarr;</button>
            <div class="lightbox-left">
                <img src="" alt="" class="lightbox-image" id="lightbox-image">
                <div class="lightbox-image-loader" id="lightbox-loader">
                    <div class="loader-spinner"></div>
                    <div class="loader-text" id="lightbox-loader-text">Remixing...</div>
                </div>
            </div>
            <div class="lightbox-right">
                <div class="lightbox-counter" id="lightbox-counter">1 / 1</div>
                <div class="lightbox-section">
                    <h3 class="lightbox-section-title">Look</h3>
                    <p class="lightbox-model-text" id="lightbox-look"></p>
                </div>
                <div class="lightbox-section">
                    <h3 class="lightbox-section-title">Pose</h3>
                    <p class="lightbox-model-text" id="lightbox-pose"></p>
                </div>
                <div class="lightbox-section collapsed" id="lightbox-prompt-section">
                    <div class="lightbox-section-header" onclick="togglePromptSection()">
                        <h3 class="lightbox-section-title">Prompt</h3>
                        <span class="lightbox-collapse-arrow">â–¼</span>
                    </div>
                    <div class="lightbox-collapsible">
                        <p class="lightbox-prompt-text" id="lightbox-prompt"></p>
                    </div>
                </div>
                <div class="lightbox-section">
                    <h3 class="lightbox-section-title">Source Images</h3>
                    <div class="lightbox-source-images" id="lightbox-source-images"></div>
                </div>

                <!-- History -->
                <div class="lightbox-section" id="lightbox-history-section" style="display: none;">
                    <div class="lightbox-history-label">History</div>
                    <div class="lightbox-history" id="lightbox-history"></div>
                </div>

                <!-- Edit/Remix Section -->
                <div class="lightbox-edit-section">
                    <h3 class="lightbox-section-title">Edit</h3>
                    <textarea class="lightbox-edit-input" id="lightbox-edit-input" placeholder="Describe changes... e.g. 'make the jeans baggier' or 'change background to outdoor'"></textarea>
                    <div class="lightbox-model-buttons">
                        <button class="lightbox-model-btn active" data-model="nano" onclick="setLightboxModel('nano')">Nano</button>
                        <button class="lightbox-model-btn" data-model="nano-pro" onclick="setLightboxModel('nano-pro')">Nano Pro</button>
                    </div>
                    <button class="lightbox-remix-btn" id="lightbox-remix-btn" onclick="remixCurrentImage()">Remix</button>
                </div>

                <button class="lightbox-download" id="lightbox-download">Download Image</button>
            </div>
        </div>
    </div>

    <!-- Loading -->
    <div class="loading-overlay" id="loading">
        <div class="spinner"></div>
        <p class="loading-text" id="loading-text">Processing...</p>
    </div>

    <!-- Scripts -->
    <script src="poses.js"></script>
    <script src="/shared/js/utils.js"></script>
    <script src="/shared/js/api.js"></script>

    <script>
        // Studio messages for fun loader
        const STUDIO_MESSAGES = [
            "Setting up the Studio...",
            "Adjusting the Key Light...",
            "Loading the Film...",
            "Warming up the Strobes...",
            "Preparing the Backdrop...",
            "Adjusting the Fill Light...",
            "Checking the Framing...",
            "Setting the Aperture...",
            "Loading Color Profiles...",
            "Positioning the C-Stand...",
            "Focusing...",
            "Checking Tethering...",
            "Rolling...",
            "Adjusting the Umbrella...",
            "Metering...",
            "Standby...",
            "Loading the Presets...",
            "Quiet on Set...",
            "Final Touches...",
            "Almost There...",
            "Testing...",
            "Checking the Batteries...",
            "One Moment...",
            "Preparing the Fan...",
            "Setting the Focal Length...",
            "Hold Please...",
            "Touch-Ups...",
            "Cueing the Talent...",
            "Composing...",
            "Ready When You Are...",
            "Dialing It In...",
            "Setting the Scene...",
            "Looking Good...",
            "Locking Focus...",
            "Last Looks...",
            "Warming Up...",
            "Standing By...",
            "All Set...",
            "Getting Close...",
            "Picture Ready...",
            "Checking the Light...",
            "Take Your Mark...",
            "Here We Go...",
            "Exposure Set...",
            "Finding the Angle...",
            "Frame Locked...",
            "Just a Sec...",
            "Setting Up...",
            "Ready...",
            "Working on It..."
        ];

        let studioMessageInterval = null;
        let currentMessageElement = null;

        // Studio message cycling functions
        function startStudioMessages(targetElement) {
            if (studioMessageInterval) return;
            currentMessageElement = targetElement;
            let lastIndex = -1;

            const updateMessage = () => {
                if (!currentMessageElement) return;

                let idx;
                do {
                    idx = Math.floor(Math.random() * STUDIO_MESSAGES.length);
                } while (idx === lastIndex && STUDIO_MESSAGES.length > 1);
                lastIndex = idx;

                // Fade out
                currentMessageElement.classList.add('fade-out');
                currentMessageElement.classList.remove('fade-in');

                setTimeout(() => {
                    if (!currentMessageElement) return;
                    currentMessageElement.textContent = STUDIO_MESSAGES[idx];
                    currentMessageElement.classList.remove('fade-out');
                    currentMessageElement.classList.add('fade-in');

                    // Resume pulse after fade-in
                    setTimeout(() => {
                        if (currentMessageElement) {
                            currentMessageElement.classList.remove('fade-in');
                        }
                    }, 250);
                }, 250);
            };

            // Initial message
            if (currentMessageElement) {
                currentMessageElement.textContent = STUDIO_MESSAGES[Math.floor(Math.random() * STUDIO_MESSAGES.length)];
            }

            studioMessageInterval = setInterval(updateMessage, 2500);
        }

        function stopStudioMessages() {
            if (studioMessageInterval) {
                clearInterval(studioMessageInterval);
                studioMessageInterval = null;
            }
            currentMessageElement = null;
        }

        // Setset internal talent roster
        const SETSET_MODELS = [
            { id: 'james', name: 'James Wilson', image: '/shared/images/talent/talent-01_JamesWilson.png' },
            { id: 'maya', name: 'Maya Johnson', image: '/shared/images/talent/talent-02_MayaJohnson.png' },
            { id: 'river', name: 'River Blake', image: '/shared/images/talent/talent-03_RiverBlake.png' },
            { id: 'emma', name: 'Emma Sullivan', image: '/shared/images/talent/talent-04_EmmaSullivan.png' },
            { id: 'marcus', name: 'Marcus Brown', image: '/shared/images/talent/talent-05_MarcusBrown.png' },
            { id: 'zara', name: 'Zara Mitchell', image: '/shared/images/talent/talent-06_ZaraMitchell.png' },
            { id: 'sophia', name: 'Sophia Anderson', image: '/shared/images/talent/talent-07_SophiaAnderson.png' },
            { id: 'liam', name: 'Liam Garcia', image: '/shared/images/talent/talent-08_LiamGarcia.png' },
            { id: 'nina', name: 'Nina Davis', image: '/shared/images/talent/talent-09_NinaDavis.png' },
            { id: 'ava', name: 'Ava Martinez', image: '/shared/images/talent/talent-10_AvaMartinez.png' },
            { id: 'luna', name: 'Luna Park', image: '/shared/images/talent/talent-11_LunaPark.png' },
            { id: 'noah', name: 'Noah Chen', image: '/shared/images/talent/talent-12_NoahChen.png' },
            { id: 'kai', name: 'Kai Thompson', image: '/shared/images/talent/talent-13_KaiThompson.png' },
            { id: 'riley', name: 'Riley Morgan', image: '/shared/images/talent/talent-14_RileyMorgan.png' },
            { id: 'jordan', name: 'Jordan Lee', image: '/shared/images/talent/talent-15_JordanLee.png' },
            { id: 'isabella', name: 'Isabella Rodriguez', image: '/shared/images/talent/talent-16_IsabellaRodriguez.png' },
            { id: 'quinn', name: 'Quinn Santos', image: '/shared/images/talent/talent-17_QuinnSantos.png' },
            { id: 'casey', name: 'Casey White', image: '/shared/images/talent/talent-18_CaseyWhite.png' },
            { id: 'sam', name: 'Sam Wilson', image: '/shared/images/talent/talent-19_SamWilson.png' },
            { id: 'drew', name: 'Drew Martinez', image: '/shared/images/talent/talent-20_DrewMartinez.png' },
            { id: 'avery', name: 'Avery Taylor', image: '/shared/images/talent/talent-21_AveryTaylor.png' },
            { id: 'parker', name: 'Parker Miller', image: '/shared/images/talent/talent-22_ParkerMiller.png' },
            { id: 'morgan', name: 'Morgan Kim', image: '/shared/images/talent/talent-23_MorganKim.png' },
            { id: 'andre', name: 'Andre Jackson', image: '/shared/images/talent/talent-24_AndreJackson.png' }
        ];

        // State
        const state = {
            modelImage: null,
            modelImagePortrait: null,
            modelImages: [], // Array of { thumbnail, file, selected, name }
            setsetModels: [], // Array of selected Setset model IDs
            looks: [], // Array of { name, id, selected, heroImages: [], looksImages: [] }
            poseCounts: {}, // { poseId: count }
            aspectRatio: '3:4',
            resolution: '2K',
            selectedModel: 'nano-pro',
            selectedLighting: 'default',
            results: [],
            lightboxIndex: 0
        };

        // DOM Elements
        const elements = {
            modelPreview: document.getElementById('modelPreview'),
            modelPreviewPortrait: document.getElementById('modelPreviewPortrait'),
            modelInput: document.getElementById('modelInput'),
            modelInputPortrait: document.getElementById('modelInputPortrait'),
            folderDropZone: document.getElementById('folderDropZone'),
            dropPlaceholder: document.getElementById('dropPlaceholder'),
            looksContainer: document.getElementById('looksContainer'),
            looksGrid: document.getElementById('looksGrid'),
            posesContainer: document.getElementById('posesContainer'),
            generateBtn: document.getElementById('generateBtn'),
            calcDisplay: document.getElementById('calc-display'),
            costValue: document.getElementById('cost-value'),
            resolutionButtons: document.getElementById('resolution-buttons'),
            progressSection: document.getElementById('progress-section'),
            progressCount: document.getElementById('progress-count'),
            progressBar: document.getElementById('progress-bar'),
            resultsSection: document.getElementById('results-section'),
            resultsGrid: document.getElementById('results-grid'),
            errorDiv: document.getElementById('error'),
            lightbox: document.getElementById('lightbox'),
            lightboxImage: document.getElementById('lightbox-image'),
            lightboxLook: document.getElementById('lightbox-look'),
            lightboxPose: document.getElementById('lightbox-pose'),
            lightboxPrompt: document.getElementById('lightbox-prompt'),
            lightboxSourceImages: document.getElementById('lightbox-source-images'),
            loading: document.getElementById('loading'),
            loadingText: document.getElementById('loading-text'),
            analyzeAllBtn: document.getElementById('analyzeAllBtn'),
            analyzeProgress: document.getElementById('analyzeProgress'),
            analyzeProgressFill: document.getElementById('analyzeProgressFill'),
            analyzeProgressText: document.getElementById('analyzeProgressText')
        };

        // Initialize poses grid
        function initializePoses() {
            const pdpPoses = POSES.filter(p => p.category === 'pdp' || p.category === 'detail');
            const lifestylePoses = POSES.filter(p => p.category === 'lifestyle');

            const pdpHtml = `
                <div class="pose-category">
                    <div class="pose-category-title">PDP / E-Commerce</div>
                    <div class="poses-grid">
                        ${pdpPoses.map(pose => createPoseCard(pose)).join('')}
                    </div>
                </div>
            `;

            const lifestyleHtml = `
                <div class="pose-category">
                    <div class="pose-category-title">Lifestyle / Editorial</div>
                    <div class="poses-grid">
                        ${lifestylePoses.map(pose => createPoseCard(pose)).join('')}
                    </div>
                </div>
            `;

            elements.posesContainer.innerHTML = pdpHtml + lifestyleHtml;

            // Build pose lookup map
            const poseMap = {};
            POSES.forEach(p => poseMap[p.id] = p);

            // Add slider handlers
            elements.posesContainer.querySelectorAll('.pose-slider').forEach(slider => {
                slider.addEventListener('input', (e) => {
                    const poseId = e.target.dataset.pose;
                    const count = parseInt(e.target.value);
                    updatePoseCount(poseId, count);
                });
            });

            // Add hover/click handlers
            elements.posesContainer.querySelectorAll('.pose-card-image').forEach(imageContainer => {
                const card = imageContainer.closest('.pose-card');
                const poseId = card.dataset.id;
                const pose = poseMap[poseId];
                const img = imageContainer.querySelector('img');

                if (pose && pose.hoverImage) {
                    imageContainer.addEventListener('mouseenter', () => img.src = pose.hoverImage);
                    imageContainer.addEventListener('mouseleave', () => img.src = pose.defaultImage);
                }

                imageContainer.addEventListener('click', () => {
                    const currentCount = state.poseCounts[poseId] || 0;
                    const newCount = currentCount > 0 ? 0 : 1;
                    card.querySelector('.pose-slider').value = newCount;
                    updatePoseCount(poseId, newCount);
                });
            });
        }

        function createPoseCard(pose) {
            state.poseCounts[pose.id] = 0;
            return `
                <div class="pose-card" data-id="${pose.id}">
                    <div class="pose-card-image">
                        <img src="${pose.defaultImage}" alt="${pose.name}">
                        <span class="pose-count" data-count="${pose.id}">0</span>
                    </div>
                    <div class="pose-name">${pose.name}</div>
                    <div class="pose-slider-row">
                        <input type="range" class="pose-slider" data-pose="${pose.id}" min="0" max="4" value="0">
                    </div>
                </div>
            `;
        }

        function updatePoseCount(poseId, count) {
            state.poseCounts[poseId] = count;
            const card = elements.posesContainer.querySelector(`[data-id="${poseId}"]`);
            const countBadge = card.querySelector(`[data-count="${poseId}"]`);
            countBadge.textContent = count;
            card.classList.toggle('active', count > 0);
            updateCalculator();
        }

        // Model upload
        elements.modelPreview.addEventListener('click', () => elements.modelInput.click());
        elements.modelInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) handleModelUpload(e.target.files[0], 'fullbody');
        });

        elements.modelPreviewPortrait.addEventListener('click', () => elements.modelInputPortrait.click());
        elements.modelInputPortrait.addEventListener('change', (e) => {
            if (e.target.files.length > 0) handleModelUpload(e.target.files[0], 'portrait');
        });

        function handleModelUpload(file, type = 'fullbody') {
            const reader = new FileReader();
            reader.onload = (e) => {
                if (type === 'fullbody') {
                    state.modelImage = { file, url: e.target.result };
                    elements.modelPreview.innerHTML = `<img src="${e.target.result}" alt="Model">`;
                    elements.modelPreview.classList.add('has-image');
                } else {
                    state.modelImagePortrait = { file, url: e.target.result };
                    elements.modelPreviewPortrait.innerHTML = `<img src="${e.target.result}" alt="Portrait">`;
                    elements.modelPreviewPortrait.classList.add('has-image');
                }
                updateCalculator();
            };
            reader.readAsDataURL(file);
        }

        // Folder drop zone
        elements.folderDropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            elements.folderDropZone.classList.add('drag-over');
        });

        elements.folderDropZone.addEventListener('dragleave', () => {
            elements.folderDropZone.classList.remove('drag-over');
        });

        elements.folderDropZone.addEventListener('drop', async (e) => {
            e.preventDefault();
            elements.folderDropZone.classList.remove('drag-over');

            const items = e.dataTransfer.items;
            state.looks = [];

            // Show loading state
            elements.dropPlaceholder.style.display = 'none';
            document.getElementById('dropLoading').style.display = 'flex';
            startStudioMessages(document.getElementById('drop-studio-message'));

            console.log('ðŸ“ Processing dropped folder...');

            for (const item of items) {
                if (item.webkitGetAsEntry) {
                    const entry = item.webkitGetAsEntry();
                    if (entry && entry.isDirectory) {
                        await processRootFolder(entry);
                    }
                }
            }

            // Hide loading state
            stopStudioMessages();
            document.getElementById('dropLoading').style.display = 'none';

            if (state.looks.length > 0) {
                console.log(`âœ… Found ${state.looks.length} looks`);
                renderLooksGrid();
                elements.looksContainer.style.display = 'block';
                elements.folderDropZone.classList.add('has-looks');
                updateBatchInfo();
                updateCalculator();

                // Show model section and update step numbers
                document.getElementById('modelSection').style.display = 'block';
                document.getElementById('folderStepNumber').textContent = '2';

                // If model images were discovered, switch to Discovered tab
                if (state.modelImages.length > 0) {
                    renderModelDiscovered();
                    // Switch to Discovered tab
                    document.querySelectorAll('.model-tab').forEach(t => t.classList.remove('active'));
                    document.querySelector('.model-tab[data-tab="discovered"]').classList.add('active');
                    document.getElementById('tabDiscovered').style.display = 'block';
                    document.getElementById('tabUpload').style.display = 'none';
                    document.getElementById('tabSetset').style.display = 'none';
                }
            } else {
                elements.dropPlaceholder.style.display = 'flex';
                showError('No valid product folders found. Expected folders with Hero_Product and Looks subfolders.');
            }
        });

        // Helper to read ALL entries from a directory (readEntries may return partial results)
        async function readAllEntries(reader) {
            const allEntries = [];
            let entries;
            do {
                entries = await new Promise(resolve => reader.readEntries(resolve));
                allEntries.push(...entries);
            } while (entries.length > 0);
            return allEntries;
        }

        async function processRootFolder(rootEntry) {
            console.log('ðŸ“‚ Processing folder:', rootEntry.name);
            const reader = rootEntry.createReader();
            const entries = await readAllEntries(reader);
            console.log(`ðŸ“‚ Found ${entries.length} entries`);

            // Check if THIS folder is a product folder (has Hero_Product or Looks directly)
            const hasHeroDirectly = entries.some(e => e.isDirectory && e.name.toLowerCase().includes('hero'));
            const hasLooksDirectly = entries.some(e => e.isDirectory && e.name.toLowerCase().includes('look'));

            if (hasHeroDirectly || hasLooksDirectly) {
                // This IS a product folder - process it directly
                console.log('ðŸ“¦ This folder is a product folder itself');
                await processProductFolder(rootEntry, entries);
            } else {
                // This is a parent folder - look for product subfolders
                console.log('ðŸ“‚ Looking for product subfolders...');
                for (const entry of entries) {
                    if (entry.isDirectory) {
                        const name = entry.name;
                        console.log(`  ðŸ“ Checking folder: ${name}`);

                        // Check for model/twin folder
                        if (name.toLowerCase().includes('twin') || name.toLowerCase().includes('model')) {
                            console.log(`  ðŸ‘¤ Found model folder: ${name}`);
                            await processModelFolder(entry);
                            continue;
                        }

                        // Skip hidden folders
                        if (name.startsWith('.')) {
                            console.log(`    â­ï¸ Skipping: ${name}`);
                            continue;
                        }

                        // Check if this folder has Hero_Product or Looks subfolders
                        const subReader = entry.createReader();
                        const subEntries = await readAllEntries(subReader);
                        console.log(`    ðŸ“ Found ${subEntries.length} subfolders in ${name}`);

                        const hasHero = subEntries.some(e => e.isDirectory && e.name.toLowerCase().includes('hero'));
                        const hasLooks = subEntries.some(e => e.isDirectory && e.name.toLowerCase().includes('look'));
                        console.log(`    ðŸ” hasHero: ${hasHero}, hasLooks: ${hasLooks}`);

                        if (hasHero || hasLooks) {
                            await processProductFolder(entry, subEntries);
                        }
                    }
                }
            }
        }

        async function processModelFolder(folderEntry) {
            const images = await getImagesFromFolder(folderEntry);
            if (images.length > 0) {
                state.modelImages = images;
                console.log(`ðŸ‘¤ Loaded ${images.length} model images`);
                renderModelDiscovered();
            }
        }

        function renderModelDiscovered() {
            const grid = document.getElementById('modelDiscoveredGrid');

            if (state.modelImages.length === 0) {
                grid.innerHTML = '';
                document.getElementById('modelEmptyMessage').style.display = 'block';
                return;
            }

            document.getElementById('modelEmptyMessage').style.display = 'none';
            grid.innerHTML = state.modelImages.map((img, idx) => `
                <div class="model-thumb ${img.selected ? 'selected' : ''}" onclick="toggleModelImage(${idx})">
                    <img src="${img.thumbnail}" alt="${img.name}">
                    <span class="check-mark">âœ“</span>
                </div>
            `).join('');
        }

        window.toggleModelImage = function(idx) {
            const img = state.modelImages[idx];
            if (img) {
                img.selected = !img.selected;
                renderModelDiscovered();
                updateCalculator();
            }
        };

        async function processProductFolder(folderEntry, entries) {
            const name = folderEntry.name;
            const displayName = name.replace('SetSet_SMC_', '').replace(/_/g, ' ');

            const look = {
                id: `look-${state.looks.length}`,
                name: displayName,
                selected: false,
                customPrompt: '',
                heroImages: [],
                looksImages: []
            };

            for (const subEntry of entries) {
                if (subEntry.isDirectory) {
                    const subName = subEntry.name.toLowerCase();
                    if (subName.includes('hero')) {
                        look.heroImages = await getImagesFromFolder(subEntry);
                        console.log(`      âœ… Hero images: ${look.heroImages.length}`);
                    } else if (subName.includes('look')) {
                        look.looksImages = await getImagesFromFolder(subEntry);
                        console.log(`      âœ… Looks images: ${look.looksImages.length}`);
                    }
                }
            }

            if (look.heroImages.length > 0 || look.looksImages.length > 0) {
                state.looks.push(look);
                console.log(`ðŸ“¦ Found look: ${look.name} (${look.heroImages.length} hero, ${look.looksImages.length} looks)`);
            }
        }

        async function getImagesFromFolder(folderEntry) {
            const images = [];
            const reader = folderEntry.createReader();
            const entries = await readAllEntries(reader);

            for (const entry of entries) {
                if (entry.isFile && /\.(jpg|jpeg|png|webp)$/i.test(entry.name)) {
                    const file = await new Promise(resolve => entry.file(resolve));

                    // Create thumbnail (800px) - good quality for preview and hover zoom
                    const thumbnail = await createThumbnail(file, 800);

                    // Store file reference for later upload, but use thumbnail for display
                    images.push({
                        file,
                        thumbnail,  // Small preview
                        url: null,  // Will be loaded on-demand when generating
                        name: entry.name,
                        selectionType: 'none'  // 'none', 'front', or 'back'
                    });
                }
            }

            return images;
        }

        // Convert file to data URL
        function fileToDataUrl(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.readAsDataURL(file);
            });
        }

        // Create a small thumbnail from a file
        function createThumbnail(file, maxSize) {
            return new Promise((resolve) => {
                const img = new Image();
                const url = URL.createObjectURL(file);

                img.onload = () => {
                    // Calculate thumbnail dimensions
                    let width = img.width;
                    let height = img.height;

                    if (width > height) {
                        if (width > maxSize) {
                            height = (height * maxSize) / width;
                            width = maxSize;
                        }
                    } else {
                        if (height > maxSize) {
                            width = (width * maxSize) / height;
                            height = maxSize;
                        }
                    }

                    // Draw to canvas
                    const canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);

                    // Get data URL with good quality
                    const thumbnailUrl = canvas.toDataURL('image/jpeg', 0.85);

                    // Clean up object URL
                    URL.revokeObjectURL(url);

                    resolve(thumbnailUrl);
                };

                img.src = url;
            });
        }

        function renderLooksGrid() {
            // Save scroll positions before re-render
            const scrollPositions = {};
            document.querySelectorAll('.look-card-images').forEach(el => {
                const lookId = el.closest('.look-card')?.dataset.lookId;
                if (lookId) scrollPositions[lookId] = el.scrollTop;
            });

            elements.looksGrid.innerHTML = state.looks.map(look => {
                const allImages = [...look.heroImages, ...look.looksImages];
                const selectedCount = allImages.filter(i => i.selectionType && i.selectionType !== 'none').length;
                const columns = look.columns || 5;

                return `
                    <div class="look-card ${look.selected ? 'selected' : ''}" data-look-id="${look.id}">
                        <div class="look-card-header" onclick="toggleLook('${look.id}')">
                            <input type="checkbox" class="look-checkbox" ${look.selected ? 'checked' : ''} onclick="event.stopPropagation(); toggleLook('${look.id}')">
                            <span class="look-name">${look.name}</span>
                            <span class="look-count">${selectedCount}/${allImages.length}</span>
                            <div class="look-columns" onclick="event.stopPropagation()">
                                <input type="range" class="look-columns-slider" min="2" max="6" value="${columns}"
                                    oninput="updateLookColumns('${look.id}', this.value)">
                                <span class="look-columns-value">${columns}</span>
                            </div>
                        </div>
                        <div class="look-card-images" style="grid-template-columns: repeat(${columns}, 1fr)">
                            ${allImages.map((img, idx) => {
                                const selType = img.selectionType || 'none';
                                return `
                                    <div class="look-image-thumb ${selType !== 'none' ? selType : ''}" onclick="toggleImage('${look.id}', ${idx})">
                                        <img src="${img.thumbnail}" alt="${img.name}" loading="lazy">
                                        <span class="check-mark">âœ“</span>
                                        ${selType !== 'none' ? `<span class="selection-label">${selType.toUpperCase()}</span>` : ''}
                                    </div>
                                `;
                            }).join('')}
                        </div>
                        <div class="look-card-footer">
                            ${look.analysis ? `<div class="look-analysis">${look.analysis}</div>` : ''}
                            <input type="text"
                                placeholder="Additional instructions"
                                value="${look.customPrompt || ''}"
                                onchange="updateLookPrompt('${look.id}', this.value)"
                                onclick="event.stopPropagation()">
                        </div>
                    </div>
                `;
            }).join('');

            // Restore scroll positions after re-render
            requestAnimationFrame(() => {
                document.querySelectorAll('.look-card-images').forEach(el => {
                    const lookId = el.closest('.look-card')?.dataset.lookId;
                    if (lookId && scrollPositions[lookId]) {
                        el.scrollTop = scrollPositions[lookId];
                    }
                });

                // Add pan-on-hover to all image thumbs
                initImageZoom();
            });
        }

        // Pan-on-hover zoom effect
        function initImageZoom() {
            document.querySelectorAll('.look-image-thumb').forEach(thumb => {
                const img = thumb.querySelector('img');
                if (!img) return;

                thumb.addEventListener('mouseenter', () => {
                    img.style.transform = 'scale(2.5)';
                });

                thumb.addEventListener('mousemove', (e) => {
                    const rect = thumb.getBoundingClientRect();
                    const x = (e.clientX - rect.left) / rect.width;
                    const y = (e.clientY - rect.top) / rect.height;

                    // Calculate transform origin based on mouse position
                    img.style.transformOrigin = `${x * 100}% ${y * 100}%`;
                });

                thumb.addEventListener('mouseleave', () => {
                    img.style.transform = 'scale(1)';
                    img.style.transformOrigin = 'center center';
                });
            });
        }

        window.toggleLook = function(lookId) {
            const look = state.looks.find(l => l.id === lookId);
            if (look) {
                look.selected = !look.selected;
                const card = document.querySelector(`[data-look-id="${lookId}"]`);
                card.classList.toggle('selected', look.selected);
                card.querySelector('.look-checkbox').checked = look.selected;
                updateBatchInfo();
                updateCalculator();
            }
        };

        window.toggleImage = function(lookId, imageIndex) {
            const look = state.looks.find(l => l.id === lookId);
            if (look) {
                const allImages = [...look.heroImages, ...look.looksImages];
                if (allImages[imageIndex]) {
                    // Cycle: none â†’ front â†’ back â†’ all â†’ none
                    const current = allImages[imageIndex].selectionType || 'none';
                    if (current === 'none') {
                        allImages[imageIndex].selectionType = 'front';
                    } else if (current === 'front') {
                        allImages[imageIndex].selectionType = 'back';
                    } else if (current === 'back') {
                        allImages[imageIndex].selectionType = 'all';
                    } else {
                        allImages[imageIndex].selectionType = 'none';
                    }
                    renderLooksGrid();
                    updateBatchInfo();
                    updateCalculator();
                }
            }
        };

        window.updateLookPrompt = function(lookId, value) {
            const look = state.looks.find(l => l.id === lookId);
            if (look) {
                look.customPrompt = value;
            }
        };

        window.updateLookColumns = function(lookId, value) {
            const look = state.looks.find(l => l.id === lookId);
            if (look) {
                look.columns = parseInt(value);
                // Update the grid and value display without full re-render
                const card = document.querySelector(`.look-card[data-look-id="${lookId}"]`);
                if (card) {
                    const grid = card.querySelector('.look-card-images');
                    const valueDisplay = card.querySelector('.look-columns-value');
                    if (grid) grid.style.gridTemplateColumns = `repeat(${value}, 1fr)`;
                    if (valueDisplay) valueDisplay.textContent = value;
                }
            }
        };

        window.selectAllLooks = function() {
            state.looks.forEach(l => l.selected = true);
            renderLooksGrid();
            updateBatchInfo();
            updateCalculator();
        };

        window.deselectAllLooks = function() {
            state.looks.forEach(l => l.selected = false);
            renderLooksGrid();
            updateBatchInfo();
            updateCalculator();
        };

        // Analyze a look's selected images
        window.analyzeLook = async function(lookId) {
            const look = state.looks.find(l => l.id === lookId);
            if (!look) return;

            const allImages = [...look.heroImages, ...look.looksImages];
            const selectedImages = allImages.filter(i => i.selectionType && i.selectionType !== 'none');

            if (selectedImages.length === 0) return;

            look.analyzing = true;
            renderLooksGrid();

            console.log(`ðŸ” Analyzing ${selectedImages.length} images for ${look.name}...`);

            try {
                // Upload all selected images first
                const imageUrls = [];
                for (const img of selectedImages) {
                    const dataUrl = await fileToDataUrl(img.file);
                    const result = await api.uploadBase64(dataUrl);
                    imageUrls.push(result.url);
                }

                // Analyze all images together for a cohesive description
                const analysisPrompt = `You are analyzing product images for a fashion photo shoot. Describe ONLY the actual products/garments being sold across these ${imageUrls.length} images.

IMPORTANT: IGNORE any mannequins, hangers, display props, styling accessories (like hats or glasses on mannequins), or items that are clearly not part of the product being sold.

For each distinct PRODUCT, briefly note:
- What it is (jacket, pants, shoes, bag, etc.)
- Key visual details (color, material, style)

Format as a flowing description that could be used in a prompt, like:
"Navy wool overcoat with peak lapels, black slim-fit trousers, brown leather Chelsea boots"

Keep it under 100 words total. Focus on the actual products only.`;

                // Send ALL images for analysis
                const analysisResult = await fetch('/api/analyze', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        images: imageUrls, // Send all images
                        prompt: analysisPrompt
                    })
                });

                const analysisData = await analysisResult.json();

                if (analysisData.content) {
                    look.analysis = analysisData.content;
                    console.log(`âœ… Analysis for ${look.name}: ${look.analysis.substring(0, 80)}...`);
                } else {
                    look.analysis = `${look.name} - ${selectedImages.length} items`;
                }
            } catch (err) {
                console.error(`âŒ Analysis failed for ${look.name}:`, err);
                look.analysis = `${look.name} products`;
            }

            look.analyzing = false;
            renderLooksGrid();
        };

        // Analyze all selected products
        elements.analyzeAllBtn.addEventListener('click', analyzeAllProducts);

        let analyzeMessageInterval = null;

        function startAnalyzeMessages() {
            const loaderText = document.getElementById('analyzeLoaderText');
            if (!loaderText) return;

            let lastIndex = -1;

            const updateMessage = () => {
                let idx;
                do {
                    idx = Math.floor(Math.random() * STUDIO_MESSAGES.length);
                } while (idx === lastIndex && STUDIO_MESSAGES.length > 1);
                lastIndex = idx;
                loaderText.textContent = STUDIO_MESSAGES[idx];
            };

            // Initial message
            updateMessage();
            analyzeMessageInterval = setInterval(updateMessage, 2000);
        }

        function stopAnalyzeMessages() {
            if (analyzeMessageInterval) {
                clearInterval(analyzeMessageInterval);
                analyzeMessageInterval = null;
            }
        }

        async function analyzeAllProducts() {
            const selectedLooks = state.looks.filter(l => l.selected);
            const looksWithImages = selectedLooks.filter(look => {
                const allImages = [...look.heroImages, ...look.looksImages];
                return allImages.some(i => i.selectionType && i.selectionType !== 'none');
            });

            if (looksWithImages.length === 0) return;

            const total = looksWithImages.length;
            let completed = 0;

            // Show loader state and progress bar
            elements.analyzeAllBtn.disabled = true;
            elements.analyzeAllBtn.classList.add('analyzing');
            elements.analyzeProgress.style.display = 'block';
            elements.analyzeProgressFill.style.width = '0%';
            elements.analyzeProgressText.textContent = `Analyzing 0 / ${total}`;

            console.log(`ðŸ” Analyzing ${total} products in parallel...`);

            // Run all analyses in parallel with progress tracking
            await Promise.all(looksWithImages.map(async (look) => {
                await analyzeLook(look.id);
                completed++;
                const percent = (completed / total) * 100;
                elements.analyzeProgressFill.style.width = `${percent}%`;
                elements.analyzeProgressText.textContent = `Analyzing ${completed} / ${total}`;
            }));

            // Reset button and hide progress
            elements.analyzeAllBtn.classList.remove('analyzing');
            elements.analyzeAllBtn.disabled = false;
            elements.analyzeProgress.style.display = 'none';
            console.log('âœ… All products analyzed');
        }

        function updateBatchInfo() {
            const totalLooks = state.looks.length;
            const selectedLooks = state.looks.filter(l => l.selected).length;
            const totalImages = state.looks.reduce((sum, l) => {
                if (!l.selected) return sum;
                const heroCount = l.heroImages.filter(i => i.selectionType && i.selectionType !== 'none').length;
                const looksCount = l.looksImages.filter(i => i.selectionType && i.selectionType !== 'none').length;
                return sum + heroCount + looksCount;
            }, 0);

            document.getElementById('lookCountDisplay').textContent = totalLooks;
            document.getElementById('selectedCountDisplay').textContent = selectedLooks;
            document.getElementById('imageCountDisplay').textContent = totalImages;
        }

        // Aspect ratio buttons
        document.getElementById('aspect-buttons').addEventListener('click', (e) => {
            if (e.target.classList.contains('btn--toggle')) {
                document.getElementById('aspect-buttons').querySelectorAll('.btn--toggle').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                state.aspectRatio = e.target.dataset.value;
            }
        });

        // Model buttons
        document.getElementById('model-buttons').addEventListener('click', (e) => {
            if (e.target.classList.contains('btn--toggle')) {
                document.getElementById('model-buttons').querySelectorAll('.btn--toggle').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                state.selectedModel = e.target.dataset.value;
            }
        });

        // Lighting buttons
        document.getElementById('lighting-buttons').addEventListener('click', (e) => {
            if (e.target.classList.contains('btn--toggle')) {
                document.getElementById('lighting-buttons').querySelectorAll('.btn--toggle').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                state.selectedLighting = e.target.dataset.value;
                console.log('ðŸ”¦ Lighting preset:', state.selectedLighting, LIGHTING_PRESETS[state.selectedLighting]?.name);
            }
        });

        // Resolution buttons
        elements.resolutionButtons.addEventListener('click', (e) => {
            if (e.target.classList.contains('btn--toggle')) {
                elements.resolutionButtons.querySelectorAll('.btn--toggle').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                state.resolution = e.target.dataset.value;
                updateCalculator();
            }
        });

        // Calculator
        function updateCalculator() {
            const hasModel = state.modelImage !== null || state.modelImages.some(m => m.selected) || state.setsetModels.length > 0;
            const selectedLooks = state.looks.filter(l => l.selected);
            const totalPoses = Object.values(state.poseCounts).reduce((sum, count) => sum + count, 0);

            // Count total selected product images
            const totalSelectedImages = selectedLooks.reduce((sum, look) => {
                const heroCount = look.heroImages.filter(i => i.selectionType && i.selectionType !== 'none').length;
                const looksCount = look.looksImages.filter(i => i.selectionType && i.selectionType !== 'none').length;
                return sum + heroCount + looksCount;
            }, 0);

            // Total generated images = looks Ã— poses
            const totalImages = selectedLooks.length * totalPoses;

            // Cost: $0.15 per image, 2K = double
            let costPerImage = 0.15;
            if (state.resolution === '2K') costPerImage *= 2;
            const totalCost = totalImages * costPerImage;

            // Build display
            if (totalImages > 0) {
                elements.calcDisplay.textContent = `${selectedLooks.length} looks Ã— ${totalPoses} poses = ${totalImages} images`;
            } else {
                elements.calcDisplay.textContent = 'Drop folder and select poses to generate';
            }
            elements.costValue.textContent = formatCost(totalCost);

            // Enable analyze button if there are selected product images
            elements.analyzeAllBtn.disabled = totalSelectedImages === 0;

            // Enable generate button
            elements.generateBtn.disabled = !hasModel || totalImages === 0;
        }

        // Generate
        elements.generateBtn.addEventListener('click', generateImages);

        async function generateImages() {
            const selectedLooks = state.looks.filter(l => l.selected);
            const totalPoses = Object.values(state.poseCounts).reduce((sum, count) => sum + count, 0);
            const selectedModelImages = state.modelImages.filter(m => m.selected);
            const hasModel = state.modelImage !== null || selectedModelImages.length > 0 || state.setsetModels.length > 0;

            if (!hasModel || selectedLooks.length === 0 || totalPoses === 0) return;

            console.log('ðŸš€ Starting batch generation...');
            console.log(`ðŸ“Š ${selectedLooks.length} looks Ã— ${totalPoses} poses`);

            elements.errorDiv.classList.remove('show');
            state.results = [];
            elements.resultsGrid.innerHTML = '';

            // Build tasks: each look Ã— each pose Ã— pose count
            const tasks = [];

            for (const look of selectedLooks) {
                // Front poses get: front + all images
                const frontImages = [
                    ...look.heroImages.filter(i => i.selectionType === 'front' || i.selectionType === 'all'),
                    ...look.looksImages.filter(i => i.selectionType === 'front' || i.selectionType === 'all')
                ];
                // Back pose gets: back + all images
                const backImages = [
                    ...look.heroImages.filter(i => i.selectionType === 'back' || i.selectionType === 'all'),
                    ...look.looksImages.filter(i => i.selectionType === 'back' || i.selectionType === 'all')
                ];

                if (frontImages.length === 0 && backImages.length === 0) continue;

                for (const [poseId, count] of Object.entries(state.poseCounts)) {
                    if (count === 0) continue;

                    const pose = POSES.find(p => p.id === poseId);
                    const prompts = POSE_PROMPTS[poseId] || POSE_PROMPTS['pose-pdp-front'] || [];
                    const productView = pose?.productView || 'front';

                    for (let i = 0; i < count; i++) {
                        const promptTemplate = prompts[Math.floor(Math.random() * prompts.length)];

                        tasks.push({
                            lookId: look.id,
                            lookName: look.name,
                            poseId,
                            poseName: pose?.name || poseId,
                            productView,  // 'front' or 'back'
                            promptTemplate,
                            customPrompt: look.customPrompt || '',
                            analysis: look.analysis || null,
                            frontImages,
                            backImages
                        });
                    }
                }
            }

            const totalTasks = tasks.length;
            let completed = 0;

            console.log(`ðŸ“‹ Created ${totalTasks} generation tasks`);

            elements.progressSection.classList.add('visible');
            elements.progressCount.textContent = `0 / ${totalTasks}`;
            elements.progressBar.style.width = '0%';
            elements.generateBtn.disabled = true;
            startStudioMessages(document.getElementById('progress-studio-message'));

            // Upload model images first
            console.log('ðŸ“¤ Uploading model images...');
            elements.loadingText && (elements.loadingText.textContent = 'Uploading model...');
            elements.loading.classList.add('visible');

            const modelUrls = [];
            try {
                // Handle manually uploaded model images (old method)
                if (state.modelImage && state.modelImage.url) {
                    if (state.modelImage.url.startsWith('data:')) {
                        const result = await api.uploadBase64(state.modelImage.url);
                        modelUrls.push(result.url);
                    } else {
                        modelUrls.push(state.modelImage.url);
                    }
                }

                if (state.modelImagePortrait && state.modelImagePortrait.url) {
                    if (state.modelImagePortrait.url.startsWith('data:')) {
                        const result = await api.uploadBase64(state.modelImagePortrait.url);
                        modelUrls.push(result.url);
                    } else {
                        modelUrls.push(state.modelImagePortrait.url);
                    }
                }

                // Handle discovered model images from TWIN folder
                if (selectedModelImages.length > 0) {
                    console.log(`ðŸ“¤ Uploading ${selectedModelImages.length} discovered model images...`);
                    for (const modelImg of selectedModelImages) {
                        // Convert file to data URL, then upload
                        const dataUrl = await fileToDataUrl(modelImg.file);
                        const result = await api.uploadBase64(dataUrl);
                        modelUrls.push(result.url);
                        console.log(`  âœ… Uploaded: ${modelImg.name}`);
                    }
                }

                // Handle Setset internal models
                if (state.setsetModels.length > 0) {
                    console.log(`ðŸ“¤ Using ${state.setsetModels.length} Setset models...`);
                    for (const modelId of state.setsetModels) {
                        const model = SETSET_MODELS.find(m => m.id === modelId);
                        if (model) {
                            // These are local paths, upload them
                            const response = await fetch(model.image);
                            const blob = await response.blob();
                            const dataUrl = await new Promise((resolve) => {
                                const reader = new FileReader();
                                reader.onload = () => resolve(reader.result);
                                reader.readAsDataURL(blob);
                            });
                            const result = await api.uploadBase64(dataUrl);
                            modelUrls.push(result.url);
                            console.log(`  âœ… Added Setset model: ${model.name}`);
                        }
                    }
                }
            } catch (err) {
                console.error('âŒ Model upload failed:', err);
                showError('Failed to upload model images');
                stopStudioMessages();
                elements.loading.classList.remove('visible');
                elements.progressSection.classList.remove('visible');
                elements.generateBtn.disabled = false;
                return;
            }

            elements.loading.classList.remove('visible');
            console.log(`âœ… Model images uploaded: ${modelUrls.length}`);

            // PRE-UPLOAD: Upload front and back images separately per look
            console.log('ðŸ“¤ Pre-uploading product images for all looks...');
            const lookFrontUrls = {}; // { lookId: [urls] }
            const lookBackUrls = {}; // { lookId: [urls] }
            const lookFrontThumbnails = {}; // { lookId: [thumbnails] }
            const lookBackThumbnails = {}; // { lookId: [thumbnails] }

            await Promise.all(selectedLooks.map(async (look) => {
                // Front poses get: front + all images
                const frontImages = [
                    ...look.heroImages.filter(i => i.selectionType === 'front' || i.selectionType === 'all'),
                    ...look.looksImages.filter(i => i.selectionType === 'front' || i.selectionType === 'all')
                ];
                // Back pose gets: back + all images
                const backImages = [
                    ...look.heroImages.filter(i => i.selectionType === 'back' || i.selectionType === 'all'),
                    ...look.looksImages.filter(i => i.selectionType === 'back' || i.selectionType === 'all')
                ];

                if (frontImages.length === 0 && backImages.length === 0) return;

                const allCount = [...look.heroImages, ...look.looksImages].filter(i => i.selectionType === 'all').length;
                console.log(`  ðŸ“¤ Uploading images for ${look.name} (${frontImages.length} for front poses, ${backImages.length} for back pose, ${allCount} shared)...`);

                // Upload front images
                if (frontImages.length > 0) {
                    const frontUrls = await Promise.all(frontImages.map(async (img) => {
                        const fullDataUrl = await fileToDataUrl(img.file);
                        const result = await api.uploadBase64(fullDataUrl);
                        return result.url;
                    }));
                    lookFrontUrls[look.id] = frontUrls;
                    lookFrontThumbnails[look.id] = frontImages.map(i => i.thumbnail);
                }

                // Upload back images
                if (backImages.length > 0) {
                    const backUrls = await Promise.all(backImages.map(async (img) => {
                        const fullDataUrl = await fileToDataUrl(img.file);
                        const result = await api.uploadBase64(fullDataUrl);
                        return result.url;
                    }));
                    lookBackUrls[look.id] = backUrls;
                    lookBackThumbnails[look.id] = backImages.map(i => i.thumbnail);
                }

                console.log(`  âœ… ${look.name}: uploaded`);
            }));

            console.log('âœ… All product images pre-uploaded');

            // Process tasks with true parallel concurrency (rolling queue)
            const CONCURRENCY = 10; // 10 concurrent generation tasks

            async function processTask(task, taskIndex) {
                console.log(`ðŸ”„ [${taskIndex + 1}/${totalTasks}] ${task.lookName} - ${task.poseName} (${task.productView})`);

                try {
                    // Select images based on pose's productView (front or back)
                    // Fall back to front images if no back images available
                    let productUrls, thumbnails;
                    if (task.productView === 'back') {
                        const backUrls = lookBackUrls[task.lookId] || [];
                        const backThumbs = lookBackThumbnails[task.lookId] || [];
                        if (backUrls.length > 0) {
                            productUrls = backUrls;
                            thumbnails = backThumbs;
                            console.log(`  ðŸ“· Using ${backUrls.length} BACK images`);
                        } else {
                            // Fallback to front images
                            productUrls = lookFrontUrls[task.lookId] || [];
                            thumbnails = lookFrontThumbnails[task.lookId] || [];
                            console.log(`  ðŸ“· No back images, falling back to ${productUrls.length} front images`);
                        }
                    } else {
                        productUrls = lookFrontUrls[task.lookId] || [];
                        thumbnails = lookFrontThumbnails[task.lookId] || [];
                        console.log(`  ðŸ“· Using ${productUrls.length} FRONT images`);
                    }

                    // Get product description (use cached analysis or analyze now)
                    let productDescription = task.lookName;
                    if (task.analysis) {
                        productDescription = task.analysis;
                        console.log(`  ðŸ“‹ Using cached analysis`);
                    } else if (productUrls.length > 0) {
                        console.log(`  ðŸ” Analyzing...`);
                        try {
                            const analysisPrompt = `Describe ALL the fashion products shown across these ${productUrls.length} images. For each distinct product, note what it is and key visual details (color, material, style). Ignore mannequins, hangers, or display props. Format as a flowing description. Keep it under 100 words total.`;
                            const analysisResult = await fetch('/api/analyze', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ images: productUrls, prompt: analysisPrompt })
                            });
                            const analysisData = await analysisResult.json();
                            if (analysisData.content) {
                                productDescription = analysisData.content;
                            }
                        } catch (err) {
                            console.log(`  âš ï¸ Analysis failed`);
                        }
                    }

                    // Build final prompt
                    const lightingPreset = LIGHTING_PRESETS[state.selectedLighting] || LIGHTING_PRESETS['default'];
                    let finalPrompt = task.promptTemplate
                        .replace('[PRODUCT_DESCRIPTION]', productDescription)
                        .replace('[LIGHTING]', lightingPreset.lighting);
                    if (task.customPrompt) {
                        finalPrompt += `. ${task.customPrompt}`;
                    }

                    // Generate image
                    const imageUrls = [...modelUrls, ...productUrls];
                    const params = {
                        prompt: finalPrompt,
                        image_urls: imageUrls,
                        num_images: 1,
                        aspect_ratio: state.aspectRatio,
                        resolution: state.resolution,
                        output_format: 'png'
                    };

                    const data = await api.remixImage(state.selectedModel, params);

                    if (data.images && data.images.length > 0) {
                        data.images.forEach(img => {
                            state.results.push({
                                url: img.url,
                                prompt: finalPrompt,
                                lookName: task.lookName,
                                poseName: task.poseName,
                                aspectRatio: state.aspectRatio,
                                sourceImages: productUrls,
                                sourceThumbnails: thumbnails
                            });
                        });
                        renderResults();
                        console.log(`  âœ… Done`);
                    }

                    return { success: true, taskIndex };
                } catch (error) {
                    console.error(`âŒ [${task.lookName}] Error:`, error);
                    return { success: false, taskIndex, error };
                }
            }

            // Rolling concurrent queue - starts new task as soon as one finishes
            const runConcurrent = async (tasks, concurrency) => {
                let index = 0;
                const results = [];

                const runNext = async () => {
                    if (index >= tasks.length) return;
                    const currentIndex = index++;
                    const result = await processTask(tasks[currentIndex], currentIndex);
                    results.push(result);

                    // Update progress
                    completed++;
                    elements.progressCount.textContent = `${completed} / ${totalTasks}`;
                    elements.progressBar.style.width = `${(completed / totalTasks) * 100}%`;

                    // Start next task immediately
                    await runNext();
                };

                // Start initial batch of concurrent tasks
                const workers = Array(Math.min(concurrency, tasks.length))
                    .fill(null)
                    .map(() => runNext());

                await Promise.all(workers);
                return results;
            };

            await runConcurrent(tasks, CONCURRENCY);

            console.log('ðŸ Batch complete. Total results:', state.results.length);
            stopStudioMessages();
            elements.progressSection.classList.remove('visible');
            elements.resultsSection.classList.add('visible');
            updateCalculator();
        }

        function renderResults() {
            const getAspectCSS = (ar) => {
                if (ar === '3:4') return '3/4';
                if (ar === '4:3') return '4/3';
                if (ar === '1:1') return '1/1';
                return '3/4';
            };

            elements.resultsGrid.innerHTML = state.results.map((result, idx) => `
                <div class="result-card" onclick="openLightbox(${idx})" style="aspect-ratio: ${getAspectCSS(result.aspectRatio || '3:4')};">
                    <img src="${result.url}" alt="Result ${idx + 1}">
                    <span class="result-tag">${result.lookName} - ${result.poseName}</span>
                </div>
            `).join('');
        }

        // Lightbox state
        let lightboxRemixModel = 'nano';
        let lightboxLoaderInterval = null;

        window.openLightbox = function(index) {
            state.lightboxIndex = index;
            updateLightboxContent();
            elements.lightbox.classList.add('visible');
            document.body.style.overflow = 'hidden';
            // Clear edit input when opening
            document.getElementById('lightbox-edit-input').value = '';
        };

        function updateLightboxContent() {
            const result = state.results[state.lightboxIndex];
            const total = state.results.length;
            const current = state.lightboxIndex + 1;

            elements.lightboxImage.src = result.url;
            elements.lightboxLook.textContent = result.lookName;
            elements.lightboxPose.textContent = result.poseName;
            elements.lightboxPrompt.textContent = result.prompt;
            document.getElementById('lightbox-counter').textContent = `${current} / ${total}`;

            // Display source images using thumbnails for faster loading
            if (result.sourceThumbnails && result.sourceThumbnails.length > 0) {
                elements.lightboxSourceImages.innerHTML = result.sourceThumbnails.map(thumb =>
                    `<img src="${thumb}" alt="Source">`
                ).join('');
            } else if (result.sourceImages && result.sourceImages.length > 0) {
                // Fallback to full URLs if no thumbnails
                elements.lightboxSourceImages.innerHTML = result.sourceImages.map(url =>
                    `<img src="${url}" alt="Source">`
                ).join('');
            } else {
                elements.lightboxSourceImages.innerHTML = '<span style="color: var(--slate); font-size: var(--text-xs);">No source images</span>';
            }

            // Display history if exists
            const historySection = document.getElementById('lightbox-history-section');
            const historyContainer = document.getElementById('lightbox-history');

            // Initialize selected history index (current = last)
            if (!result.hasOwnProperty('selectedHistoryIndex')) {
                result.selectedHistoryIndex = -1; // -1 means current image
            }

            if (result.history && result.history.length > 0) {
                historySection.style.display = 'block';
                const historyHtml = result.history.map((histItem, idx) =>
                    `<div class="lightbox-history-item ${result.selectedHistoryIndex === idx ? 'selected' : ''}"
                         onclick="selectHistoryItem(${idx})" title="Version ${idx + 1}">
                        <img src="${histItem.url}" alt="Version ${idx + 1}">
                    </div>`
                ).join('');
                const currentHtml = `<div class="lightbox-history-item ${result.selectedHistoryIndex === -1 ? 'selected' : ''}"
                     onclick="selectHistoryItem(-1)" title="Current">
                    <img src="${result.url}" alt="Current">
                </div>`;
                historyContainer.innerHTML = historyHtml + currentHtml;
            } else {
                historySection.style.display = 'none';
            }

            document.getElementById('lightbox-prev').disabled = state.lightboxIndex === 0;
            document.getElementById('lightbox-next').disabled = state.lightboxIndex === total - 1;
        }

        // Toggle prompt section collapse
        window.togglePromptSection = function() {
            const section = document.getElementById('lightbox-prompt-section');
            section.classList.toggle('collapsed');
        };

        // Set lightbox remix model
        window.setLightboxModel = function(model) {
            lightboxRemixModel = model;
            document.querySelectorAll('.lightbox-model-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.model === model);
            });
        };

        // Select history item (for remixing)
        window.selectHistoryItem = function(historyIndex) {
            const result = state.results[state.lightboxIndex];
            result.selectedHistoryIndex = historyIndex;

            // Update the displayed image
            if (historyIndex === -1) {
                elements.lightboxImage.src = result.url;
            } else if (result.history && result.history[historyIndex]) {
                elements.lightboxImage.src = result.history[historyIndex].url;
            }

            // Update history item styling
            document.querySelectorAll('.lightbox-history-item').forEach((item, idx) => {
                const itemIndex = idx < result.history.length ? idx : -1;
                item.classList.toggle('selected', itemIndex === historyIndex);
            });
        };

        // Start lightbox loader messages
        function startLightboxLoader() {
            const loader = document.getElementById('lightbox-loader');
            const loaderText = document.getElementById('lightbox-loader-text');
            loader.classList.add('visible');

            let lastIndex = -1;
            const updateMessage = () => {
                let idx;
                do {
                    idx = Math.floor(Math.random() * STUDIO_MESSAGES.length);
                } while (idx === lastIndex && STUDIO_MESSAGES.length > 1);
                lastIndex = idx;
                loaderText.textContent = STUDIO_MESSAGES[idx];
            };
            updateMessage();
            lightboxLoaderInterval = setInterval(updateMessage, 2000);
        }

        function stopLightboxLoader() {
            const loader = document.getElementById('lightbox-loader');
            loader.classList.remove('visible');
            if (lightboxLoaderInterval) {
                clearInterval(lightboxLoaderInterval);
                lightboxLoaderInterval = null;
            }
        }

        // Enhance edit prompt for better remix results
        function enhanceEditPrompt(originalPrompt, editRequest) {
            // Build a clear, direct edit instruction
            return `${originalPrompt}. Modify the image: ${editRequest}. Maintain the same person, pose, and overall composition while applying these changes.`;
        }

        // Remix current image
        window.remixCurrentImage = async function() {
            const editInput = document.getElementById('lightbox-edit-input');
            const editPrompt = editInput.value.trim();

            if (!editPrompt) {
                editInput.focus();
                editInput.placeholder = 'Please enter edit instructions...';
                return;
            }

            const result = state.results[state.lightboxIndex];
            const remixBtn = document.getElementById('lightbox-remix-btn');

            // Determine which image to remix (selected history item or current)
            let sourceImageUrl = result.url;
            let sourcePrompt = result.prompt;

            if (result.selectedHistoryIndex !== undefined && result.selectedHistoryIndex !== -1) {
                const histItem = result.history[result.selectedHistoryIndex];
                if (histItem) {
                    sourceImageUrl = histItem.url;
                    sourcePrompt = histItem.prompt;
                }
            }

            // Show loader
            startLightboxLoader();
            remixBtn.disabled = true;
            remixBtn.textContent = 'Remixing...';

            try {
                // Enhance the prompt for better results
                const fullPrompt = enhanceEditPrompt(sourcePrompt, editPrompt);

                // Prepare image URLs - selected image + source product images
                const imageUrls = [sourceImageUrl];
                if (result.sourceImages) {
                    imageUrls.push(...result.sourceImages);
                }

                const params = {
                    prompt: fullPrompt,
                    image_urls: imageUrls,
                    num_images: 1,
                    aspect_ratio: result.aspectRatio || '3:4',
                    output_format: 'png'
                };

                console.log('ðŸ”„ Remixing with model:', lightboxRemixModel);
                console.log('ðŸ“ Edit prompt:', editPrompt);
                console.log('ðŸ“ Enhanced prompt:', fullPrompt);

                const data = await api.remixImage(lightboxRemixModel, params);

                if (data.images && data.images.length > 0) {
                    const newUrl = data.images[0].url;

                    // Save current to history (if not already in history)
                    if (!result.history) {
                        result.history = [];
                    }

                    // Only add to history if it's not already there
                    const existingUrls = result.history.map(h => h.url);
                    if (!existingUrls.includes(result.url)) {
                        result.history.push({
                            url: result.url,
                            prompt: result.prompt
                        });
                    }

                    // Update result with new image
                    result.url = newUrl;
                    result.prompt = fullPrompt;
                    result.selectedHistoryIndex = -1; // Select the new current

                    // Update display
                    elements.lightboxImage.src = newUrl;
                    elements.lightboxPrompt.textContent = fullPrompt;

                    // Update results grid
                    renderResults();

                    // Update history display
                    updateLightboxContent();

                    // Clear edit input
                    editInput.value = '';

                    console.log('âœ… Remix complete');
                }
            } catch (error) {
                console.error('âŒ Remix failed:', error);
                alert('Remix failed: ' + error.message);
            } finally {
                stopLightboxLoader();
                remixBtn.disabled = false;
                remixBtn.textContent = 'Remix';
                editInput.placeholder = "Describe changes... e.g. 'make the jeans baggier' or 'change background to outdoor'";
            }
        };

        document.getElementById('lightbox-close').addEventListener('click', closeLightbox);
        elements.lightbox.addEventListener('click', (e) => { if (e.target === elements.lightbox) closeLightbox(); });

        document.getElementById('lightbox-prev').addEventListener('click', () => {
            if (state.lightboxIndex > 0) {
                state.lightboxIndex--;
                updateLightboxContent();
            }
        });

        document.getElementById('lightbox-next').addEventListener('click', () => {
            if (state.lightboxIndex < state.results.length - 1) {
                state.lightboxIndex++;
                updateLightboxContent();
            }
        });

        document.getElementById('lightbox-download').addEventListener('click', () => {
            const result = state.results[state.lightboxIndex];
            downloadFile(result.url, `lockgroup-${result.lookName}-${result.poseName}-${Date.now()}.png`);
        });

        document.addEventListener('keydown', (e) => {
            if (!elements.lightbox.classList.contains('visible')) return;
            if (e.key === 'Escape') closeLightbox();
            else if (e.key === 'ArrowLeft' && state.lightboxIndex > 0) {
                state.lightboxIndex--;
                updateLightboxContent();
            }
            else if (e.key === 'ArrowRight' && state.lightboxIndex < state.results.length - 1) {
                state.lightboxIndex++;
                updateLightboxContent();
            }
        });

        function closeLightbox() {
            elements.lightbox.classList.remove('visible');
            document.body.style.overflow = '';
        }

        function showError(message) {
            elements.errorDiv.textContent = message;
            elements.errorDiv.classList.add('show');
        }

        // Render Setset models grid
        function renderSetsetModels() {
            const grid = document.getElementById('setsetModelsGrid');
            grid.innerHTML = SETSET_MODELS.map(model => `
                <div class="setset-model-card ${state.setsetModels.includes(model.id) ? 'selected' : ''}"
                     data-model-id="${model.id}" onclick="toggleSetsetModel('${model.id}')">
                    <img src="${model.image}" alt="${model.name}" loading="lazy">
                    <div class="model-name">${model.name}</div>
                    <div class="model-check">âœ“</div>
                </div>
            `).join('');
        }

        // Toggle Setset model selection
        window.toggleSetsetModel = function(modelId) {
            const idx = state.setsetModels.indexOf(modelId);
            if (idx === -1) {
                state.setsetModels.push(modelId);
            } else {
                state.setsetModels.splice(idx, 1);
            }
            renderSetsetModels();
            updateCalculator();
        };

        // Model tab switching
        document.querySelectorAll('.model-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const tabName = tab.dataset.tab;

                // Update active tab
                document.querySelectorAll('.model-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');

                // Show corresponding content
                document.getElementById('tabDiscovered').style.display = tabName === 'discovered' ? 'block' : 'none';
                document.getElementById('tabUpload').style.display = tabName === 'upload' ? 'block' : 'none';
                document.getElementById('tabSetset').style.display = tabName === 'setset' ? 'block' : 'none';
            });
        });

        // Initialize
        initializePoses();
        renderSetsetModels();
        updateCalculator();
    </script>
</body>
</html>
