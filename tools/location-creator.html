<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light">
    <title>Location Creator</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üèõÔ∏è</text></svg>">
    <link rel="stylesheet" href="/shared/css/tokens.css">
    <link rel="stylesheet" href="/shared/css/base.css">
    <link rel="stylesheet" href="/shared/css/components.css">
    <style>
        :root {
            color-scheme: light only;
        }

        .container {
            max-width: 900px;
        }

        .generator-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-md);
            margin-bottom: var(--space-lg);
        }

        .generator-section {
            background: var(--off-white);
            padding: var(--space-md);
            border-radius: var(--radius-md);
        }

        .generator-section.full-width {
            grid-column: 1 / -1;
        }

        .section-title {
            font-size: var(--text-sm);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--carbon);
            margin-bottom: var(--space-sm);
        }

        /* Description textarea */
        .description-input {
            width: 100%;
            padding: 12px 14px;
            font-size: var(--text-md);
            font-family: var(--font-sans);
            color: var(--carbon);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-sm);
            background: var(--white);
            resize: none;
            min-height: 120px;
            line-height: 1.5;
        }

        .description-input:focus {
            outline: none;
            border-color: var(--jet);
        }

        .description-input::placeholder {
            color: var(--slate);
        }

        /* Button groups */
        .button-group {
            display: flex;
            gap: var(--space-xs);
        }

        .button-group .btn {
            flex: 1;
        }

        .button-group-wrap {
            display: flex;
            flex-wrap: wrap;
            gap: var(--space-xs);
        }

        .button-group-wrap .btn {
            padding: 10px 16px;
        }

        /* Slider */
        .slider-row {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }

        .slider-label {
            font-size: var(--text-sm);
            color: var(--slate);
            min-width: 60px;
        }

        .slider-label.right {
            text-align: right;
        }

        .people-slider {
            flex: 1;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--gainsboro);
            border-radius: 4px;
            cursor: pointer;
        }

        .people-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: var(--jet);
            border-radius: 50%;
            cursor: pointer;
        }

        .people-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: var(--jet);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .slider-value {
            font-size: var(--text-sm);
            font-weight: 600;
            color: var(--jet);
            min-width: 40px;
            text-align: center;
        }

        /* Generate section */
        .generate-section {
            margin-top: var(--space-md);
        }

        .calc-display {
            font-size: var(--text-md);
            color: var(--carbon);
            margin-bottom: var(--space-sm);
            text-align: center;
        }

        /* Progress */
        .progress-section {
            display: none;
            margin-top: var(--space-lg);
            padding: var(--space-lg);
            background: var(--white);
            border-radius: var(--radius-lg);
            border: 1px solid var(--gainsboro);
        }

        .progress-section.visible {
            display: block;
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-sm);
        }

        .progress-title {
            font-size: var(--text-xs);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--slate);
        }

        .progress-count {
            font-size: var(--text-sm);
            font-weight: 600;
            color: var(--jet);
        }

        .progress-bar-container {
            height: 8px;
            background: var(--off-white);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: var(--jet);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }

        /* Results */
        .results-section {
            display: none;
            margin-top: var(--space-lg);
        }

        .results-section.visible {
            display: block;
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-md);
        }

        .results-header h3 {
            font-size: var(--text-sm);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--carbon);
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: var(--space-md);
        }

        @media (max-width: 900px) {
            .results-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            .generator-grid {
                grid-template-columns: 1fr;
            }
        }

        .result-card {
            position: relative;
            border-radius: var(--radius-md);
            overflow: hidden;
            cursor: pointer;
            border: 2px solid var(--gainsboro);
            transition: all var(--transition-fast);
            background: var(--off-white);
        }

        .result-card:hover {
            border-color: var(--jet);
        }

        .result-card img {
            width: 100%;
            aspect-ratio: 4/3;
            object-fit: cover;
            display: block;
        }

        .result-card[data-ratio="3:4"] img,
        .result-card[data-ratio="2:3"] img {
            aspect-ratio: 3/4;
        }

        .result-card[data-ratio="16:9"] img,
        .result-card[data-ratio="21:9"] img {
            aspect-ratio: 16/9;
        }

        .result-card[data-ratio="1:1"] img {
            aspect-ratio: 1/1;
        }

        .result-placeholder {
            width: 100%;
            aspect-ratio: 4/3;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: var(--space-xs);
            background: var(--off-white);
        }

        .result-placeholder .spinner {
            width: 24px;
            height: 24px;
            border: 2px solid var(--gainsboro);
            border-top-color: var(--jet);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .result-placeholder p {
            font-size: var(--text-xs);
            color: var(--slate);
        }

        .result-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: var(--space-sm);
            background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
            opacity: 0;
            transition: opacity var(--transition-fast);
        }

        .result-card:hover .result-overlay {
            opacity: 1;
        }

        .result-actions {
            display: flex;
            gap: var(--space-xs);
        }

        .result-btn {
            flex: 1;
            padding: 6px 10px;
            background: var(--white);
            border: none;
            border-radius: var(--radius-sm);
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .result-btn:hover {
            background: var(--jet);
            color: var(--white);
        }

        .result-tag {
            position: absolute;
            top: var(--space-xs);
            left: var(--space-xs);
            padding: 2px 6px;
            background: rgba(0,0,0,0.6);
            color: white;
            font-size: 10px;
            border-radius: var(--radius-xs);
            text-transform: uppercase;
        }

        /* Lightbox */
        .lightbox {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: var(--space-lg);
        }

        .lightbox.visible {
            display: flex;
        }

        .lightbox-content {
            display: flex;
            gap: var(--space-lg);
            max-width: 1400px;
            max-height: 90vh;
        }

        .lightbox-image {
            max-height: 85vh;
            max-width: 60vw;
            object-fit: contain;
            border-radius: var(--radius-md);
        }

        .lightbox-info {
            width: 320px;
            background: var(--white);
            border-radius: var(--radius-md);
            padding: var(--space-md);
            overflow-y: auto;
            max-height: 85vh;
        }

        .lightbox-info h3 {
            font-size: var(--text-xs);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--slate);
            margin-bottom: var(--space-xs);
        }

        .lightbox-info p {
            font-size: var(--text-sm);
            color: var(--carbon);
            margin-bottom: var(--space-md);
            line-height: 1.5;
        }

        .lightbox-close {
            position: absolute;
            top: var(--space-md);
            right: var(--space-md);
            width: 44px;
            height: 44px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: var(--radius-sm);
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
        }

        .lightbox-close:hover {
            background: rgba(255,255,255,0.2);
        }

        .lightbox-nav {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 50px;
            height: 50px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: var(--radius-sm);
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
        }

        .lightbox-nav:hover {
            background: rgba(255,255,255,0.2);
        }

        .lightbox-prev { left: var(--space-md); }
        .lightbox-next { right: var(--space-md); }

        /* Inline Loader */
        .inline-loader {
            display: none;
            text-align: center;
            padding: var(--space-xl) var(--space-lg);
            background: var(--white);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-lg);
            margin-top: var(--space-lg);
        }

        .inline-loader.visible {
            display: block;
        }

        .loader-message {
            font-size: var(--text-lg);
            font-weight: 500;
            color: var(--jet);
            margin-bottom: var(--space-sm);
            transition: opacity 0.25s ease;
        }

        .loader-message.fade-out {
            opacity: 0;
        }

        .loader-message.fade-in {
            opacity: 1;
        }

        .loader-progress {
            font-size: var(--text-sm);
            color: var(--slate);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="hero">
            <h1>Location Creator</h1>
            <p class="hero-subtitle">Generate diverse location and environment shots with compositional variety</p>
        </div>

        <!-- Generator Controls -->
        <div class="generator-grid">
            <!-- Description -->
            <div class="generator-section full-width">
                <div class="section-title">Describe the Location</div>
                <textarea class="description-input" id="description-input"
                    placeholder="Describe the location or environment...&#10;&#10;Example: Brutalist concrete museum interior with dramatic skylights, geometric shapes, raw concrete walls, diffused natural light streaming through angular windows"></textarea>
            </div>

            <!-- People Slider -->
            <div class="generator-section full-width">
                <div class="section-title">Include People</div>
                <div class="slider-row">
                    <span class="slider-label">None</span>
                    <input type="range" class="people-slider" id="people-slider" min="0" max="100" value="30">
                    <span class="slider-label right">All</span>
                    <span class="slider-value" id="people-value">30%</span>
                </div>
            </div>

            <!-- Lighting (multi-select) -->
            <div class="generator-section full-width">
                <div class="section-title">Lighting (select multiple)</div>
                <div class="button-group" id="lighting-group">
                    <button class="btn btn--toggle active" data-value="hard">Hard Daylight</button>
                    <button class="btn btn--toggle active" data-value="soft">Soft Afternoon</button>
                    <button class="btn btn--toggle" data-value="overcast">Overcast</button>
                    <button class="btn btn--toggle" data-value="golden">Golden Hour</button>
                </div>
            </div>

            <!-- Model (multi-select) -->
            <div class="generator-section">
                <div class="section-title">Model</div>
                <div class="button-group" id="model-group">
                    <button class="btn btn--toggle active" data-value="reve">Reve</button>
                    <button class="btn btn--toggle" data-value="zimage">Z-Image</button>
                </div>
            </div>

            <!-- Aspect Ratio -->
            <div class="generator-section">
                <div class="section-title">Aspect Ratio</div>
                <div class="button-group" id="aspect-group">
                    <button class="btn btn--toggle" data-value="3:4">3:4</button>
                    <button class="btn btn--toggle active" data-value="4:3">4:3</button>
                    <button class="btn btn--toggle" data-value="16:9">16:9</button>
                    <button class="btn btn--toggle" data-value="1:1">1:1</button>
                </div>
            </div>

            <!-- Number of Results -->
            <div class="generator-section full-width">
                <div class="section-title">Number of Results</div>
                <div class="button-group" id="count-group">
                    <button class="btn btn--toggle" data-value="8">8</button>
                    <button class="btn btn--toggle active" data-value="12">12</button>
                    <button class="btn btn--toggle" data-value="16">16</button>
                    <button class="btn btn--toggle" data-value="20">20</button>
                </div>
            </div>
        </div>

        <!-- Generate -->
        <div class="generate-section">
            <div class="calc-display" id="calc-display">12 images @ $0.04 each = $0.48</div>
            <button class="btn btn--primary btn--lg btn--block" id="generate-btn">Generate Locations</button>
        </div>

        <!-- Progress -->
        <div class="progress-section" id="progress-section">
            <div class="progress-header">
                <span class="progress-title">Generating</span>
                <span class="progress-count" id="progress-count">0 / 0</span>
            </div>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
        </div>

        <!-- Results -->
        <div class="results-section" id="results-section">
            <div class="results-header">
                <h3>Generated Locations</h3>
                <button class="btn" id="download-all-btn">Download All</button>
            </div>
            <div class="results-grid" id="results-grid"></div>
        </div>
    </div>

    <!-- Lightbox -->
    <div class="lightbox" id="lightbox" onclick="if(event.target === this) closeLightbox()">
        <button class="lightbox-close" onclick="closeLightbox()">&times;</button>
        <button class="lightbox-nav lightbox-prev" onclick="navigateLightbox(-1)">&#8249;</button>
        <button class="lightbox-nav lightbox-next" onclick="navigateLightbox(1)">&#8250;</button>
        <div class="lightbox-content">
            <img class="lightbox-image" id="lightbox-image" src="" alt="Generated location">
            <div class="lightbox-info">
                <h3>Composition</h3>
                <p id="lightbox-composition"></p>
                <h3>Prompt</h3>
                <p id="lightbox-prompt"></p>
                <h3>Settings</h3>
                <p id="lightbox-settings"></p>
                <button class="btn btn--primary btn--block" id="lightbox-download">Download</button>
            </div>
        </div>
    </div>

    <script src="/shared/js/api.js"></script>
    <script src="/shared/js/loader.js"></script>
    <script src="/shared/data/editorial-moods.js"></script>
    <script>
        // State
        const state = {
            description: '',
            peoplePercent: 30,
            lighting: ['hard', 'soft'],  // multi-select lighting types
            models: ['reve'],
            aspectRatio: '4:3',
            resultCount: 12,
            results: [],
            generating: false,
            lightboxIndex: 0
        };

        // Model costs per image
        const MODEL_COSTS = {
            'reve': 0.04,
            'zimage': 0.01
        };

        // Aspect ratio to dimensions (for models that need explicit sizes)
        const ASPECT_SIZES = {
            '3:4': { width: 768, height: 1024 },
            '4:3': { width: 1024, height: 768 },
            '16:9': { width: 1280, height: 720 },
            '1:1': { width: 1024, height: 1024 }
        };

        // Composition types - ALL must show FULL PERSON (head to toe) or 3/4 (head to knees)
        // NEVER cut off the head - face must ALWAYS be visible
        const COMPOSITION_TYPES = [
            // Full body (most shots should be these)
            { type: 'wide', label: 'Wide', desc: 'full-body, head-to-toe, person fills ~2/3 of frame height' },
            { type: 'center', label: 'Center', desc: 'full-body centered, environment on both sides' },
            { type: 'left', label: 'Left', desc: 'full-body on left third, not too tight, environment fills right' },
            { type: 'right', label: 'Right', desc: 'full-body on right third, environment fills left' },
            { type: 'depth', label: 'Depth', desc: 'full-body with depth layers, person still prominent' },
            // 3/4 body (fewer of these)
            { type: 'threequarter', label: '3/4', desc: '3/4 body from head to knees, face clearly visible, slightly tighter' },
            { type: 'threequarter_left', label: '3/4 Left', desc: '3/4 body on left side, head to knees, face visible' },
            { type: 'threequarter_right', label: '3/4 Right', desc: '3/4 body on right side, head to knees, face visible' },
            // Special
            { type: 'low_angle', label: 'Low Angle', desc: 'full-body from slightly lower angle, sky above' },
            { type: 'foreground', label: 'Foreground', desc: 'blurry foreground element, full-body in focus behind' }
        ];

        // Lighting variations by type
        const LIGHTING_BY_TYPE = {
            hard: [
                'hard direct sunlight, strong shadows, high contrast',
                'harsh midday sun, crisp shadows on ground',
                'bright direct daylight, sun high in sky',
                'strong sunlight creating sharp defined shadows'
            ],
            soft: [
                'soft late afternoon light, warm but not golden',
                'diffused natural light with gentle directionality',
                'soft directional light, fashion campaign quality',
                'gentle side light creating subtle dimension'
            ],
            overcast: [
                'soft overcast light, even and flattering',
                'cloudy diffused light, no harsh shadows',
                'flat overcast sky, even illumination',
                'grey sky ambient light, soft and moody'
            ],
            golden: [
                'golden hour warm light, long shadows',
                'late day golden sunlight, warm tones',
                'sunset light, warm orange glow',
                'magic hour lighting, golden and soft'
            ]
        };

        // Get lighting variations based on selected types
        function getSelectedLighting() {
            let variations = [];
            state.lighting.forEach(type => {
                if (LIGHTING_BY_TYPE[type]) {
                    variations = variations.concat(LIGHTING_BY_TYPE[type]);
                }
            });
            return variations.length > 0 ? variations : LIGHTING_BY_TYPE.soft;
        }

        // Editorial person placements - fierce and commanding presence
        // These should feel like fashion editorial, not generic stock photos
        const PERSON_PLACEMENTS = [
            // Powerful poses
            'a model standing with fierce confidence, direct challenging gaze at camera, commanding the space',
            'a figure leaning against the wall with editorial intensity, smoldering look, owning the environment',
            'someone seated on the floor with defiant expression, chin raised, fashion editorial pose',
            'a model mid-stride walking toward camera with powerful presence, intense focused gaze',
            'a figure framed in doorway with nonchalant editorial attitude, unbothered cool expression',
            // Dynamic/artistic
            'a person in motion blur walking through, editorial ghost effect, ethereal presence',
            'silhouette of a figure against dramatic light, striking pose, fashion editorial',
            'someone looking over shoulder with smoldering expression, caught mid-turn',
            'a model crouched low with intense upward gaze, raw and powerful',
            // Contextual but fierce
            'a figure ascending stairs with commanding presence, looking back at camera',
            'someone standing at window in contemplative but powerful pose, editorial stillness',
            'a model interacting with architecture, hand trailing on surface, cool detachment',
            // Scale figures (still editorial)
            'a small figure in the distance, perfect posture, adding scale and editorial atmosphere',
            'two figures in background conversation, stylish silhouettes, fashion context'
        ];

        // Fierce expression pool for people in locations
        const FIERCE_EXPRESSIONS = [
            'fierce intense gaze with slightly parted lips',
            'intense powerful stare with clenched jaw',
            'smoldering look with lips barely open',
            'defiant expression with chin raised, challenging the camera',
            'commanding presence with brow slightly furrowed',
            'sharp piercing eyes with mouth firmly closed',
            'editorial blank stare, fashion neutral but powerful',
            'nonchalant model-off-duty expression, effortlessly cool',
            'high fashion disdain, looking slightly past camera'
        ];

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            setupEventListeners();
            updateCalcDisplay();
        });

        function setupEventListeners() {
            // Description
            document.getElementById('description-input').addEventListener('input', (e) => {
                state.description = e.target.value;
            });

            // People slider
            const peopleSlider = document.getElementById('people-slider');
            const peopleValue = document.getElementById('people-value');
            peopleSlider.addEventListener('input', (e) => {
                state.peoplePercent = parseInt(e.target.value);
                peopleValue.textContent = `${state.peoplePercent}%`;
            });

            // Lighting multi-select (toggle)
            document.querySelectorAll('#lighting-group .btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const value = btn.dataset.value;
                    const index = state.lighting.indexOf(value);

                    if (index > -1) {
                        // Don't allow deselecting if it's the only one
                        if (state.lighting.length > 1) {
                            state.lighting.splice(index, 1);
                            btn.classList.remove('active');
                        }
                    } else {
                        state.lighting.push(value);
                        btn.classList.add('active');
                    }
                });
            });

            // Model multi-select (toggle)
            document.querySelectorAll('#model-group .btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const value = btn.dataset.value;
                    const index = state.models.indexOf(value);

                    if (index > -1) {
                        if (state.models.length > 1) {
                            state.models.splice(index, 1);
                            btn.classList.remove('active');
                        }
                    } else {
                        state.models.push(value);
                        btn.classList.add('active');
                    }
                    updateCalcDisplay();
                });
            });

            // Aspect ratio single-select
            document.querySelectorAll('#aspect-group .btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#aspect-group .btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.aspectRatio = btn.dataset.value;
                });
            });

            // Count single-select
            document.querySelectorAll('#count-group .btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#count-group .btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.resultCount = parseInt(btn.dataset.value);
                    updateCalcDisplay();
                });
            });

            // Generate button
            document.getElementById('generate-btn').addEventListener('click', generateLocations);

            // Download all button
            document.getElementById('download-all-btn').addEventListener('click', downloadAll);

            // Keyboard navigation for lightbox
            document.addEventListener('keydown', (e) => {
                if (!document.getElementById('lightbox').classList.contains('visible')) return;
                if (e.key === 'Escape') closeLightbox();
                if (e.key === 'ArrowLeft') navigateLightbox(-1);
                if (e.key === 'ArrowRight') navigateLightbox(1);
            });
        }

        function updateCalcDisplay() {
            const totalImages = state.resultCount * state.models.length;
            const totalCost = state.models.reduce((sum, m) => sum + (MODEL_COSTS[m] || 0.04) * state.resultCount, 0);
            const modelNames = state.models.map(m => m === 'reve' ? 'Reve' : 'Z-Image').join(' + ');
            document.getElementById('calc-display').textContent = `${state.resultCount} prompts √ó ${state.models.length} model${state.models.length > 1 ? 's' : ''} = ${totalImages} images ‚âà $${totalCost.toFixed(2)}`;
        }

        // Generate prompts via GPT
        async function generatePrompts(count) {
            // Calculate how many should have people
            const peopleCount = Math.round(count * (state.peoplePercent / 100));

            const systemPrompt = `You are writing DETAILED, EVOCATIVE prompts for fashion campaign backdrop photography.

YOUR PROMPTS MUST BE:
1. HIGHLY DESCRIPTIVE - paint a vivid picture with specific details (textures, colors, atmosphere, light quality)
2. EACH ONE UNIQUE - every prompt should describe a distinctly different scene/angle/mood
3. TRUE TO THE LOCATION - capture the specific character described (if they say "dark volcanic rocks" - make them DARK, not bright)

PROMPT STRUCTURE - each prompt should include:
- Specific environmental details (what exactly do we see? what textures? what colors?)
- Atmosphere and mood (how does the air feel? what's the quality of light?)
- Spatial description (where is the standing space for the model?)
- Lighting specifics (direction, quality, shadows, highlights)

EXAMPLE OF GOOD VS BAD:
BAD: "Standing space on left with rocks on right, overcast lighting"
GOOD: "Jagged obsidian-black volcanic rock formations rise on the right, their porous surfaces catching subtle highlights, while the left third opens to a flat expanse of dark weathered stone where a figure could stand, the overcast sky creating soft even illumination that emphasizes the raw mineral textures"

BACKDROP REQUIREMENTS:
- Every shot must have clear space for a full-body OR half-body person
- Ground must be visible for full-body shots
- Person should fill significant portion of frame (not tiny in distance)

STYLE: Campaign/editorial - confident, quiet, not overly dramatic or adventure-tourism feeling`;

            // Build lighting instruction
            const lightingTypes = [];
            if (state.lighting.includes('hard')) lightingTypes.push('hard direct sunlight with crisp shadows');
            if (state.lighting.includes('soft')) lightingTypes.push('soft diffused afternoon light');
            if (state.lighting.includes('overcast')) lightingTypes.push('overcast even lighting');
            if (state.lighting.includes('golden')) lightingTypes.push('golden hour warm light');
            const lightingInstruction = lightingTypes.length > 0 ? lightingTypes.join(', ') : 'natural light';

            const userPrompt = `Write ${count} DETAILED backdrop prompts for this location. Each must be HIGHLY DESCRIPTIVE and DISTINCTLY DIFFERENT.

===== THE LOCATION =====
${state.description || 'An interesting environmental location'}

===== CRITICAL =====
- STAY TRUE to the location description above. If it says "dark volcanic rocks" they must be DARK, not bright.
- Each prompt must be 2-3 sentences of RICH DESCRIPTION - textures, colors, atmosphere, specific details
- Every prompt must be DIFFERENT - vary the angle, the specific elements shown, the mood

===== COMPOSITION TYPES (use these labels) =====

CRITICAL: The person's HEAD and FACE must ALWAYS be visible. NEVER cut off at the waist showing only legs.

FULL-BODY (~75% of shots): [Wide], [Center], [Left], [Right], [Depth]
- Head-to-toe, entire person visible
- Person fills significant portion of frame (not tiny)
- [Left] should not be too tight - give breathing room

3/4 BODY (~15% of shots): [3/4], [3/4 Left], [3/4 Right]
- Head to approximately knees
- FACE MUST BE VISIBLE - this is upper 3/4, not lower
- Slightly tighter framing

SPECIAL (~10%): [Low Angle], [Foreground]
- [Low Angle] = full-body from slightly lower, sky above
- [Foreground] = blurry element in front, full-body sharp behind

===== LIGHTING =====
Distribute across prompts: ${lightingInstruction}

===== PEOPLE =====
${peopleCount > 0 ? `Include a person in ${peopleCount} of the ${count} prompts. When including people: editorial/fierce presence, commanding posture, confident expression. Person should feel like they belong in a fashion campaign.` : 'No people in these shots.'}

===== FORMAT =====
Start each with [CompositionType] then 2-3 sentences of vivid description.
Return ONLY a JSON array of strings.`;

            try {
                console.log('üèõÔ∏è [Location Creator] Generating prompts...');

                const response = await fetch('/api/analyze', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        images: [],
                        prompt: userPrompt,
                        system: systemPrompt
                    })
                });

                const data = await response.json();

                if (data.error) {
                    console.error('üèõÔ∏è [Location Creator] GPT Error:', data.error);
                    throw new Error(data.error);
                }

                let content = data.content || '';
                console.log('üèõÔ∏è [Location Creator] GPT Response received, length:', content.length);

                // Extract JSON array from response
                const jsonMatch = content.match(/\[[\s\S]*\]/);
                if (jsonMatch) {
                    const rawPrompts = JSON.parse(jsonMatch[0]);

                    // Handle both string arrays and object arrays
                    const processedPrompts = rawPrompts.map(p => {
                        let promptText = p;
                        if (typeof p === 'object' && p !== null) {
                            promptText = p.prompt || p.description || p.text || p.content || JSON.stringify(p);
                        }
                        return promptText;
                    });

                    return processedPrompts;
                }

                throw new Error('Failed to parse prompts');
            } catch (error) {
                console.error('üèõÔ∏è [Location Creator] Prompt generation error:', error);
                return generateFallbackPrompts(count);
            }
        }

        function generateFallbackPrompts(count) {
            const prompts = [];
            const peopleCount = Math.round(count * (state.peoplePercent / 100));
            const baseDesc = state.description || 'Dramatic architectural interior with interesting lighting';

            // Check if description suggests softer mood
            const descLower = state.description.toLowerCase();
            const isSoftMood = descLower.includes('soft') || descLower.includes('gentle') ||
                              descLower.includes('warm') || descLower.includes('cozy');

            // Shuffle compositions
            const shuffledComps = [...COMPOSITION_TYPES].sort(() => Math.random() - 0.5);
            const shuffledLighting = [...getSelectedLighting()].sort(() => Math.random() - 0.5);
            const shuffledPlacements = [...PERSON_PLACEMENTS].sort(() => Math.random() - 0.5);
            const shuffledExpressions = [...FIERCE_EXPRESSIONS].sort(() => Math.random() - 0.5);

            for (let i = 0; i < count; i++) {
                const comp = shuffledComps[i % shuffledComps.length];
                const lighting = shuffledLighting[i % shuffledLighting.length];
                const includePerson = i < peopleCount;

                let personText = '';
                if (includePerson) {
                    const placement = shuffledPlacements[i % shuffledPlacements.length];
                    // For soft moods, adjust the expression
                    if (isSoftMood) {
                        personText = `, ${placement.replace(/fierce|defiant|intense|smoldering/gi, 'contemplative')}`;
                    } else {
                        personText = `, ${placement}`;
                    }
                }

                const prompt = `[${comp.label}] ${comp.desc}, ${baseDesc}, ${lighting}${personText}, professional editorial photography, photorealistic`;
                prompts.push(prompt);
            }

            return prompts;
        }

        // Main generation function
        async function generateLocations() {
            if (state.generating) return;
            if (!state.description.trim()) {
                alert('Please describe the location you want to generate');
                return;
            }

            state.generating = true;
            state.results = [];

            const count = state.resultCount;
            const totalImages = count * state.models.length;

            // Show loader and progress
            startLoadingAnimation(`Creating ${count} unique compositions...`);
            document.getElementById('progress-section').classList.add('visible');
            document.getElementById('progress-count').textContent = `0 / ${totalImages}`;
            document.getElementById('progress-bar').style.width = '0%';
            document.getElementById('results-section').classList.remove('visible');
            document.getElementById('results-grid').innerHTML = '';
            document.getElementById('generate-btn').disabled = true;

            try {
                // Step 1: Generate prompts via GPT
                document.querySelector('.progress-title').textContent = 'Creating compositions...';
                const prompts = await generatePrompts(count);
                console.log(`üèõÔ∏è [Location Creator] Generated ${prompts.length} prompts`);

                // Step 2: Create placeholder cards
                const jobs = [];
                let resultIndex = 0;

                prompts.forEach((prompt, promptIndex) => {
                    state.models.forEach((model) => {
                        // Extract composition type from prompt
                        const compMatch = prompt.match(/^\[([^\]]+)\]/);
                        const compType = compMatch ? compMatch[1] : 'Shot';

                        addResultPlaceholder(resultIndex, compType);
                        state.results.push({
                            id: resultIndex,
                            prompt,
                            model,
                            composition: compType,
                            url: null,
                            generating: true
                        });
                        jobs.push({ index: resultIndex, prompt, model });
                        resultIndex++;
                    });
                });

                // Stop loader, show results with placeholders
                stopLoadingAnimation();
                document.getElementById('results-section').classList.add('visible');
                document.querySelector('.progress-title').textContent = 'Generating';

                // Step 3: Generate images in parallel (batches of 4)
                let completed = 0;
                const batchSize = 4;

                for (let i = 0; i < jobs.length; i += batchSize) {
                    const batch = jobs.slice(i, i + batchSize);
                    const batchPromises = batch.map(async (job) => {
                        const { index, prompt, model } = job;
                        try {
                            const params = {
                                model: model,
                                prompt: prompt,
                                num_images: 1
                            };

                            if (model === 'reve') {
                                params.aspect_ratio = state.aspectRatio;
                            } else {
                                params.image_size = ASPECT_SIZES[state.aspectRatio] || ASPECT_SIZES['4:3'];
                            }

                            const response = await fetch('/api/generate', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(params)
                            });

                            const data = await response.json();

                            if (data.images && data.images[0]) {
                                const imageUrl = data.images[0].url;
                                state.results[index].url = imageUrl;
                                state.results[index].generating = false;
                                state.results[index].aspectRatio = state.aspectRatio;
                                updateResultCard(index, imageUrl);
                            } else {
                                throw new Error('No image returned');
                            }
                        } catch (error) {
                            console.error(`Generation ${index} failed:`, error);
                            state.results[index].error = error.message;
                            state.results[index].generating = false;
                            updateResultError(index);
                        }

                        completed++;
                        document.getElementById('progress-count').textContent = `${completed} / ${totalImages}`;
                        document.getElementById('progress-bar').style.width = `${(completed / totalImages) * 100}%`;
                    });

                    await Promise.all(batchPromises);
                }

                document.querySelector('.progress-title').textContent = 'Complete';

            } catch (error) {
                console.error('Generation error:', error);
                stopLoadingAnimation();
                alert('Failed to generate: ' + error.message);
            } finally {
                state.generating = false;
                document.getElementById('generate-btn').disabled = false;
            }
        }

        function addResultPlaceholder(index, compType) {
            const grid = document.getElementById('results-grid');
            const html = `
                <div class="result-card" id="result-${index}" data-index="${index}" data-ratio="${state.aspectRatio}">
                    <div class="result-placeholder">
                        <div class="spinner"></div>
                        <p>${compType}</p>
                    </div>
                </div>
            `;
            grid.insertAdjacentHTML('beforeend', html);
        }

        function updateResultCard(index, imageUrl) {
            const card = document.getElementById(`result-${index}`);
            if (!card) return;

            const result = state.results[index];
            card.innerHTML = `
                <img src="${imageUrl}" alt="Generated location ${index + 1}" onclick="openLightbox(${index})">
                <span class="result-tag">${result.composition}</span>
                <div class="result-overlay">
                    <div class="result-actions">
                        <button class="result-btn" onclick="event.stopPropagation(); downloadImage(${index})">Download</button>
                    </div>
                </div>
            `;
        }

        function updateResultError(index) {
            const card = document.getElementById(`result-${index}`);
            if (!card) return;

            card.innerHTML = `
                <div class="result-placeholder">
                    <p>Failed</p>
                </div>
            `;
        }

        // Lightbox functions
        function openLightbox(index) {
            state.lightboxIndex = index;
            updateLightboxContent();
            document.getElementById('lightbox').classList.add('visible');
        }

        function closeLightbox() {
            document.getElementById('lightbox').classList.remove('visible');
        }

        function navigateLightbox(direction) {
            const validResults = state.results.filter(r => r.url);
            const currentValidIndex = validResults.findIndex(r => r.id === state.lightboxIndex);
            const newValidIndex = currentValidIndex + direction;

            if (newValidIndex >= 0 && newValidIndex < validResults.length) {
                state.lightboxIndex = validResults[newValidIndex].id;
                updateLightboxContent();
            }
        }

        function updateLightboxContent() {
            const result = state.results[state.lightboxIndex];
            if (!result || !result.url) return;

            const modelNames = { 'reve': 'Reve', 'zimage': 'Z-Image' };
            document.getElementById('lightbox-image').src = result.url;
            document.getElementById('lightbox-composition').textContent = result.composition || 'Shot';
            document.getElementById('lightbox-prompt').textContent = result.prompt;
            document.getElementById('lightbox-settings').textContent = `Model: ${modelNames[result.model] || result.model}\nAspect: ${result.aspectRatio || '4:3'}\nPeople: ${state.peoplePercent}%`;
            document.getElementById('lightbox-download').onclick = () => downloadImage(state.lightboxIndex);
        }

        // Download functions
        async function downloadImage(index) {
            const result = state.results[index];
            if (!result || !result.url) return;

            const compLabel = (result.composition || 'shot').toLowerCase().replace(/\s+/g, '_');
            const filename = `Setset_Location_${compLabel}_${String(index + 1).padStart(2, '0')}_${Date.now()}.png`;

            try {
                const response = await fetch(`/api/proxy-download?url=${encodeURIComponent(result.url)}`);
                const blob = await response.blob();
                const downloadUrl = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = downloadUrl;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(downloadUrl);
            } catch (error) {
                console.error('Download failed:', error);
                window.open(result.url, '_blank');
            }
        }

        async function downloadAll() {
            const validResults = state.results.filter(r => r.url);
            for (let i = 0; i < validResults.length; i++) {
                await downloadImage(validResults[i].id);
                await new Promise(r => setTimeout(r, 300));
            }
        }
    </script>
</body>
</html>
