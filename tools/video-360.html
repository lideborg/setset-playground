<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video 360 - Reference to Video</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üîÑ</text></svg>">
    <link rel="stylesheet" href="/shared/css/tokens.css">
    <link rel="stylesheet" href="/shared/css/base.css">
    <link rel="stylesheet" href="/shared/css/components.css">
    <style>
        .container {
            max-width: 1200px;
        }

        /* Settings section */
        .settings-section {
            background: var(--white);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-md);
            padding: var(--space-md);
            margin-bottom: var(--space-lg);
        }

        .setting-row {
            display: flex;
            align-items: center;
            gap: var(--space-lg);
            flex-wrap: wrap;
            margin-bottom: var(--space-md);
        }

        .setting-row:last-child {
            margin-bottom: 0;
        }

        .setting-group {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }

        .setting-label {
            font-size: var(--text-xs);
            font-weight: 500;
            color: var(--slate);
            min-width: 60px;
        }

        /* Toggle buttons */
        .toggle-buttons {
            display: flex;
            gap: 4px;
        }

        .toggle-btn {
            padding: 6px 12px;
            font-size: var(--text-xs);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-sm);
            background: var(--off-white);
            color: var(--slate);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .toggle-btn:hover {
            border-color: var(--ash-grey);
        }

        .toggle-btn.active {
            background: var(--jet);
            color: var(--white);
            border-color: var(--jet);
        }

        /* Pairs slider */
        .pairs-slider-group {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }

        .pairs-slider {
            width: 100px;
            cursor: pointer;
        }

        .pairs-value {
            font-size: var(--text-sm);
            font-weight: 600;
            color: var(--jet);
            min-width: 40px;
        }

        /* Duration slider */
        .duration-slider-group {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }

        .duration-slider {
            width: 120px;
            cursor: pointer;
        }

        .duration-value {
            font-size: var(--text-sm);
            font-weight: 600;
            color: var(--jet);
            min-width: 30px;
        }

        /* Input pairs grid */
        .pairs-container {
            margin-bottom: var(--space-lg);
        }

        .pairs-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-md);
            margin-bottom: var(--space-lg);
        }

        .pair-group {
            display: flex;
            flex-direction: column;
            gap: var(--space-sm);
        }

        .pair-number {
            font-size: var(--text-xs);
            font-weight: 600;
            color: var(--slate);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: var(--space-xs);
        }

        /* Frame + Element layout */
        .pair-inputs {
            display: flex;
            gap: var(--space-sm);
        }

        .frame-column {
            flex: 0 0 auto;
            width: 180px;
        }

        .element-column {
            flex: 1;
            min-width: 0;
        }

        /* Image upload slots */
        .frame-slot {
            aspect-ratio: 16/9;
            border: 2px dashed var(--gainsboro);
            border-radius: var(--radius-md);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            background: var(--off-white);
            transition: all var(--transition-fast);
        }

        .frame-slot:hover {
            border-color: var(--ash-grey);
            background: var(--white);
        }

        .frame-slot.filled {
            border-style: solid;
            border-color: var(--jet);
        }

        .frame-slot.filled img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .frame-slot .placeholder {
            text-align: center;
            color: var(--ash-grey);
        }

        .frame-slot .placeholder-icon {
            font-size: 24px;
            margin-bottom: 4px;
        }

        .frame-slot .placeholder-text {
            font-size: var(--text-xs);
            font-weight: 500;
        }

        .frame-slot .remove-btn {
            position: absolute;
            top: 6px;
            right: 6px;
            width: 24px;
            height: 24px;
            background: rgba(0,0,0,0.7);
            color: var(--white);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 14px;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .frame-slot.filled:hover .remove-btn {
            display: flex;
        }

        .frame-label {
            font-size: var(--text-2xs);
            font-weight: 500;
            color: var(--slate);
            text-align: center;
            margin-top: 4px;
        }

        /* Element section */
        .element-section {
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-sm);
            padding: var(--space-sm);
            background: var(--off-white);
        }

        .element-header {
            font-size: var(--text-2xs);
            font-weight: 600;
            color: var(--slate);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: var(--space-xs);
        }

        .element-slots {
            display: flex;
            gap: var(--space-xs);
        }

        .element-slot {
            width: 64px;
            height: 64px;
            border: 2px dashed var(--gainsboro);
            border-radius: var(--radius-sm);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            background: var(--white);
            transition: all var(--transition-fast);
            flex-shrink: 0;
        }

        .element-slot:hover {
            border-color: var(--ash-grey);
        }

        .element-slot.filled {
            border-style: solid;
            border-color: var(--jet);
        }

        .element-slot.filled img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .element-slot .placeholder {
            text-align: center;
            color: var(--ash-grey);
        }

        .element-slot .placeholder-icon {
            font-size: 14px;
        }

        .element-slot .placeholder-text {
            font-size: 8px;
            font-weight: 500;
        }

        .element-slot .remove-btn {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 16px;
            height: 16px;
            background: rgba(0,0,0,0.7);
            color: var(--white);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 10px;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .element-slot.filled:hover .remove-btn {
            display: flex;
        }

        .element-slot-label {
            font-size: 8px;
            color: var(--ash-grey);
            text-align: center;
            margin-top: 2px;
        }

        /* Prompt textarea for each pair */
        .pair-prompt {
            width: 100%;
            min-height: 60px;
            padding: var(--space-xs);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-sm);
            font-family: var(--font-sans);
            font-size: var(--text-xs);
            resize: vertical;
            transition: border-color var(--transition-fast);
        }

        .pair-prompt:focus {
            outline: none;
            border-color: var(--jet);
        }

        .pair-prompt::placeholder {
            color: var(--ash-grey);
        }

        /* Generate section */
        .generate-section {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--space-lg);
        }

        .generate-btn {
            padding: 14px 32px;
            font-size: 15px;
            min-width: 180px;
        }

        .generate-info {
            font-size: var(--text-sm);
            color: var(--slate);
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Results */
        .results-section {
            display: none;
        }

        .results-section.visible {
            display: block;
        }

        .results-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--space-md);
        }

        .results-header h2 {
            font-size: var(--text-lg);
            font-weight: 600;
        }

        .videos-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: var(--space-md);
        }

        .batch-divider {
            grid-column: 1 / -1;
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            color: var(--french-gray);
            font-size: var(--text-xs);
            padding: var(--space-xs) 0;
        }

        .batch-divider::before,
        .batch-divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: var(--gainsboro);
        }

        .video-card {
            background: var(--white);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-md);
            overflow: hidden;
        }

        .video-card video {
            width: 100%;
            display: block;
            background: var(--carbon);
        }

        .video-card-footer {
            padding: var(--space-sm);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: var(--space-sm);
        }

        .video-card-info {
            flex: 1;
            overflow: hidden;
        }

        .video-card-pair {
            font-size: var(--text-2xs);
            font-weight: 600;
            color: var(--jet);
            margin-bottom: 2px;
        }

        .video-card-prompt {
            font-size: var(--text-xs);
            color: var(--slate);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .video-card-cost {
            font-size: var(--text-xs);
            color: var(--ash-grey);
            margin-left: var(--space-xs);
        }

        .video-card.generating {
            position: relative;
        }

        .video-card .generating-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--off-white);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1;
        }

        .video-card .generating-spinner {
            width: 32px;
            height: 32px;
            border: 2px solid var(--gainsboro);
            border-top-color: var(--jet);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: var(--space-xs);
        }

        .video-card .generating-text {
            font-size: var(--text-sm);
            color: var(--slate);
        }

        input[type="file"] {
            display: none;
        }

        @media (max-width: 900px) {
            .pairs-row {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="hero">
            <h1>Video 360</h1>
            <p class="hero-subtitle">Generate 360¬∞ rotation videos using Kling reference-to-video</p>
        </div>

        <!-- Settings -->
        <div class="settings-section">
            <div class="setting-row">
                <div class="setting-group">
                    <span class="setting-label">Quality</span>
                    <div class="toggle-buttons" id="quality-buttons">
                        <button class="toggle-btn active" data-value="pro">Pro</button>
                        <button class="toggle-btn" data-value="standard">Standard</button>
                    </div>
                </div>

                <div class="setting-group">
                    <span class="setting-label">Duration</span>
                    <div class="duration-slider-group">
                        <input type="range" class="duration-slider" id="duration-slider" min="3" max="15" value="8" step="1">
                        <span class="duration-value" id="duration-value">8s</span>
                    </div>
                </div>

                <div class="setting-group">
                    <span class="setting-label">Aspect</span>
                    <div class="toggle-buttons" id="aspect-buttons">
                        <button class="toggle-btn active" data-value="16:9">16:9</button>
                        <button class="toggle-btn" data-value="9:16">9:16</button>
                        <button class="toggle-btn" data-value="1:1">1:1</button>
                    </div>
                </div>

                <div class="setting-group pairs-slider-group">
                    <span class="setting-label">Pairs</span>
                    <input type="range" class="pairs-slider" id="pairs-slider" min="1" max="3" value="1" step="1">
                    <span class="pairs-value" id="pairs-value">2</span>
                </div>
            </div>
        </div>

        <!-- Input Pairs -->
        <div class="pairs-container" id="pairs-container">
            <!-- Dynamically generated -->
        </div>

        <!-- Generate -->
        <div class="generate-section">
            <div class="generate-info" id="generate-info">
                Upload images to generate videos
            </div>
            <button class="btn btn--primary generate-btn" id="generate-btn" disabled>
                Generate Videos
            </button>
        </div>

        <!-- Results -->
        <div class="results-section" id="results-section">
            <div class="results-header">
                <h2>Results</h2>
            </div>
            <div class="videos-grid" id="videos-grid"></div>
        </div>
    </div>

    <script src="/shared/js/utils.js"></script>
    <script src="/shared/js/api.js"></script>
    <script>
        // Logging with timestamps
        const startTime = performance.now();
        function log(message, ...args) {
            const elapsed = ((performance.now() - startTime) / 1000).toFixed(2);
            console.log(`[${elapsed}s] ${message}`, ...args);
        }

        // State
        const state = {
            quality: 'pro',
            duration: '8',
            aspectRatio: '16:9',
            numPairs: 1, // 1 = 2 pairs per row
            pairs: [], // Array of { frame, element: { frontal, references[] }, prompt }
            results: [],
            batchCounter: 0
        };

        const DEFAULT_PROMPT = 'The camera moves to execute a smooth, horizontal 360 orbit around @Element1 with a consistent pace. ending on the same frame as it started.';

        // Initialize pairs array
        function initializePairs() {
            const totalPairs = state.numPairs * 2;
            while (state.pairs.length < totalPairs) {
                state.pairs.push({
                    frame: null,
                    element: { frontal: null, references: [null, null, null] },
                    prompt: DEFAULT_PROMPT
                });
            }
            state.pairs.length = totalPairs;
        }

        // Cost calculation
        function calculateVideoCost() {
            const duration = parseInt(state.duration);
            const pricePerSec = state.quality === 'pro' ? 0.224 : 0.084;
            return duration * pricePerSec;
        }

        // DOM Elements
        const elements = {
            qualityButtons: document.getElementById('quality-buttons'),
            durationSlider: document.getElementById('duration-slider'),
            durationValue: document.getElementById('duration-value'),
            aspectButtons: document.querySelectorAll('#aspect-buttons .toggle-btn'),
            pairsSlider: document.getElementById('pairs-slider'),
            pairsValue: document.getElementById('pairs-value'),
            pairsContainer: document.getElementById('pairs-container'),
            generateBtn: document.getElementById('generate-btn'),
            generateInfo: document.getElementById('generate-info'),
            resultsSection: document.getElementById('results-section'),
            videosGrid: document.getElementById('videos-grid')
        };

        // Initialize
        function init() {
            initializePairs();
            setupEventListeners();
            renderPairs();
            updateUI();
        }

        function setupEventListeners() {
            // Quality buttons
            elements.qualityButtons.querySelectorAll('.toggle-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    elements.qualityButtons.querySelectorAll('.toggle-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.quality = btn.dataset.value;
                    updateUI();
                });
            });

            // Duration slider
            elements.durationSlider.addEventListener('input', () => {
                state.duration = elements.durationSlider.value;
                elements.durationValue.textContent = `${state.duration}s`;
                updateUI();
            });

            // Aspect ratio buttons
            elements.aspectButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    elements.aspectButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.aspectRatio = btn.dataset.value;
                });
            });

            // Pairs slider
            elements.pairsSlider.addEventListener('input', () => {
                state.numPairs = parseInt(elements.pairsSlider.value);
                elements.pairsValue.textContent = state.numPairs * 2;
                initializePairs();
                renderPairs();
                updateUI();
            });

            // Generate button
            elements.generateBtn.addEventListener('click', handleGenerate);

            // Global paste handler
            document.addEventListener('paste', handlePaste);
        }

        function handlePaste(e) {
            const items = e.clipboardData?.items;
            if (!items) return;

            for (const item of items) {
                if (item.type.startsWith('image/')) {
                    e.preventDefault();
                    const file = item.getAsFile();
                    if (file) {
                        // Find first empty frame slot
                        for (let i = 0; i < state.pairs.length; i++) {
                            if (!state.pairs[i].frame) {
                                handleFrameUpload(file, i);
                                log(`üìã Pasted image to pair ${i + 1} frame`);
                                return;
                            }
                        }
                    }
                    break;
                }
            }
        }

        function renderPairs() {
            const totalPairs = state.numPairs * 2;

            let html = '';
            for (let row = 0; row < state.numPairs; row++) {
                html += '<div class="pairs-row">';
                for (let col = 0; col < 2; col++) {
                    const pairIndex = row * 2 + col;
                    const pair = state.pairs[pairIndex] || { frame: null, element: { frontal: null, references: [null, null, null] }, prompt: DEFAULT_PROMPT };

                    html += `
                        <div class="pair-group" data-pair="${pairIndex}">
                            <div class="pair-number">Video ${pairIndex + 1}</div>
                            <div class="pair-inputs">
                                <div class="frame-column">
                                    <div class="frame-slot ${pair.frame ? 'filled' : ''}"
                                         data-pair="${pairIndex}" data-slot="frame">
                                        ${pair.frame ? `
                                            <img src="${pair.frame.url}" alt="Frame">
                                            <button class="remove-btn">&times;</button>
                                        ` : `
                                            <div class="placeholder">
                                                <div class="placeholder-icon">üñºÔ∏è</div>
                                                <div class="placeholder-text">Frame</div>
                                            </div>
                                        `}
                                    </div>
                                    <div class="frame-label">Start + End Frame</div>
                                </div>
                                <div class="element-column">
                                    <div class="element-section">
                                        <div class="element-header">Element (optional)</div>
                                        <div style="font-size: 10px; color: var(--ash-grey); margin-bottom: var(--space-xs);">Reference images should be uploaded in the same order as the rotation.</div>
                                        <div class="element-slots">
                                            <div>
                                                <div class="element-slot ${pair.element.frontal ? 'filled' : ''}"
                                                     data-pair="${pairIndex}" data-slot="frontal">
                                                    ${pair.element.frontal ? `
                                                        <img src="${pair.element.frontal.url}" alt="Frontal">
                                                        <button class="remove-btn">&times;</button>
                                                    ` : `
                                                        <div class="placeholder">
                                                            <div class="placeholder-icon">üë§</div>
                                                            <div class="placeholder-text">Frontal</div>
                                                        </div>
                                                    `}
                                                </div>
                                                <div class="element-slot-label">Frontal</div>
                                            </div>
                                            ${[0, 1, 2].map(refIdx => `
                                                <div>
                                                    <div class="element-slot ${pair.element.references[refIdx] ? 'filled' : ''}"
                                                         data-pair="${pairIndex}" data-slot="ref" data-ref-index="${refIdx}">
                                                        ${pair.element.references[refIdx] ? `
                                                            <img src="${pair.element.references[refIdx].url}" alt="Ref ${refIdx + 1}">
                                                            <button class="remove-btn">&times;</button>
                                                        ` : `
                                                            <div class="placeholder">
                                                                <div class="placeholder-icon">üì∑</div>
                                                                <div class="placeholder-text">Ref ${refIdx + 1}</div>
                                                            </div>
                                                        `}
                                                    </div>
                                                    <div class="element-slot-label">Ref ${refIdx + 1}</div>
                                                </div>
                                            `).join('')}
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <textarea class="pair-prompt" data-pair="${pairIndex}"
                                placeholder="Describe the 360 motion...">${pair.prompt}</textarea>
                            <input type="file" class="file-input" data-pair="${pairIndex}" accept="image/*">
                        </div>
                    `;
                }
                html += '</div>';
            }

            elements.pairsContainer.innerHTML = html;

            // Attach event listeners
            // Frame slots
            document.querySelectorAll('.frame-slot').forEach(slot => {
                const pairIndex = parseInt(slot.dataset.pair);
                slot.addEventListener('click', (e) => {
                    if (e.target.classList.contains('remove-btn')) {
                        state.pairs[pairIndex].frame = null;
                        renderPairs();
                        updateUI();
                    } else if (!slot.classList.contains('filled')) {
                        openFilePicker(pairIndex, 'frame');
                    }
                });
                slot.addEventListener('dragover', (e) => e.preventDefault());
                slot.addEventListener('drop', (e) => {
                    e.preventDefault();
                    const file = e.dataTransfer.files[0];
                    if (file && file.type.startsWith('image/')) handleFrameUpload(file, pairIndex);
                });
            });

            // Element slots
            document.querySelectorAll('.element-slot').forEach(slot => {
                const pairIndex = parseInt(slot.dataset.pair);
                const slotType = slot.dataset.slot;
                const refIndex = parseInt(slot.dataset.refIndex);

                slot.addEventListener('click', (e) => {
                    if (e.target.classList.contains('remove-btn')) {
                        if (slotType === 'frontal') {
                            state.pairs[pairIndex].element.frontal = null;
                        } else {
                            state.pairs[pairIndex].element.references[refIndex] = null;
                        }
                        renderPairs();
                        updateUI();
                    } else if (!slot.classList.contains('filled')) {
                        openFilePicker(pairIndex, slotType, refIndex);
                    }
                });
                slot.addEventListener('dragover', (e) => e.preventDefault());
                slot.addEventListener('drop', (e) => {
                    e.preventDefault();
                    const file = e.dataTransfer.files[0];
                    if (file && file.type.startsWith('image/')) {
                        handleElementUpload(file, pairIndex, slotType, refIndex);
                    }
                });
            });

            // File input handlers
            document.querySelectorAll('.file-input').forEach(input => {
                input.addEventListener('change', (e) => {
                    const pairIndex = parseInt(input.dataset.pair);
                    const targetSlot = input.dataset.targetSlot;
                    const targetRefIndex = parseInt(input.dataset.targetRefIndex);
                    const file = e.target.files[0];
                    if (!file) return;

                    if (targetSlot === 'frame') {
                        handleFrameUpload(file, pairIndex);
                    } else if (targetSlot === 'frontal') {
                        handleElementUpload(file, pairIndex, 'frontal');
                    } else {
                        handleElementUpload(file, pairIndex, 'ref', targetRefIndex);
                    }
                    e.target.value = '';
                });
            });

            // Prompt textarea handlers
            document.querySelectorAll('.pair-prompt').forEach(textarea => {
                textarea.addEventListener('input', (e) => {
                    const pairIndex = parseInt(textarea.dataset.pair);
                    state.pairs[pairIndex].prompt = e.target.value;
                    updateUI();
                });
            });
        }

        function openFilePicker(pairIndex, slotType, refIndex) {
            const input = document.querySelector(`.file-input[data-pair="${pairIndex}"]`);
            input.dataset.targetSlot = slotType;
            input.dataset.targetRefIndex = refIndex !== undefined ? refIndex : '';
            input.click();
        }

        // Compress image
        async function compressImage(dataUrl, maxSizeBytes = 9 * 1024 * 1024) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    let width = img.width;
                    let height = img.height;

                    const maxDimension = 2048;
                    if (width > maxDimension || height > maxDimension) {
                        const scale = maxDimension / Math.max(width, height);
                        width = Math.round(width * scale);
                        height = Math.round(height * scale);
                    }

                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);

                    let quality = 0.92;
                    let result = canvas.toDataURL('image/jpeg', quality);

                    while (result.length > maxSizeBytes * 1.37 && quality > 0.3) {
                        quality -= 0.1;
                        result = canvas.toDataURL('image/jpeg', quality);
                    }

                    log(`üì¶ Compressed image: ${(result.length / 1024 / 1024).toFixed(2)}MB at quality ${quality.toFixed(1)}`);
                    resolve(result);
                };
                img.src = dataUrl;
            });
        }

        async function processImageUpload(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    let dataUrl = e.target.result;
                    if (dataUrl.length > 8 * 1024 * 1024) {
                        log(`üîÑ Image too large (${(dataUrl.length / 1024 / 1024).toFixed(2)}MB), compressing...`);
                        dataUrl = await compressImage(dataUrl);
                    }
                    resolve({ file, url: dataUrl });
                };
                reader.readAsDataURL(file);
            });
        }

        async function handleFrameUpload(file, pairIndex) {
            if (!file) return;
            const imageData = await processImageUpload(file);
            state.pairs[pairIndex].frame = imageData;
            log(`üì∑ Uploaded frame for pair ${pairIndex + 1}`);
            renderPairs();
            updateUI();
        }

        async function handleElementUpload(file, pairIndex, slotType, refIndex) {
            if (!file) return;
            const imageData = await processImageUpload(file);
            if (slotType === 'frontal') {
                state.pairs[pairIndex].element.frontal = imageData;
                log(`üë§ Uploaded frontal for pair ${pairIndex + 1}`);
            } else {
                state.pairs[pairIndex].element.references[refIndex] = imageData;
                log(`üì∑ Uploaded ref ${refIndex + 1} for pair ${pairIndex + 1}`);
            }
            renderPairs();
            updateUI();
        }

        function updateUI() {
            const validPairs = state.pairs.filter(p => p.frame);
            elements.generateBtn.disabled = validPairs.length === 0;

            if (validPairs.length === 0) {
                elements.generateInfo.textContent = 'Upload images to generate videos';
            } else {
                const qualityLabel = state.quality === 'pro' ? 'Pro' : 'Standard';
                const costPerVideo = calculateVideoCost();
                const totalCost = (costPerVideo * validPairs.length).toFixed(2);
                elements.generateInfo.textContent = `Ref-to-Video ${qualityLabel} ‚Ä¢ ${state.duration}s ‚Ä¢ ${validPairs.length} video${validPairs.length > 1 ? 's' : ''} ‚Ä¢ $${totalCost}`;
            }
        }

        async function handleGenerate() {
            const validPairs = state.pairs
                .map((p, i) => ({ ...p, index: i }))
                .filter(p => p.frame);

            if (validPairs.length === 0) return;

            log(`üöÄ Starting generation for ${validPairs.length} video(s)`);
            const totalStart = performance.now();

            state.batchCounter++;
            const currentBatch = state.batchCounter;
            elements.generateBtn.disabled = true;

            const costPerVideo = calculateVideoCost();

            // Show results section
            elements.resultsSection.classList.add('visible');

            // Create batch divider
            const now = new Date();
            const timeStr = now.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
            const batchDivider = document.createElement('div');
            batchDivider.className = 'batch-divider';
            batchDivider.textContent = `Batch ${currentBatch} ‚Ä¢ ${timeStr}`;

            // Create placeholder cards
            const placeholderCards = validPairs.map((pair) => {
                const card = document.createElement('div');
                card.className = 'video-card generating';
                card.id = `video-card-${currentBatch}-${pair.index}`;
                card.innerHTML = `
                    <div class="generating-overlay">
                        <div class="generating-spinner"></div>
                        <div class="generating-text">Preparing...</div>
                    </div>
                    <video style="aspect-ratio: 16/9;"></video>
                    <div class="video-card-footer">
                        <div class="video-card-info">
                            <div class="video-card-pair">Video ${pair.index + 1} <span style="opacity:0.6">(${state.quality.toUpperCase()})</span></div>
                            <span class="video-card-prompt" title="${pair.prompt || ''}">${pair.prompt || 'No prompt'}</span>
                        </div>
                        <span class="video-card-cost">$${costPerVideo.toFixed(2)}</span>
                        <button class="btn btn--sm" disabled>Download</button>
                    </div>
                `;
                return card;
            });

            // Insert at the beginning of the grid
            const firstChild = elements.videosGrid.firstChild;
            placeholderCards.reverse().forEach(card => {
                elements.videosGrid.insertBefore(card, firstChild);
            });
            elements.videosGrid.insertBefore(batchDivider, firstChild);

            // Process all pairs in parallel
            const generatePromises = validPairs.map(async (pair) => {
                const pairStart = performance.now();
                const card = document.getElementById(`video-card-${currentBatch}-${pair.index}`);
                const statusText = card?.querySelector('.generating-text');

                try {
                    // Step 1: Upload frame image
                    if (statusText) statusText.textContent = 'Uploading frame...';
                    log(`[Video ${pair.index + 1}] Uploading frame...`);

                    const uploadStart = performance.now();
                    const frameResult = await api.uploadBase64(pair.frame.url);
                    const frameUrl = frameResult.url;

                    const uploadElapsed = ((performance.now() - uploadStart) / 1000).toFixed(2);
                    log(`[Video ${pair.index + 1}] Frame uploaded (${uploadElapsed}s)`);

                    // Step 2: Upload element images if provided
                    let elementData = null;
                    const hasFrontal = pair.element.frontal;

                    if (hasFrontal) {
                        if (statusText) statusText.textContent = 'Uploading element...';
                        log(`[Video ${pair.index + 1}] Uploading element images...`);

                        const frontalResult = await api.uploadBase64(pair.element.frontal.url);
                        const refUrls = [];

                        for (const ref of pair.element.references) {
                            if (ref) {
                                const refResult = await api.uploadBase64(ref.url);
                                refUrls.push(refResult.url);
                            }
                        }

                        elementData = {
                            frontal_image_url: frontalResult.url,
                            reference_image_urls: refUrls
                        };

                        log(`[Video ${pair.index + 1}] Element uploaded (frontal + ${refUrls.length} refs)`);
                    }

                    // Step 3: Generate video
                    if (statusText) statusText.textContent = 'Generating...';
                    const finalPrompt = pair.prompt.trim() || DEFAULT_PROMPT;
                    log(`[Video ${pair.index + 1}] Starting generation with prompt: "${finalPrompt.substring(0, 60)}..."`);

                    const genStart = performance.now();

                    const params = {
                        prompt: finalPrompt,
                        start_image_url: frameUrl,
                        end_image_url: frameUrl,
                        duration: state.duration,
                        aspect_ratio: state.aspectRatio,
                        quality: state.quality,
                        falKey: api.getFalKey()
                    };

                    if (elementData) {
                        params.elements = [elementData];
                    }

                    const response = await fetch('/api/video-360', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(params)
                    });

                    const data = await response.json();

                    if (!response.ok) {
                        throw new Error(data.error || 'Video generation failed');
                    }

                    const videoUrl = data.video?.url || data.url;
                    const genElapsed = ((performance.now() - genStart) / 1000).toFixed(2);
                    const totalElapsed = ((performance.now() - pairStart) / 1000).toFixed(2);

                    log(`[Video ${pair.index + 1}] ‚úÖ Generation complete (gen: ${genElapsed}s, total: ${totalElapsed}s)`);

                    if (videoUrl && card) {
                        card.classList.remove('generating');
                        const overlay = card.querySelector('.generating-overlay');
                        if (overlay) overlay.remove();

                        const video = card.querySelector('video');
                        video.src = videoUrl;
                        video.controls = true;
                        video.loop = true;

                        const downloadBtn = card.querySelector('.btn');
                        downloadBtn.disabled = false;
                        downloadBtn.onclick = () => {
                            const dur = `${state.duration}s`;
                            const ar = state.aspectRatio.replace(':', '-');
                            const promptSlug = (finalPrompt || '').toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_|_$/g, '').substring(0, 40);
                            downloadFile(videoUrl, `kling_ref_3_0_${state.quality}_${dur}_${ar}_${promptSlug}_video_${pair.index + 1}.mp4`);
                        };

                        state.results.push({ url: videoUrl, prompt: finalPrompt, pairIndex: pair.index });
                    }

                } catch (error) {
                    const totalElapsed = ((performance.now() - pairStart) / 1000).toFixed(2);
                    log(`[Video ${pair.index + 1}] ‚ùå Failed after ${totalElapsed}s:`, error.message);

                    if (card) {
                        card.classList.remove('generating');
                        const overlay = card.querySelector('.generating-overlay');
                        if (overlay) {
                            overlay.innerHTML = `<div class="generating-text" style="color: #dc2626;">Failed: ${error.message}</div>`;
                        }
                    }
                }
            });

            await Promise.all(generatePromises);

            const totalElapsed = ((performance.now() - totalStart) / 1000).toFixed(2);
            log(`üèÅ All generations complete! Total time: ${totalElapsed}s`);

            elements.generateBtn.disabled = false;
        }

        // Initialize
        init();
    </script>
</body>
</html>
