<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SocialSet v2</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ“±</text></svg>">
    <link rel="stylesheet" href="/shared/css/tokens.css">
    <link rel="stylesheet" href="/shared/css/base.css">
    <link rel="stylesheet" href="/shared/css/components.css">
    <style>
        .container {
            max-width: 1200px;
        }

        /* Mode Tabs - Main navigation */
        .mode-tabs {
            display: flex;
            gap: 0;
            margin-bottom: var(--space-lg);
            border-bottom: 2px solid var(--gainsboro);
        }

        .mode-tab {
            padding: 14px 32px;
            font-size: var(--text-md);
            font-weight: 600;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            color: var(--slate);
            cursor: pointer;
            transition: all var(--transition-fast);
            margin-bottom: -2px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .mode-tab:hover {
            color: var(--jet);
        }

        .mode-tab.active {
            color: var(--jet);
            border-bottom-color: var(--jet);
        }

        /* Section styling */
        .section {
            background: var(--white);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-md);
            padding: var(--space-md);
            margin-bottom: var(--space-md);
        }

        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--space-sm);
        }

        .section-title {
            font-size: var(--text-sm);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--carbon);
        }

        .section-badge {
            font-size: var(--text-2xs);
            padding: 2px 8px;
            border-radius: var(--radius-sm);
            background: var(--off-white);
            color: var(--slate);
        }

        .section-badge.required {
            background: var(--jet);
            color: var(--white);
        }

        .section-hint {
            font-size: var(--text-xs);
            color: var(--ash-grey);
            margin-top: var(--space-xs);
        }

        /* Talent Grid - 12 columns x 2 rows */
        .talent-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: var(--space-xs);
        }

        @media (min-width: 800px) {
            .talent-grid {
                grid-template-columns: repeat(12, 1fr);
            }
        }

        .talent-card {
            position: relative;
            aspect-ratio: 3/4;
            border-radius: var(--radius-sm);
            overflow: hidden;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all var(--transition-fast);
        }

        .talent-card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .talent-card:hover {
            border-color: var(--ash-grey);
        }

        .talent-card.selected {
            border-color: var(--jet);
        }

        .talent-card.selected::after {
            content: attr(data-badge);
            position: absolute;
            top: 4px;
            right: 4px;
            min-width: 20px;
            height: 20px;
            padding: 0 4px;
            background: var(--jet);
            color: var(--white);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 600;
        }

        .talent-card.hero {
            border-color: #dc2626;
        }

        .talent-card.hero::after {
            content: 'HERO';
            background: #dc2626;
        }

        .talent-card.supporting {
            border-color: #2563eb;
        }

        .talent-card.supporting::after {
            content: '+';
            background: #2563eb;
        }

        .talent-card.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* Mood Board Grid */
        .moodboard-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: var(--space-xs);
        }

        @media (min-width: 800px) {
            .moodboard-grid {
                grid-template-columns: repeat(12, 1fr);
            }
        }

        .upload-slot {
            aspect-ratio: 3/4;
            border: 1px dashed var(--gainsboro);
            border-radius: var(--radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            background: var(--off-white);
            transition: all var(--transition-fast);
        }

        .upload-slot:hover {
            border-color: var(--ash-grey);
        }

        .upload-slot.filled {
            border-style: solid;
            border-color: transparent;
        }

        .upload-slot.filled img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .upload-slot .plus {
            font-size: 18px;
            font-weight: 300;
            color: var(--ash-grey);
        }

        .upload-slot .remove-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 20px;
            height: 20px;
            background: rgba(0,0,0,0.7);
            color: var(--white);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 12px;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .upload-slot.filled:hover .remove-btn {
            display: flex;
        }

        .upload-slot.deselected {
            opacity: 0.4;
        }

        .upload-slot.deselected img {
            filter: grayscale(100%);
        }

        /* Style input */
        .style-input-container {
            margin-top: var(--space-sm);
            display: flex;
            gap: var(--space-sm);
            align-items: stretch;
        }

        .style-input {
            flex: 1;
            padding: 10px 14px;
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-sm);
            font-size: var(--text-sm);
            font-family: inherit;
            resize: none;
            min-height: 40px;
        }

        .style-input:focus {
            outline: none;
            border-color: var(--jet);
        }

        .style-input::placeholder {
            color: var(--ash-grey);
        }

        /* Output Grid */
        .output-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: var(--space-sm);
        }

        @media (min-width: 600px) {
            .output-grid {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        @media (min-width: 900px) {
            .output-grid {
                grid-template-columns: repeat(6, 1fr);
            }
        }

        .output-slot {
            background: var(--white);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-sm);
            padding: var(--space-sm);
            display: flex;
            flex-direction: column;
            gap: var(--space-xs);
        }

        .output-slot.active {
            border-color: var(--ash-grey);
            background: var(--off-white);
        }

        .output-slot-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: var(--text-xs);
            color: var(--slate);
        }

        .output-slot-number {
            font-weight: 600;
        }

        .output-toggle {
            width: 32px;
            height: 18px;
            background: var(--gainsboro);
            border-radius: 9px;
            position: relative;
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .output-toggle.active {
            background: var(--jet);
        }

        .output-toggle::after {
            content: '';
            position: absolute;
            width: 14px;
            height: 14px;
            background: var(--white);
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: all var(--transition-fast);
        }

        .output-toggle.active::after {
            left: 16px;
        }

        .output-pose-select {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-xs);
            font-size: var(--text-xs);
            background: var(--white);
            cursor: pointer;
        }

        .output-pose-select:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .output-people-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: var(--space-xs);
        }

        .output-people-label {
            font-size: var(--text-xs);
            color: var(--slate);
        }

        .output-people-controls {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .output-people-btn {
            width: 22px;
            height: 22px;
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-xs);
            background: var(--white);
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--transition-fast);
        }

        .output-people-btn:hover:not(:disabled) {
            border-color: var(--jet);
        }

        .output-people-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .output-people-count {
            min-width: 20px;
            text-align: center;
            font-size: var(--text-sm);
            font-weight: 600;
        }

        /* Drag hover state */
        .moodboard-grid.drag-over {
            background: rgba(0, 0, 0, 0.03);
            border-radius: var(--radius-md);
        }

        .moodboard-grid.drag-over .upload-slot:not(.filled) {
            border-color: var(--jet);
            background: rgba(0, 0, 0, 0.05);
        }

        /* Inline loader */
        .inline-loader {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: var(--space-lg);
            background: var(--off-white);
            border-radius: var(--radius-md);
            margin-bottom: var(--space-md);
        }

        .inline-loader.visible {
            display: flex;
        }

        .loader-message {
            font-size: var(--text-lg);
            font-weight: 600;
            background: linear-gradient(90deg,
                rgba(0, 47, 167, 0.4) 0%,
                rgba(0, 47, 167, 1) 50%,
                rgba(0, 47, 167, 0.4) 100%);
            background-size: 200% 100%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: sweep 2s ease-in-out infinite;
        }

        .loader-message.fade-out {
            animation: fade-out 0.25s ease-out forwards;
        }

        .loader-message.fade-in {
            animation: fade-in 0.25s ease-out forwards, sweep 2s ease-in-out infinite;
        }

        @keyframes sweep {
            0% { background-position: 100% 0; }
            100% { background-position: -100% 0; }
        }

        @keyframes fade-out {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        @keyframes fade-in {
            0% { opacity: 0; }
            100% { opacity: 1; }
        }

        .loader-progress {
            font-size: var(--text-sm);
            color: var(--slate);
            margin-top: var(--space-xs);
        }

        /* Actions row */
        .actions-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--space-md);
            background: var(--white);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-md);
            margin-bottom: var(--space-md);
            flex-wrap: wrap;
            gap: var(--space-sm);
        }

        .settings-row {
            display: flex;
            align-items: center;
            gap: var(--space-lg);
            flex-wrap: wrap;
        }

        .setting-group {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }

        .setting-label {
            font-size: var(--text-xs);
            color: var(--slate);
            font-weight: 500;
        }

        .aspect-buttons {
            display: flex;
            gap: 4px;
        }

        .aspect-btn {
            padding: 6px 12px;
            font-size: var(--text-xs);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-sm);
            background: var(--off-white);
            color: var(--slate);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .aspect-btn:hover {
            border-color: var(--ash-grey);
        }

        .aspect-btn.active {
            background: var(--jet);
            color: var(--white);
            border-color: var(--jet);
        }

        .action-buttons {
            display: flex;
            gap: var(--space-sm);
        }

        .action-btn {
            padding: 12px 24px;
            font-size: 14px;
            min-width: 160px;
            text-align: center;
        }

        .btn.analyzed {
            background: #22c55e;
            border-color: #22c55e;
            color: var(--white);
        }

        .btn.analyzed:hover {
            background: #16a34a;
            border-color: #16a34a;
        }

        /* Results section */
        .results-section {
            display: none;
            margin-left: calc(-50vw + 50%);
            margin-right: calc(-50vw + 50%);
            padding-left: var(--space-lg);
            padding-right: var(--space-lg);
            max-width: 100vw;
        }

        .results-section.visible {
            display: block;
        }

        .results-header {
            max-width: 1200px;
            margin: 0 auto var(--space-md);
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: var(--space-md);
            max-width: 1400px;
            margin: 0 auto;
        }

        @media (min-width: 900px) {
            .results-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        .result-card {
            cursor: pointer;
            border-radius: var(--radius-md);
            overflow: hidden;
            transition: transform var(--transition-fast);
        }

        .result-card:hover {
            transform: scale(1.02);
        }

        .result-card img {
            width: 100%;
            aspect-ratio: 3/4;
            object-fit: cover;
        }

        /* Progress section */
        .progress-section {
            display: none;
            margin-bottom: var(--space-md);
        }

        .progress-section.visible {
            display: block;
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: var(--space-xs);
        }

        .progress-title {
            font-size: var(--text-xs);
            font-weight: 600;
            text-transform: uppercase;
            color: var(--slate);
        }

        .progress-count {
            font-size: var(--text-sm);
            font-weight: 600;
        }

        .progress-bar-container {
            height: 6px;
            background: var(--off-white);
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: var(--jet);
            border-radius: 3px;
            transition: width 0.3s ease;
            width: 0%;
        }

        input[type="file"] {
            display: none;
        }

        /* Style Toggle Row */
        .style-toggle-row {
            display: flex;
            align-items: center;
            gap: var(--space-md);
            padding: var(--space-sm) var(--space-md);
            background: var(--off-white);
            border-radius: var(--radius-md);
            margin-bottom: var(--space-md);
        }

        .style-toggle-row.hidden {
            display: none;
        }

        .style-toggle-label {
            font-size: var(--text-sm);
            font-weight: 500;
            color: var(--carbon);
        }

        .style-toggle-buttons {
            display: flex;
            gap: 4px;
        }

        .style-toggle-btn {
            padding: 8px 16px;
            font-size: var(--text-sm);
            font-weight: 500;
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-sm);
            background: var(--white);
            color: var(--slate);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .style-toggle-btn:hover {
            border-color: var(--ash-grey);
        }

        .style-toggle-btn.active {
            background: var(--jet);
            color: var(--white);
            border-color: var(--jet);
        }

        .style-toggle-hint {
            font-size: var(--text-xs);
            color: var(--ash-grey);
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="hero">
            <h1>SocialSet</h1>
            <p class="hero-subtitle">Generate Instagram content for E-commerce, Campaigns, and Casting</p>
        </div>

        <!-- Mode Tabs -->
        <div class="mode-tabs">
            <button class="mode-tab active" data-mode="ecommerce">E-commerce</button>
            <button class="mode-tab" data-mode="campaign">Campaign</button>
            <button class="mode-tab" data-mode="casting">Casting</button>
        </div>

        <!-- E-commerce Style Toggle (only visible in e-commerce mode) -->
        <div class="style-toggle-row" id="style-toggle-row">
            <span class="style-toggle-label">E-commerce Style:</span>
            <div class="style-toggle-buttons">
                <button class="style-toggle-btn" data-style="classic">Classic</button>
                <button class="style-toggle-btn active" data-style="editorial">Editorial</button>
            </div>
            <span class="style-toggle-hint" id="style-toggle-hint">Subtle body language, natural poses</span>
        </div>

        <!-- Section 1: Talent Selection -->
        <div class="section">
            <div class="section-header">
                <span class="section-title">1. Select Talent</span>
                <span class="section-badge required">Required</span>
            </div>
            <div class="talent-grid" id="talent-grid"></div>
            <p class="section-hint" id="talent-hint">Select up to 4 models. Selected: <span id="talent-count">0</span>/4</p>
        </div>

        <!-- Section 2: Mood Board -->
        <div class="section">
            <div class="section-header">
                <span class="section-title">2. Mood Board</span>
                <span class="section-badge required">Required</span>
                <button class="btn btn--sm" id="clear-moodboard" style="margin-left: auto; font-size: 11px; padding: 4px 10px;">Clear All</button>
            </div>
            <div class="moodboard-grid" id="moodboard-grid"></div>
            <input type="file" id="moodboard-input" accept="image/*" multiple>

            <!-- Style Input -->
            <div class="style-input-container">
                <textarea class="style-input" id="style-input" placeholder="Add style directions (e.g., 'more minimal', 'all red', 'athletic wear', 'oversized silhouettes')..." rows="2"></textarea>
            </div>
        </div>

        <!-- Section 3: Output Configuration -->
        <div class="section">
            <div class="section-header">
                <span class="section-title">3. Output Configuration</span>
                <span class="section-badge required">Required</span>
            </div>
            <p class="section-hint" style="margin-bottom: var(--space-sm);" id="output-hint">Toggle slots on/off. Select pose and number of people per image.</p>
            <div class="output-grid" id="output-grid"></div>
        </div>

        <!-- Inline Loader -->
        <div class="inline-loader" id="inline-loader">
            <div class="loader-message" id="loader-message">Setting up the Studio...</div>
            <div class="loader-progress" id="loader-progress">Preparing...</div>
        </div>

        <!-- Settings & Actions -->
        <div class="actions-row">
            <div class="settings-row">
                <div class="setting-group">
                    <span class="setting-label">Aspect</span>
                    <div class="aspect-buttons" id="aspect-buttons">
                        <button class="aspect-btn" data-ratio="1:1">1:1</button>
                        <button class="aspect-btn active" data-ratio="3:4">3:4</button>
                        <button class="aspect-btn" data-ratio="4:3">4:3</button>
                        <button class="aspect-btn" data-ratio="9:16">9:16</button>
                        <button class="aspect-btn" data-ratio="16:9">16:9</button>
                    </div>
                </div>
                <div class="setting-group">
                    <span class="setting-label">Resolution</span>
                    <div class="aspect-buttons" id="resolution-buttons">
                        <button class="aspect-btn" data-res="1K">1K</button>
                        <button class="aspect-btn active" data-res="2K">2K</button>
                    </div>
                </div>
            </div>
            <div class="action-buttons">
                <button class="btn action-btn" id="analyze-btn" disabled>Analyze Mood Board</button>
                <button class="btn btn--primary action-btn" id="generate-btn" disabled>
                    <span id="generate-btn-text">Generate 0 images</span>
                </button>
            </div>
        </div>

        <!-- Progress -->
        <div class="progress-section" id="progress-section">
            <div class="progress-header">
                <span class="progress-title">Generating</span>
                <span class="progress-count" id="progress-count">0 / 0</span>
            </div>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
        </div>

        <!-- Results -->
        <div class="results-section" id="results-section">
            <div class="results-header">
                <h2>Results</h2>
            </div>
            <div class="results-grid" id="results-grid"></div>
        </div>
    </div>

    <!-- Lightbox -->
    <div class="lightbox" id="lightbox">
        <div class="lightbox-content">
            <button class="lightbox-close" id="lightbox-close">&times;</button>
            <div class="lightbox-left">
                <img src="" alt="" class="lightbox-image" id="lightbox-image">
            </div>
            <div class="lightbox-right">
                <div class="lightbox-section">
                    <h3 class="lightbox-section-title">Type</h3>
                    <p class="lightbox-model-text" id="lightbox-type"></p>
                </div>
                <div class="lightbox-section">
                    <h3 class="lightbox-section-title">Pose</h3>
                    <p id="lightbox-pose"></p>
                </div>
                <div class="lightbox-section">
                    <h3 class="lightbox-section-title">Prompt</h3>
                    <p class="lightbox-prompt-text" id="lightbox-prompt"></p>
                </div>
                <button class="lightbox-download" id="lightbox-download">Download Image</button>
            </div>
        </div>
    </div>

    <!-- Shared JS -->
    <script src="/shared/js/utils.js"></script>
    <script src="/shared/js/api.js"></script>
    <script src="poses.js"></script>
    <script src="pose-pools.js"></script>

    <script>
        // Setset Talent Library (with gender for outfit assignment)
        const TALENT = [
            { id: 'james', name: 'James Wilson', gender: 'male', image: '/shared/images/talent/talent-01_JamesWilson.png' },
            { id: 'maya', name: 'Maya Johnson', gender: 'female', image: '/shared/images/talent/talent-02_MayaJohnson.png' },
            { id: 'river', name: 'River Blake', gender: 'male', image: '/shared/images/talent/talent-03_RiverBlake.png' },
            { id: 'emma', name: 'Emma Sullivan', gender: 'female', image: '/shared/images/talent/talent-04_EmmaSullivan.png' },
            { id: 'marcus', name: 'Marcus Brown', gender: 'male', image: '/shared/images/talent/talent-05_MarcusBrown.png' },
            { id: 'zara', name: 'Zara Mitchell', gender: 'female', image: '/shared/images/talent/talent-06_ZaraMitchell.png' },
            { id: 'sophia', name: 'Sophia Anderson', gender: 'female', image: '/shared/images/talent/talent-07_SophiaAnderson.png' },
            { id: 'liam', name: 'Liam Garcia', gender: 'male', image: '/shared/images/talent/talent-08_LiamGarcia.png' },
            { id: 'nina', name: 'Nina Davis', gender: 'female', image: '/shared/images/talent/talent-09_NinaDavis.png' },
            { id: 'ava', name: 'Ava Martinez', gender: 'female', image: '/shared/images/talent/talent-10_AvaMartinez.png' },
            { id: 'luna', name: 'Luna Park', gender: 'female', image: '/shared/images/talent/talent-11_LunaPark.png' },
            { id: 'noah', name: 'Noah Chen', gender: 'male', image: '/shared/images/talent/talent-12_NoahChen.png' },
            { id: 'kai', name: 'Kai Thompson', gender: 'male', image: '/shared/images/talent/talent-13_KaiThompson.png' },
            { id: 'riley', name: 'Riley Morgan', gender: 'female', image: '/shared/images/talent/talent-14_RileyMorgan.png' },
            { id: 'jordan', name: 'Jordan Lee', gender: 'female', image: '/shared/images/talent/talent-15_JordanLee.png' },
            { id: 'isabella', name: 'Isabella Rodriguez', gender: 'female', image: '/shared/images/talent/talent-16_IsabellaRodriguez.png' },
            { id: 'quinn', name: 'Quinn Santos', gender: 'female', image: '/shared/images/talent/talent-17_QuinnSantos.png' },
            { id: 'casey', name: 'Casey White', gender: 'female', image: '/shared/images/talent/talent-18_CaseyWhite.png' },
            { id: 'sam', name: 'Sam Wilson', gender: 'male', image: '/shared/images/talent/talent-19_SamWilson.png' },
            { id: 'drew', name: 'Drew Martinez', gender: 'male', image: '/shared/images/talent/talent-20_DrewMartinez.png' },
            { id: 'avery', name: 'Avery Taylor', gender: 'female', image: '/shared/images/talent/talent-21_AveryTaylor.png' },
            { id: 'parker', name: 'Parker Miller', gender: 'male', image: '/shared/images/talent/talent-22_ParkerMiller.png' },
            { id: 'morgan', name: 'Morgan Kim', gender: 'female', image: '/shared/images/talent/talent-23_MorganKim.png' },
            { id: 'andre', name: 'Andre Jackson', gender: 'male', image: '/shared/images/talent/talent-24_AndreJackson.png' },
            { id: 'damon', name: 'Damon Carter', gender: 'male', image: '/shared/images/talent/talent-25_DamonCarter.png' },
            { id: 'nikolai', name: 'Nikolai Volkov', gender: 'male', image: '/shared/images/talent/talent-26_NikolaiVolkov.png' },
            { id: 'sofia', name: 'Sofia Rodriguez', gender: 'female', image: '/shared/images/talent/talent-27_SofiaRodriguez.png' },
            { id: 'finn', name: 'Finn O\'Connor', gender: 'male', image: '/shared/images/talent/talent-28_FinnOConnor.png' },
            { id: 'clara', name: 'Clara Devereaux', gender: 'female', image: '/shared/images/talent/talent-29_ClaraDevereaux.png' },
            { id: 'zoe', name: 'Zoe Washington', gender: 'female', image: '/shared/images/talent/talent-30_ZoeWashington.png' }
        ];

        // Studio loading messages
        const STUDIO_MESSAGES = [
            "Setting up the Studio...",
            "Adjusting the Key Light...",
            "Loading the Film...",
            "Warming up the Strobes...",
            "Preparing the Backdrop...",
            "Adjusting the Fill Light...",
            "Checking the Framing...",
            "Setting the Aperture...",
            "Loading Color Profiles...",
            "Positioning the C-Stand...",
            "Focusing...",
            "Checking Tethering...",
            "Rolling...",
            "Adjusting the Umbrella...",
            "Metering...",
            "Standby...",
            "Loading the Presets...",
            "Quiet on Set...",
            "Final Touches...",
            "Almost There..."
        ];

        // State
        const state = {
            mode: 'ecommerce',  // 'ecommerce', 'campaign', 'casting'
            ecommerceStyle: 'editorial',  // 'classic' or 'editorial' (default to editorial)

            // Talent selection
            selectedTalent: [],      // For ecommerce/campaign: array of IDs
            heroTalent: null,        // For casting: single hero ID
            supportingTalent: [],    // For casting: array of supporting IDs

            // Mood board
            moodboardImages: new Array(24).fill(null),
            styleInput: '',
            analysis: null,

            // Outfit pools - generated during analyze step
            outfits: {
                female: [],  // Array of outfit descriptions for female talent
                male: [],    // Array of outfit descriptions for male talent
                usedFemale: 0,  // Counter for assigning unique outfits
                usedMale: 0
            },

            // Output configuration - 12 slots
            outputs: new Array(12).fill(null).map(() => ({
                enabled: false,
                poseId: 'pose-pdp-front',
                peopleCount: 1
            })),

            // Settings
            aspectRatio: '3:4',
            resolution: '2K',

            // Results
            results: [],
            lightboxIndex: 0
        };

        // DOM Elements
        const elements = {
            modeTabs: document.querySelectorAll('.mode-tab'),
            styleToggleRow: document.getElementById('style-toggle-row'),
            styleToggleHint: document.getElementById('style-toggle-hint'),
            talentGrid: document.getElementById('talent-grid'),
            talentCount: document.getElementById('talent-count'),
            talentHint: document.getElementById('talent-hint'),
            moodboardGrid: document.getElementById('moodboard-grid'),
            moodboardInput: document.getElementById('moodboard-input'),
            clearMoodboard: document.getElementById('clear-moodboard'),
            styleInput: document.getElementById('style-input'),
            outputGrid: document.getElementById('output-grid'),
            outputHint: document.getElementById('output-hint'),
            aspectButtons: document.getElementById('aspect-buttons'),
            analyzeBtn: document.getElementById('analyze-btn'),
            generateBtn: document.getElementById('generate-btn'),
            generateBtnText: document.getElementById('generate-btn-text'),
            inlineLoader: document.getElementById('inline-loader'),
            loaderMessage: document.getElementById('loader-message'),
            loaderProgress: document.getElementById('loader-progress'),
            progressSection: document.getElementById('progress-section'),
            progressCount: document.getElementById('progress-count'),
            progressBar: document.getElementById('progress-bar'),
            resultsSection: document.getElementById('results-section'),
            resultsGrid: document.getElementById('results-grid'),
            lightbox: document.getElementById('lightbox'),
            lightboxImage: document.getElementById('lightbox-image'),
            lightboxType: document.getElementById('lightbox-type'),
            lightboxPose: document.getElementById('lightbox-pose'),
            lightboxPrompt: document.getElementById('lightbox-prompt')
        };

        let loadingInterval = null;
        let lastMessageIndex = -1;

        // Initialize
        function init() {
            renderTalentGrid();
            renderMoodboardGrid();
            renderOutputGrid();
            setupEventListeners();
            updateUI();
        }

        // Render Talent Grid
        function renderTalentGrid() {
            const isCasting = state.mode === 'casting';

            elements.talentGrid.innerHTML = TALENT.map(talent => {
                let classes = 'talent-card';
                let badge = '';
                let isDisabled = false;

                if (isCasting) {
                    if (state.heroTalent === talent.id) {
                        classes += ' hero';
                    } else if (state.supportingTalent.includes(talent.id)) {
                        classes += ' supporting';
                    } else if (state.supportingTalent.length >= 3 && !state.heroTalent) {
                        isDisabled = true;
                    }
                } else {
                    if (state.selectedTalent.includes(talent.id)) {
                        classes += ' selected';
                        badge = 'âœ“';
                    } else if (state.selectedTalent.length >= 8) {
                        isDisabled = true;
                    }
                }

                if (isDisabled) classes += ' disabled';

                return `
                    <div class="${classes}" data-id="${talent.id}" data-badge="${badge}" title="${talent.name}">
                        <img src="${talent.image}" alt="${talent.name}">
                    </div>
                `;
            }).join('');

            // Add click handlers
            elements.talentGrid.querySelectorAll('.talent-card').forEach(card => {
                card.addEventListener('click', () => handleTalentClick(card.dataset.id));
            });

            // Update hint and count
            if (isCasting) {
                const heroText = state.heroTalent ? '1 hero' : '0 hero';
                const supportText = `${state.supportingTalent.length} supporting`;
                elements.talentHint.innerHTML = `Click once for HERO (required), click again for supporting. ${heroText}, ${supportText}`;
                elements.talentCount.textContent = state.heroTalent ? '1' : '0';
            } else {
                elements.talentHint.innerHTML = `Select up to 8 models. Selected: <span id="talent-count">${state.selectedTalent.length}</span>/8`;
                elements.talentCount.textContent = state.selectedTalent.length;
            }
        }

        // Handle talent click
        function handleTalentClick(talentId) {
            const isCasting = state.mode === 'casting';

            if (isCasting) {
                // Casting mode: cycle through none -> hero -> supporting -> none
                if (state.heroTalent === talentId) {
                    // Hero -> Supporting
                    state.heroTalent = null;
                    if (state.supportingTalent.length < 3) {
                        state.supportingTalent.push(talentId);
                    }
                } else if (state.supportingTalent.includes(talentId)) {
                    // Supporting -> None
                    state.supportingTalent = state.supportingTalent.filter(id => id !== talentId);
                } else {
                    // None -> Hero (if no hero) or Supporting (if hero exists)
                    if (!state.heroTalent) {
                        state.heroTalent = talentId;
                    } else if (state.supportingTalent.length < 3) {
                        state.supportingTalent.push(talentId);
                    }
                }
            } else {
                // Normal mode: toggle selection
                if (state.selectedTalent.includes(talentId)) {
                    state.selectedTalent = state.selectedTalent.filter(id => id !== talentId);
                } else if (state.selectedTalent.length < 8) {
                    state.selectedTalent.push(talentId);
                }
            }

            renderTalentGrid();
            updateUI();
        }

        // Render Moodboard Grid
        function renderMoodboardGrid() {
            elements.moodboardGrid.innerHTML = state.moodboardImages.map((img, i) => {
                if (img) {
                    return `
                        <div class="upload-slot filled ${img.selected === false ? 'deselected' : ''}" data-index="${i}">
                            <img src="${img.url}" alt="Moodboard ${i + 1}">
                            <button class="remove-btn" data-action="remove">&times;</button>
                        </div>
                    `;
                }
                return `
                    <div class="upload-slot" data-index="${i}">
                        <span class="plus">+</span>
                    </div>
                `;
            }).join('');

            setupMoodboardListeners();
        }

        // Setup moodboard listeners
        function setupMoodboardListeners() {
            elements.moodboardGrid.querySelectorAll('.upload-slot').forEach(slot => {
                const index = parseInt(slot.dataset.index);

                slot.addEventListener('click', (e) => {
                    if (e.target.dataset.action === 'remove') {
                        // Remove and collapse
                        state.moodboardImages[index] = null;
                        const filled = state.moodboardImages.filter(img => img);
                        for (let i = 0; i < 24; i++) {
                            state.moodboardImages[i] = filled[i] || null;
                        }
                        state.analysis = null;
                        elements.analyzeBtn.textContent = 'Analyze Mood Board';
                        elements.analyzeBtn.classList.remove('analyzed');
                        renderMoodboardGrid();
                        updateUI();
                        return;
                    }

                    if (state.moodboardImages[index]) {
                        // Toggle selection
                        state.moodboardImages[index].selected = state.moodboardImages[index].selected === false ? true : false;
                        renderMoodboardGrid();
                        updateUI();
                    } else {
                        // Open file picker
                        elements.moodboardInput.dataset.startIndex = index;
                        elements.moodboardInput.click();
                    }
                });
            });

            // Drag and drop
            elements.moodboardGrid.addEventListener('dragover', (e) => e.preventDefault());
            elements.moodboardGrid.addEventListener('dragenter', () => elements.moodboardGrid.classList.add('drag-over'));
            elements.moodboardGrid.addEventListener('dragleave', (e) => {
                if (!elements.moodboardGrid.contains(e.relatedTarget)) {
                    elements.moodboardGrid.classList.remove('drag-over');
                }
            });
            elements.moodboardGrid.addEventListener('drop', (e) => {
                e.preventDefault();
                elements.moodboardGrid.classList.remove('drag-over');
                const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
                handleFileUpload(files, null);
            });
        }

        // Handle file upload
        function handleFileUpload(files, startIndex) {
            const targetIndices = [];

            if (startIndex !== null) {
                for (let i = 0; i < files.length; i++) {
                    const idx = startIndex + i;
                    if (idx < 24) targetIndices.push(idx);
                }
            } else {
                for (let i = 0; i < files.length; i++) {
                    const emptyIdx = state.moodboardImages.findIndex((img, idx) => !img && !targetIndices.includes(idx));
                    if (emptyIdx !== -1 && emptyIdx < 24) {
                        targetIndices.push(emptyIdx);
                    }
                }
            }

            files.forEach((file, i) => {
                if (i >= targetIndices.length) return;
                const targetIndex = targetIndices[i];

                const reader = new FileReader();
                reader.onload = (e) => {
                    state.moodboardImages[targetIndex] = { file, url: e.target.result, selected: true };
                    state.analysis = null;
                    elements.analyzeBtn.textContent = 'Analyze Mood Board';
                    elements.analyzeBtn.classList.remove('analyzed');
                    renderMoodboardGrid();
                    updateUI();
                };
                reader.readAsDataURL(file);
            });
        }

        // Render Output Grid
        function renderOutputGrid() {
            // Build pose options from poses.js
            const poseOptions = POSES.map(pose =>
                `<option value="${pose.id}">${pose.name}</option>`
            ).join('');

            elements.outputGrid.innerHTML = state.outputs.map((output, i) => {
                const isActive = output.enabled;

                return `
                    <div class="output-slot ${isActive ? 'active' : ''}" data-index="${i}">
                        <div class="output-slot-header">
                            <span class="output-slot-number">#${i + 1}</span>
                            <div class="output-toggle ${isActive ? 'active' : ''}" data-index="${i}"></div>
                        </div>
                        <select class="output-pose-select" data-index="${i}" ${!isActive ? 'disabled' : ''}>
                            ${poseOptions}
                        </select>
                        <div class="output-people-row">
                            <span class="output-people-label">People</span>
                            <div class="output-people-controls">
                                <button class="output-people-btn" data-action="decrease" data-index="${i}" ${!isActive || output.peopleCount <= 0 ? 'disabled' : ''}>âˆ’</button>
                                <span class="output-people-count">${output.peopleCount}</span>
                                <button class="output-people-btn" data-action="increase" data-index="${i}" ${!isActive || output.peopleCount >= 4 ? 'disabled' : ''}>+</button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            // Set initial pose values
            elements.outputGrid.querySelectorAll('.output-pose-select').forEach(select => {
                const index = parseInt(select.dataset.index);
                select.value = state.outputs[index].poseId;
            });

            // Toggle handlers
            elements.outputGrid.querySelectorAll('.output-toggle').forEach(toggle => {
                toggle.addEventListener('click', () => {
                    const index = parseInt(toggle.dataset.index);
                    state.outputs[index].enabled = !state.outputs[index].enabled;
                    renderOutputGrid();
                    updateUI();
                });
            });

            // Pose select handlers
            elements.outputGrid.querySelectorAll('.output-pose-select').forEach(select => {
                select.addEventListener('change', () => {
                    const index = parseInt(select.dataset.index);
                    state.outputs[index].poseId = select.value;
                });
            });

            // People count handlers
            elements.outputGrid.querySelectorAll('.output-people-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const index = parseInt(btn.dataset.index);
                    const action = btn.dataset.action;

                    if (action === 'increase' && state.outputs[index].peopleCount < 4) {
                        state.outputs[index].peopleCount++;
                    } else if (action === 'decrease' && state.outputs[index].peopleCount > 0) {
                        state.outputs[index].peopleCount--;
                    }

                    renderOutputGrid();
                    updateUI();
                });
            });
        }

        // Setup event listeners
        function setupEventListeners() {
            // Mode tabs
            elements.modeTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const newMode = tab.dataset.mode;
                    if (newMode === state.mode) return;

                    // Switch mode
                    state.mode = newMode;

                    // Reset talent selection when switching modes
                    state.selectedTalent = [];
                    state.heroTalent = null;
                    state.supportingTalent = [];

                    // Update tab styling
                    elements.modeTabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');

                    // Show/hide e-commerce style toggle
                    updateStyleToggleVisibility();

                    renderTalentGrid();
                    updateUI();
                });
            });

            // E-commerce style toggle
            document.querySelectorAll('.style-toggle-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.style-toggle-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.ecommerceStyle = btn.dataset.style;

                    // Update hint text
                    if (state.ecommerceStyle === 'classic') {
                        elements.styleToggleHint.textContent = 'Clean, straightforward poses';
                    } else {
                        elements.styleToggleHint.textContent = 'Subtle weight shifts, relaxed hands, natural body language';
                    }
                });
            });

            // File input
            elements.moodboardInput.addEventListener('change', (e) => {
                const startIndex = e.target.dataset.startIndex ? parseInt(e.target.dataset.startIndex) : null;
                handleFileUpload(Array.from(e.target.files), startIndex);
                e.target.value = '';
            });

            // Clear moodboard
            elements.clearMoodboard.addEventListener('click', () => {
                state.moodboardImages = new Array(24).fill(null);
                state.analysis = null;
                elements.analyzeBtn.textContent = 'Analyze Mood Board';
                elements.analyzeBtn.classList.remove('analyzed');
                renderMoodboardGrid();
                updateUI();
            });

            // Style input
            elements.styleInput.addEventListener('input', (e) => {
                state.styleInput = e.target.value;
                // Reset analysis when style input changes
                if (state.analysis) {
                    state.analysis = null;
                    elements.analyzeBtn.classList.remove('analyzed');
                }
                updateUI();
            });

            // Aspect ratio buttons
            elements.aspectButtons.querySelectorAll('.aspect-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    elements.aspectButtons.querySelectorAll('.aspect-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.aspectRatio = btn.dataset.ratio;
                });
            });

            // Resolution buttons
            const resolutionButtons = document.getElementById('resolution-buttons');
            resolutionButtons.querySelectorAll('.aspect-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    resolutionButtons.querySelectorAll('.aspect-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.resolution = btn.dataset.res;
                });
            });

            // Analyze button
            elements.analyzeBtn.addEventListener('click', handleAnalyze);

            // Generate button
            elements.generateBtn.addEventListener('click', handleGenerate);

            // Lightbox
            document.getElementById('lightbox-close').addEventListener('click', closeLightbox);
            elements.lightbox.addEventListener('click', (e) => {
                if (e.target === elements.lightbox) closeLightbox();
            });

            document.getElementById('lightbox-download').addEventListener('click', () => {
                const result = state.results[state.lightboxIndex];
                const now = new Date();
                const yy = String(now.getFullYear()).slice(-2);
                const mm = String(now.getMonth() + 1).padStart(2, '0');
                const dd = String(now.getDate()).padStart(2, '0');
                const hh = String(now.getHours()).padStart(2, '0');
                const min = String(now.getMinutes()).padStart(2, '0');
                const num = String(state.lightboxIndex + 1).padStart(2, '0');
                downloadFile(result.url, `Setset_Social_${yy}${mm}${dd}_${hh}${min}_${num}.png`);
            });

            // Keyboard
            document.addEventListener('keydown', (e) => {
                if (!elements.lightbox.classList.contains('visible')) return;
                if (e.key === 'Escape') closeLightbox();
                if (e.key === 'ArrowLeft' && state.lightboxIndex > 0) {
                    state.lightboxIndex--;
                    updateLightboxContent();
                }
                if (e.key === 'ArrowRight' && state.lightboxIndex < state.results.length - 1) {
                    state.lightboxIndex++;
                    updateLightboxContent();
                }
            });
        }

        // Update style toggle visibility
        function updateStyleToggleVisibility() {
            if (state.mode === 'ecommerce') {
                elements.styleToggleRow.classList.remove('hidden');
            } else {
                elements.styleToggleRow.classList.add('hidden');
            }
        }

        // Update UI state
        function updateUI() {
            const isCasting = state.mode === 'casting';
            const hasTalent = isCasting ? !!state.heroTalent : state.selectedTalent.length > 0;
            const hasMoodboard = state.moodboardImages.some(img => img && img.selected !== false);
            const hasStyleText = state.styleInput.trim().length > 0;
            const activeOutputs = state.outputs.filter(o => o.enabled);
            const hasOutputs = activeOutputs.length > 0;

            // Enable/disable analyze button - can analyze with images OR text-only
            elements.analyzeBtn.disabled = !hasMoodboard && !hasStyleText;

            // Update analyze button text based on what we're analyzing
            if (!state.analysis) {
                if (hasMoodboard && hasStyleText) {
                    elements.analyzeBtn.textContent = 'Analyze Style';
                } else if (hasMoodboard) {
                    elements.analyzeBtn.textContent = 'Analyze Mood Board';
                } else if (hasStyleText) {
                    elements.analyzeBtn.textContent = 'Analyze Style Text';
                } else {
                    elements.analyzeBtn.textContent = 'Analyze Style';
                }
            }

            // Enable/disable generate button - need style input OR moodboard (not both required)
            const hasStyleSource = hasMoodboard || hasStyleText;
            const canGenerate = hasTalent && hasStyleSource && hasOutputs && state.analysis;
            elements.generateBtn.disabled = !canGenerate;

            // Update generate button text
            const totalImages = activeOutputs.length;
            let btnText = `Generate ${totalImages} image${totalImages !== 1 ? 's' : ''}`;
            elements.generateBtnText.textContent = btnText;

            // Update output hint based on mode
            if (state.mode === 'ecommerce') {
                elements.outputHint.textContent = 'E-commerce: White studio background. Toggle slots, select pose and people count.';
            } else if (state.mode === 'campaign') {
                elements.outputHint.textContent = 'Campaign: Environmental backgrounds from mood board. Toggle slots, select pose and people count.';
            } else {
                elements.outputHint.textContent = 'Casting: Hero model in every image. Toggle slots, select pose and people count.';
            }
        }

        // Loading animation
        function startLoadingAnimation(progressText = 'Preparing...') {
            elements.inlineLoader.classList.add('visible');
            elements.loaderProgress.textContent = progressText;

            const initialIdx = Math.floor(Math.random() * STUDIO_MESSAGES.length);
            elements.loaderMessage.textContent = STUDIO_MESSAGES[initialIdx];
            lastMessageIndex = initialIdx;

            loadingInterval = setInterval(() => {
                let idx;
                do {
                    idx = Math.floor(Math.random() * STUDIO_MESSAGES.length);
                } while (idx === lastMessageIndex && STUDIO_MESSAGES.length > 1);
                lastMessageIndex = idx;

                elements.loaderMessage.classList.add('fade-out');
                elements.loaderMessage.classList.remove('fade-in');

                setTimeout(() => {
                    elements.loaderMessage.textContent = STUDIO_MESSAGES[idx];
                    elements.loaderMessage.classList.remove('fade-out');
                    elements.loaderMessage.classList.add('fade-in');
                }, 250);
            }, 2000);
        }

        function updateLoadingProgress(text) {
            elements.loaderProgress.textContent = text;
        }

        function stopLoadingAnimation() {
            if (loadingInterval) {
                clearInterval(loadingInterval);
                loadingInterval = null;
            }
            elements.inlineLoader.classList.remove('visible');
        }

        // Handle Analyze
        async function handleAnalyze() {
            const moodImages = state.moodboardImages.filter(img => img && img.selected !== false);
            const styleText = state.styleInput.trim();
            const hasImages = moodImages.length > 0;
            const hasText = styleText.length > 0;

            if (!hasImages && !hasText) return;

            if (hasImages) {
                startLoadingAnimation(`Analyzing ${moodImages.length} moodboard image${moodImages.length > 1 ? 's' : ''}...`);
            } else {
                startLoadingAnimation('Analyzing style description...');
            }

            try {
                let analysisResult = '';

                if (hasImages) {
                    // Upload moodboard images
                    const uploadPromises = moodImages.map(img => api.uploadBase64(img.url));
                    const uploadResults = await Promise.all(uploadPromises);
                    const moodboardUrls = uploadResults.map(r => r.url);

                    // Analysis prompt for images
                    const analysisPrompt = `Analyze these images and create a comprehensive style guide for image generation. Write as a single flowing paragraph that can be used directly in prompts. Include:

1. CLOTHING AESTHETIC: Describe the overall fashion aesthetic and vibe (minimalist, luxury, streetwear, bohemian, tailored, relaxed, etc.). Focus on the STYLE and MOOD of the clothing rather than specific items. Mention textures, fits, silhouettes, and color palettes that define the look. Do NOT list specific garments - describe the fashion direction instead.

2. PHOTOGRAPHY STYLE: Is it analog/film-like or digital? Note any grain, color grading, filters, or processing effects. Describe color palette and tones (warm, cool, muted, saturated).

3. LIGHTING: Describe the lighting approach (natural, studio, dramatic, soft, harsh, backlit, etc.).

4. POSES & COMPOSITION: Note typical body language, poses, framing, and compositional elements.

5. MOOD & ENVIRONMENT: Describe the atmosphere, settings, and overall mood.

IMPORTANT:
- Do NOT mention specific clothing items like "paisley jacket" or "blue dress" - instead describe the style aesthetic
- Do NOT mention any brand names, designer labels, or logos
- Focus on the VIBE and AESTHETIC rather than specific pieces
- Write one cohesive paragraph that flows naturally and can generate VARIED outfits in the same style`;

                    const result = await api.analyzeImages(moodboardUrls, analysisPrompt);
                    if (result.content) {
                        analysisResult = result.content;
                    }
                } else if (hasText) {
                    // Text-only analysis - generate style guide from brand/aesthetic description
                    const textPrompt = `Based on this style description: "${styleText}"

Create a comprehensive fashion style guide for image generation. Write as a single flowing paragraph. Describe:

1. CLOTHING AESTHETIC: The overall fashion vibe, silhouettes, fits, textures, and color palettes that define this look. Be specific about the style direction.

2. PHOTOGRAPHY STYLE: What kind of photography would suit this aesthetic (clean digital, film-like, editorial, etc.).

3. MOOD: The overall atmosphere and feeling.

IMPORTANT:
- Do NOT mention any brand names, designer labels, or logos in your response
- Do NOT say "in the style of [brand]" - instead describe the aesthetic qualities
- Focus on describing the LOOK and FEEL, not the brand
- Write one cohesive paragraph that can generate VARIED outfits in this style`;

                    // Use a simple text analysis via the analyze endpoint with no images
                    const result = await fetch('/api/analyze', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            images: [],
                            prompt: textPrompt
                        })
                    }).then(r => r.json());

                    if (result.content) {
                        analysisResult = result.content;
                    }
                }

                if (analysisResult) {
                    state.analysis = analysisResult;
                    console.log('Style analysis stored:', state.analysis);

                    // Generate outfit pools based on the analysis
                    updateLoadingProgress('Generating outfit variations...');

                    // Count how many outfits we need per gender based on active outputs
                    const activeOutputs = state.outputs.filter(o => o.enabled);
                    // Generate more than needed for variety
                    const outfitCount = Math.max(activeOutputs.length + 4, 8);

                    try {
                        const outfitResponse = await fetch('/api/generate-outfits', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                brandAnalysis: analysisResult,
                                styleText: styleText,
                                femaleCount: outfitCount,
                                maleCount: outfitCount
                            })
                        });

                        const outfits = await outfitResponse.json();

                        if (outfits.female && outfits.male) {
                            state.outfits.female = outfits.female;
                            state.outfits.male = outfits.male;
                            state.outfits.usedFemale = 0;
                            state.outfits.usedMale = 0;
                            console.log(`Outfits generated: ${outfits.female.length} female, ${outfits.male.length} male`);
                            console.log('Female outfits sample:', outfits.female.slice(0, 2));
                            console.log('Male outfits sample:', outfits.male.slice(0, 2));
                        } else {
                            console.warn('Outfits response missing female or male pools:', outfits);
                        }
                    } catch (outfitError) {
                        console.error('Outfit generation error:', outfitError);
                        // Continue without outfits - will use generic clothing instruction
                    }
                }

                elements.analyzeBtn.textContent = 'Re-analyze';
                elements.analyzeBtn.classList.add('analyzed');

                updateUI();
            } catch (error) {
                console.error('Analysis error:', error);
                alert('Failed to analyze: ' + error.message);
            } finally {
                stopLoadingAnimation();
            }
        }

        // Handle Generate
        async function handleGenerate() {
            if (!state.analysis) {
                alert('Please analyze the mood board first');
                return;
            }

            const activeOutputs = state.outputs
                .map((o, i) => ({ ...o, index: i }))
                .filter(o => o.enabled);

            if (activeOutputs.length === 0) return;

            state.results = [];
            elements.resultsGrid.innerHTML = '';
            elements.progressSection.classList.add('visible');
            startLoadingAnimation(`Generating ${activeOutputs.length} images...`);

            // Reset outfit counters for fresh distribution each generation
            state.outfits.usedFemale = 0;
            state.outfits.usedMale = 0;
            console.log(`[Generate] Outfit pools: ${state.outfits.female?.length || 0} female, ${state.outfits.male?.length || 0} male`);

            let completed = 0;
            const total = activeOutputs.length;
            elements.progressCount.textContent = `0 / ${total}`;
            elements.progressBar.style.width = '0%';

            // Get talent based on mode
            const isCasting = state.mode === 'casting';
            let allTalentData = [];

            if (isCasting) {
                // Hero is always included
                const heroData = TALENT.find(t => t.id === state.heroTalent);
                const supportingData = state.supportingTalent.map(id => TALENT.find(t => t.id === id)).filter(Boolean);
                allTalentData = [heroData, ...supportingData].filter(Boolean);
            } else {
                allTalentData = state.selectedTalent.map(id => TALENT.find(t => t.id === id)).filter(Boolean);
            }

            // Fisher-Yates shuffle for proper randomization
            function shuffle(array) {
                const arr = [...array];
                for (let i = arr.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                }
                return arr;
            }

            // Pre-assign talent to each slot for even distribution
            // Ensure mix of male/female by interleaving genders
            const singlePersonSlots = activeOutputs.filter(o => o.peopleCount === 1);

            // Separate by gender, shuffle each, then interleave
            const females = shuffle(allTalentData.filter(t => t.gender === 'female'));
            const males = shuffle(allTalentData.filter(t => t.gender === 'male'));

            // Interleave: female, male, female, male... (or male, female if more males)
            const interleaved = [];
            const maxLen = Math.max(females.length, males.length);
            for (let i = 0; i < maxLen; i++) {
                if (i < females.length) interleaved.push(females[i]);
                if (i < males.length) interleaved.push(males[i]);
            }

            console.log(`[Talent] Selected: ${females.length} female, ${males.length} male, interleaved: ${interleaved.map(t => t.name).join(', ')}`);

            const talentAssignments = new Map();

            singlePersonSlots.forEach((output, idx) => {
                // Round-robin assignment from interleaved pool (ensures gender mix)
                const talentIndex = idx % interleaved.length;
                talentAssignments.set(output.index, [interleaved[talentIndex]]);
            });

            // Helper to get talent for an output
            function getTalentForOutput(output) {
                const count = output.peopleCount;
                if (count === 0) return [];

                // Use pre-assigned talent for single-person slots
                if (count === 1 && talentAssignments.has(output.index)) {
                    return talentAssignments.get(output.index);
                }

                if (isCasting) {
                    // Hero is always first
                    const result = [allTalentData[0]]; // Hero
                    if (count > 1 && allTalentData.length > 1) {
                        // Add random supporting cast from interleaved pool
                        const supporting = interleaved.filter(t => t.id !== allTalentData[0].id);
                        result.push(...supporting.slice(0, count - 1));
                    }
                    return result;
                } else {
                    // Use interleaved pool to ensure gender mix in multi-person shots
                    return interleaved.slice(0, Math.min(count, interleaved.length));
                }
            }

            // Upload ALL talent images ONCE before generation starts
            console.log('Uploading talent images...');
            updateLoadingProgress('Uploading talent images...');
            const talentUrlMap = new Map();

            const uploadTalentPromises = allTalentData.map(async (talent) => {
                const url = talent.image;
                if (url.startsWith('/') || url.startsWith('./')) {
                    const response = await fetch(url);
                    const blob = await response.blob();
                    const file = new File([blob], 'image.png', { type: blob.type });
                    const result = await api.uploadImage(file);
                    talentUrlMap.set(talent.id, result.url);
                    console.log(`Uploaded ${talent.name}: ${result.url}`);
                } else {
                    talentUrlMap.set(talent.id, url);
                }
            });
            await Promise.all(uploadTalentPromises);
            console.log('All talent images uploaded!');
            updateLoadingProgress(`Generating ${activeOutputs.length} images...`);

            // Generate for each active output
            const promises = activeOutputs.map(async (output) => {
                try {
                    const talentForOutput = getTalentForOutput(output);
                    const pose = POSES.find(p => p.id === output.poseId) || POSES[0];

                    if (talentForOutput.length === 0) {
                        console.log('No talent for output, skipping...');
                        return;
                    }

                    // Build prompt (pass talent array for outfit assignment by gender)
                    const prompt = buildPrompt(output, talentForOutput, pose);

                    // Get pre-uploaded URLs for this output's talent
                    const imageUrls = talentForOutput.map(t => talentUrlMap.get(t.id));
                    console.log(`Slot ${output.index + 1}: ${talentForOutput.map(t => t.name).join(', ')}`);

                    // Generate
                    const params = {
                        prompt,
                        image_urls: imageUrls,
                        num_images: 1,
                        aspect_ratio: state.aspectRatio,
                        resolution: state.resolution,
                        output_format: 'png'
                    };

                    const data = await api.remixImage('nano-pro', params);

                    if (data.images && data.images.length > 0) {
                        state.results.push({
                            url: data.images[0].url,
                            prompt,
                            type: state.mode.charAt(0).toUpperCase() + state.mode.slice(1),
                            pose: pose.name,
                            peopleCount: output.peopleCount
                        });
                        renderResults();
                    }
                } catch (error) {
                    console.error('Generation error:', error);
                }

                completed++;
                elements.progressCount.textContent = `${completed} / ${total}`;
                elements.progressBar.style.width = `${(completed / total) * 100}%`;
            });

            await Promise.all(promises);
            stopLoadingAnimation();
            elements.progressSection.classList.remove('visible');
        }

        // Build prompt based on mode and output
        function buildPrompt(output, talentArray, pose) {
            const numPeople = talentArray.length;
            let analysis = state.analysis || '';
            const styleInput = state.styleInput.trim();

            // Remove brand names first
            const brandBlacklist = [
                'Gucci', 'Louis Vuitton', 'LV', 'Prada', 'Chanel', 'Dior', 'HermÃ¨s', 'Hermes',
                'Burberry', 'Balenciaga', 'Versace', 'Fendi', 'Givenchy', 'Saint Laurent', 'YSL',
                'Bottega Veneta', 'Valentino', 'Alexander McQueen', 'Celine', 'Loewe', 'Moncler',
                'Off-White', 'Supreme', 'Nike', 'Adidas', 'Zara', 'H&M', 'Uniqlo', 'Reformation',
                'Rolex', 'Cartier', 'Tiffany', 'Bulgari', 'Van Cleef', 'Armani', 'Dolce & Gabbana',
                'Tom Ford', 'Marc Jacobs', 'Coach', 'Michael Kors', 'Kate Spade', 'Ralph Lauren',
                'Calvin Klein', 'Tommy Hilfiger', 'Hugo Boss', 'Stella McCartney', 'Acne Studios'
            ];
            brandBlacklist.forEach(brand => {
                const regex = new RegExp(`\\b${brand}\\b`, 'gi');
                analysis = analysis.replace(regex, '');
            });
            analysis = analysis.replace(/\s{2,}/g, ' ').trim();

            // Anti-splitting instruction
            const noSplitting = 'Generate ONE SINGLE unified image only. Do NOT create a collage, grid, triptych, diptych, split screen, or multiple panels. The output must be one continuous photograph.';

            // Get specific outfit based on talent gender
            const getOutfitForTalent = (talent) => {
                const gender = talent.gender || 'female';
                const pool = gender === 'male' ? state.outfits.male : state.outfits.female;
                const usedKey = gender === 'male' ? 'usedMale' : 'usedFemale';

                console.log(`[Outfit Debug] Talent: ${talent.name}, Gender: ${gender}, Pool size: ${pool?.length || 0}, Counter: ${state.outfits[usedKey]}`);

                if (pool && pool.length > 0) {
                    // Get next outfit from pool (cycling through)
                    const index = state.outfits[usedKey] % pool.length;
                    state.outfits[usedKey]++;
                    const outfit = pool[index];
                    console.log(`[Outfit Debug] Selected outfit #${index}: ${outfit?.substring(0, 60)}...`);
                    return outfit;
                }
                console.warn(`[Outfit Debug] No ${gender} outfits in pool!`);
                return null;
            };

            // Build outfit instruction based on talent
            let clothingInstruction = '';
            if (numPeople === 1) {
                const talent = talentArray[0];
                const outfit = getOutfitForTalent(talent);
                console.log(`Outfit assignment: ${talent.name} (${talent.gender}) -> ${outfit?.substring(0, 50)}...`);
                if (outfit) {
                    clothingInstruction = `OUTFIT: ${outfit}.`;
                } else if (styleInput) {
                    clothingInstruction = `Dress them in: ${styleInput}.`;
                } else {
                    clothingInstruction = 'Dress them in an outfit that fits the aesthetic.';
                }
            } else {
                // Multiple people - assign outfits to each
                const outfitDescriptions = talentArray.map((talent, i) => {
                    const outfit = getOutfitForTalent(talent);
                    if (outfit) {
                        return `Person ${i + 1}: ${outfit}`;
                    }
                    return null;
                }).filter(Boolean);

                if (outfitDescriptions.length > 0) {
                    clothingInstruction = `OUTFITS: ${outfitDescriptions.join('. ')}.`;
                } else if (styleInput) {
                    clothingInstruction = `Dress them in varied outfits: ${styleInput}.`;
                } else {
                    clothingInstruction = 'Dress each person in different outfits that fit the aesthetic.';
                }
            }

            // People text - critical for multi-person shots
            const peopleText = numPeople === 1
                ? 'this exact person from the reference image'
                : `these exact ${numPeople} people from the reference images together in the same shot`;

            let prompt = '';

            // Get pose prompt from POSE_PROMPTS based on the selected pose
            const getPosePrompt = (poseId) => {
                // Check if POSE_PROMPTS exists and has this pose
                if (typeof POSE_PROMPTS !== 'undefined' && POSE_PROMPTS[poseId]) {
                    const prompts = POSE_PROMPTS[poseId];
                    // Pick a random variation from the pose's prompt templates
                    return prompts[Math.floor(Math.random() * prompts.length)];
                }
                // Fallback to pose-pools.js for generic poses
                if (typeof getRandomPose === 'function') {
                    return getRandomPose('ecom-editorial');
                }
                return 'standing naturally with relaxed posture, direct gaze';
            };

            // Map pose categories to determine if it's a lifestyle/editorial pose
            const isLifestylePose = pose && (
                pose.category === 'lifestyle' ||
                pose.id.includes('lifestyle') ||
                ['sitting', 'walking', 'leaning', 'editorial', 'pocket', 'brush', 'adjust', 'laying', 'armscrossed'].some(
                    type => pose.id.toLowerCase().includes(type) || pose.name.toLowerCase().includes(type)
                )
            );

            // Get the specific pose prompt for this output's selected pose
            const selectedPosePrompt = getPosePrompt(pose.id);

            if (state.mode === 'ecommerce') {
                // E-commerce: Always white studio background
                const groupInstruction = numPeople > 1
                    ? `Place ${peopleText} standing together in the same frame. `
                    : '';

                // Use the selected pose prompt, replacing [PRODUCT_DESCRIPTION] with outfit
                let poseInstruction = selectedPosePrompt.replace('[PRODUCT_DESCRIPTION]', clothingInstruction);

                // Build prompt using the actual selected pose
                prompt = `${noSplitting} ${groupInstruction}${poseInstruction} ${analysis}. Clean white studio background, professional e-commerce lighting.`;
            } else if (state.mode === 'campaign') {
                // Campaign: Environmental backgrounds from mood board
                // Use the selected pose but in environmental setting
                let poseInstruction = selectedPosePrompt
                    .replace('[PRODUCT_DESCRIPTION]', clothingInstruction)
                    .replace(/white studio/gi, 'editorial campaign setting')
                    .replace(/studio/gi, 'location');

                prompt = `${noSplitting} Place ${peopleText} in an editorial campaign setting. ${poseInstruction} ${analysis}. Use the environmental style, locations, and mood from the reference images. Fashion editorial style, creative composition, dramatic lighting, high-end fashion campaign aesthetic.`;
            } else if (state.mode === 'casting') {
                // Casting: Variety of styles, hero always present
                // Mix between e-commerce and campaign randomly
                const isCampaignStyle = Math.random() > 0.5;

                let poseInstruction = selectedPosePrompt.replace('[PRODUCT_DESCRIPTION]', clothingInstruction);

                if (isCampaignStyle) {
                    poseInstruction = poseInstruction
                        .replace(/white studio/gi, 'editorial campaign setting')
                        .replace(/studio/gi, 'location');

                    prompt = `${noSplitting} Place ${peopleText} in an editorial campaign setting. ${poseInstruction} ${analysis}. Use the environmental style, locations, and mood from the reference images. Fashion editorial style, creative composition, dramatic lighting.`;
                } else {
                    const groupInstruction = numPeople > 1
                        ? `Place ${peopleText} standing together. `
                        : '';

                    prompt = `${noSplitting} ${groupInstruction}${poseInstruction} ${analysis}. Clean white studio background, professional e-commerce lighting.`;
                }
            }

            return prompt;
        }

        // Render results
        function renderResults() {
            if (state.results.length === 0) {
                elements.resultsSection.classList.remove('visible');
                return;
            }

            elements.resultsSection.classList.add('visible');
            elements.resultsGrid.innerHTML = state.results.map((result, index) => `
                <div class="result-card" onclick="openLightbox(${index})">
                    <img src="${result.url}" alt="Result ${index + 1}">
                </div>
            `).join('');
        }

        // Lightbox
        window.openLightbox = function(index) {
            state.lightboxIndex = index;
            updateLightboxContent();
            elements.lightbox.classList.add('visible');
        };

        function updateLightboxContent() {
            const result = state.results[state.lightboxIndex];
            elements.lightboxImage.src = result.url;
            elements.lightboxType.textContent = result.type;
            elements.lightboxPose.textContent = result.pose;
            elements.lightboxPrompt.textContent = result.prompt;
        }

        function closeLightbox() {
            elements.lightbox.classList.remove('visible');
        }

        // Initialize
        init();
    </script>
</body>
</html>
