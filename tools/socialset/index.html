<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SocialSet v2</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ“±</text></svg>">
    <link rel="stylesheet" href="/shared/css/tokens.css">
    <link rel="stylesheet" href="/shared/css/base.css">
    <link rel="stylesheet" href="/shared/css/components.css">
    <style>
        .container {
            max-width: 1200px;
        }

        /* Mode Tabs - Main navigation */
        .mode-tabs {
            display: flex;
            gap: 0;
            margin-bottom: var(--space-lg);
            border-bottom: 2px solid var(--gainsboro);
        }

        .mode-tab {
            padding: 14px 32px;
            font-size: var(--text-md);
            font-weight: 600;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            color: var(--slate);
            cursor: pointer;
            transition: all var(--transition-fast);
            margin-bottom: -2px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .mode-tab:hover {
            color: var(--jet);
        }

        .mode-tab.active {
            color: var(--jet);
            border-bottom-color: var(--jet);
        }

        /* Section styling */
        .section {
            background: var(--white);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-md);
            padding: var(--space-md);
            margin-bottom: var(--space-md);
        }

        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--space-sm);
        }

        .section-title {
            font-size: var(--text-sm);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--carbon);
        }

        .section-badge {
            font-size: var(--text-2xs);
            padding: 2px 8px;
            border-radius: var(--radius-sm);
            background: var(--off-white);
            color: var(--slate);
        }

        .section-badge.required {
            background: var(--jet);
            color: var(--white);
        }

        .section-hint {
            font-size: var(--text-xs);
            color: var(--ash-grey);
            margin-top: var(--space-xs);
        }

        /* Talent Grid - 12 columns x 2 rows */
        .talent-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: var(--space-xs);
        }

        @media (min-width: 800px) {
            .talent-grid {
                grid-template-columns: repeat(12, 1fr);
            }
        }

        .talent-card {
            position: relative;
            aspect-ratio: 3/4;
            border-radius: var(--radius-sm);
            overflow: hidden;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all var(--transition-fast);
        }

        .talent-card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .talent-card:hover {
            border-color: var(--ash-grey);
        }

        .talent-card.selected {
            border-color: var(--jet);
        }

        .talent-card.selected::after {
            content: attr(data-badge);
            position: absolute;
            top: 4px;
            right: 4px;
            min-width: 20px;
            height: 20px;
            padding: 0 4px;
            background: var(--jet);
            color: var(--white);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 600;
        }

        .talent-card.hero {
            border-color: #dc2626;
        }

        .talent-card.hero::after {
            content: 'HERO';
            background: #dc2626;
        }

        .talent-card.supporting {
            border-color: #2563eb;
        }

        .talent-card.supporting::after {
            content: '+';
            background: #2563eb;
        }

        .talent-card.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .talent-card .talent-name {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 2px 4px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 9px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Collection Picker */
        .collection-picker {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            margin-bottom: var(--space-sm);
            padding-bottom: var(--space-sm);
            border-bottom: 1px solid var(--gainsboro);
        }

        .collection-label {
            font-size: var(--text-xs);
            color: var(--slate);
            white-space: nowrap;
        }

        .collection-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .collection-chip {
            padding: 4px 10px;
            font-size: 11px;
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-sm);
            background: var(--off-white);
            color: var(--carbon);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .collection-chip:hover {
            border-color: var(--ash-grey);
            background: var(--white);
        }

        .collection-chip.active {
            border-color: var(--jet);
            background: var(--jet);
            color: var(--white);
        }

        /* Mood Board Grid */
        .moodboard-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: var(--space-xs);
        }

        @media (min-width: 800px) {
            .moodboard-grid {
                grid-template-columns: repeat(12, 1fr);
            }
        }

        .upload-slot {
            aspect-ratio: 3/4;
            border: 1px dashed var(--gainsboro);
            border-radius: var(--radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            background: var(--off-white);
            transition: all var(--transition-fast);
        }

        .upload-slot:hover {
            border-color: var(--ash-grey);
        }

        .upload-slot.filled {
            border-style: solid;
            border-color: transparent;
        }

        .upload-slot.filled img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .upload-slot .plus {
            font-size: 18px;
            font-weight: 300;
            color: var(--ash-grey);
        }

        .upload-slot .remove-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 20px;
            height: 20px;
            background: rgba(0,0,0,0.7);
            color: var(--white);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 12px;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .upload-slot.filled:hover .remove-btn {
            display: flex;
        }

        .upload-slot.deselected {
            opacity: 0.4;
        }

        .upload-slot.deselected img {
            filter: grayscale(100%);
        }

        /* Style input */
        .style-input-container {
            margin-top: var(--space-sm);
            display: flex;
            gap: var(--space-sm);
            align-items: stretch;
        }

        .style-input {
            flex: 1;
            padding: 10px 14px;
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-sm);
            font-size: var(--text-sm);
            font-family: inherit;
            resize: none;
            min-height: 40px;
        }

        .style-input:focus {
            outline: none;
            border-color: var(--jet);
        }

        .style-input::placeholder {
            color: var(--ash-grey);
        }

        /* Output Grid */
        .output-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: var(--space-sm);
        }

        @media (min-width: 600px) {
            .output-grid {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        @media (min-width: 900px) {
            .output-grid {
                grid-template-columns: repeat(6, 1fr);
            }
        }

        .output-slot {
            background: var(--white);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-sm);
            padding: var(--space-sm);
            display: flex;
            flex-direction: column;
            gap: var(--space-xs);
        }

        .output-slot.active {
            border-color: var(--ash-grey);
            background: var(--off-white);
        }

        .output-slot-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: var(--text-xs);
            color: var(--slate);
        }

        .output-slot-number {
            font-weight: 600;
        }

        .output-toggle {
            width: 32px;
            height: 18px;
            background: var(--gainsboro);
            border-radius: 9px;
            position: relative;
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .output-toggle.active {
            background: var(--jet);
        }

        .output-toggle::after {
            content: '';
            position: absolute;
            width: 14px;
            height: 14px;
            background: var(--white);
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: all var(--transition-fast);
        }

        .output-toggle.active::after {
            left: 16px;
        }

        .output-pose-select {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-xs);
            font-size: var(--text-xs);
            background: var(--white);
            cursor: pointer;
        }

        .output-pose-select:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .output-framing-select {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-xs);
            font-size: var(--text-xs);
            background: var(--white);
            cursor: pointer;
            margin-top: 4px;
        }

        .output-framing-select:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .output-selects-row {
            display: flex;
            gap: 4px;
        }

        .output-selects-row select {
            flex: 1;
        }

        .output-people-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: var(--space-xs);
        }

        .output-people-label {
            font-size: var(--text-xs);
            color: var(--slate);
        }

        .output-people-controls {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .output-people-btn {
            width: 22px;
            height: 22px;
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-xs);
            background: var(--white);
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--transition-fast);
        }

        .output-people-btn:hover:not(:disabled) {
            border-color: var(--jet);
        }

        .output-people-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .output-people-count {
            min-width: 20px;
            text-align: center;
            font-size: var(--text-sm);
            font-weight: 600;
        }

        /* Drag hover state */
        .moodboard-grid.drag-over {
            background: rgba(0, 0, 0, 0.03);
            border-radius: var(--radius-md);
        }

        .moodboard-grid.drag-over .upload-slot:not(.filled) {
            border-color: var(--jet);
            background: rgba(0, 0, 0, 0.05);
        }

        /* Inline loader */
        .inline-loader {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: var(--space-lg);
            background: var(--off-white);
            border-radius: var(--radius-md);
            margin-bottom: var(--space-md);
        }

        .inline-loader.visible {
            display: flex;
        }

        .loader-message {
            font-size: var(--text-lg);
            font-weight: 600;
            background: linear-gradient(90deg,
                rgba(0, 47, 167, 0.4) 0%,
                rgba(0, 47, 167, 1) 50%,
                rgba(0, 47, 167, 0.4) 100%);
            background-size: 200% 100%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: sweep 2s ease-in-out infinite;
        }

        .loader-message.fade-out {
            animation: fade-out 0.25s ease-out forwards;
        }

        .loader-message.fade-in {
            animation: fade-in 0.25s ease-out forwards, sweep 2s ease-in-out infinite;
        }

        @keyframes sweep {
            0% { background-position: 100% 0; }
            100% { background-position: -100% 0; }
        }

        @keyframes fade-out {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        @keyframes fade-in {
            0% { opacity: 0; }
            100% { opacity: 1; }
        }

        .loader-progress {
            font-size: var(--text-sm);
            color: var(--slate);
            margin-top: var(--space-xs);
        }

        /* Actions row */
        .actions-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--space-md);
            background: var(--white);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-md);
            margin-bottom: var(--space-md);
            flex-wrap: wrap;
            gap: var(--space-sm);
        }

        .settings-row {
            display: flex;
            align-items: center;
            gap: var(--space-lg);
            flex-wrap: wrap;
        }

        .setting-group {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }

        .setting-label {
            font-size: var(--text-xs);
            color: var(--slate);
            font-weight: 500;
        }

        .aspect-buttons {
            display: flex;
            gap: 4px;
        }

        .aspect-btn {
            padding: 6px 12px;
            font-size: var(--text-xs);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-sm);
            background: var(--off-white);
            color: var(--slate);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .aspect-btn:hover {
            border-color: var(--ash-grey);
        }

        .aspect-btn.active {
            background: var(--jet);
            color: var(--white);
            border-color: var(--jet);
        }

        .action-buttons {
            display: flex;
            gap: var(--space-sm);
        }

        .action-btn {
            padding: 12px 24px;
            font-size: 14px;
            min-width: 160px;
            text-align: center;
        }

        .btn.analyzed {
            background: #22c55e;
            border-color: #22c55e;
            color: var(--white);
        }

        .btn.analyzed:hover {
            background: #16a34a;
            border-color: #16a34a;
        }

        /* Results section */
        .results-section {
            display: none;
            margin-left: calc(-50vw + 50%);
            margin-right: calc(-50vw + 50%);
            padding-left: var(--space-lg);
            padding-right: var(--space-lg);
            max-width: 100vw;
        }

        .results-section.visible {
            display: block;
        }

        .results-header {
            max-width: 1200px;
            margin: 0 auto var(--space-md);
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: var(--space-md);
            max-width: 1400px;
            margin: 0 auto;
        }

        @media (min-width: 900px) {
            .results-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        .result-card {
            cursor: pointer;
            border-radius: var(--radius-md);
            overflow: hidden;
            transition: transform var(--transition-fast);
        }

        .result-card:hover {
            transform: scale(1.02);
        }

        .result-card img {
            width: 100%;
            aspect-ratio: 3/4;
            object-fit: cover;
        }

        /* Progress section */
        .progress-section {
            display: none;
            margin-bottom: var(--space-md);
        }

        .progress-section.visible {
            display: block;
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: var(--space-xs);
        }

        .progress-title {
            font-size: var(--text-xs);
            font-weight: 600;
            text-transform: uppercase;
            color: var(--slate);
        }

        .progress-count {
            font-size: var(--text-sm);
            font-weight: 600;
        }

        .progress-bar-container {
            height: 6px;
            background: var(--off-white);
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: var(--jet);
            border-radius: 3px;
            transition: width 0.3s ease;
            width: 0%;
        }

        input[type="file"] {
            display: none;
        }

        /* Pose dropdown optgroup styling */
        .output-pose-select optgroup {
            font-weight: 600;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.03em;
            color: var(--slate);
            background: var(--off-white);
            padding: 8px 0 4px 0;
        }

        .output-pose-select option {
            font-weight: 400;
            font-size: 13px;
            text-transform: none;
            letter-spacing: normal;
            color: var(--carbon);
            background: var(--white);
            padding: 4px 8px;
        }

        /* Environment Picker */
        .environment-picker-container {
            margin-top: var(--space-md);
            padding: var(--space-md);
            background: var(--off-white);
            border-radius: var(--radius-md);
            border: 1px solid var(--gainsboro);
        }

        .environment-header {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            margin-bottom: var(--space-md);
        }

        .environment-title {
            font-size: var(--text-sm);
            font-weight: 600;
            color: var(--carbon);
        }

        .environment-picker {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-md);
        }

        .environment-column {
            display: flex;
            flex-direction: column;
            gap: var(--space-xs);
        }

        .environment-label {
            font-size: var(--text-xs);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--slate);
            margin: 0 0 4px 0;
        }

        .environment-options {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .environment-option {
            padding: 8px 10px;
            background: var(--white);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-sm);
            font-size: 11px;
            color: var(--carbon);
            cursor: pointer;
            transition: all var(--transition-fast);
            text-align: left;
            line-height: 1.3;
        }

        .environment-option:hover {
            border-color: var(--slate);
        }

        .environment-option.selected {
            background: var(--jet);
            color: var(--white);
            border-color: var(--jet);
        }

        .environment-option.selected:hover {
            background: var(--carbon);
            border-color: var(--carbon);
        }

        @media (max-width: 600px) {
            .environment-picker {
                grid-template-columns: 1fr;
            }
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="hero">
            <h1>SocialSet</h1>
            <p class="hero-subtitle">Generate Instagram content for E-commerce, Campaigns, and Casting</p>
        </div>

        <!-- Mode Tabs -->
        <div class="mode-tabs">
            <button class="mode-tab active" data-mode="ecommerce">E-commerce</button>
            <button class="mode-tab" data-mode="campaign">Campaign</button>
            <button class="mode-tab" data-mode="casting">Casting</button>
        </div>

        <!-- Section 1: Talent Selection -->
        <div class="section">
            <div class="section-header">
                <span class="section-title">1. Select Talent</span>
                <span class="section-badge required">Required</span>
            </div>
            <div class="talent-grid" id="talent-grid"></div>
            <p class="section-hint" id="talent-hint">Select up to 4 models. Selected: <span id="talent-count">0</span>/4</p>
        </div>

        <!-- Section 2: Mood Board -->
        <div class="section" id="moodboard-section">
            <div class="section-header">
                <span class="section-title">2. Mood Board</span>
                <span class="section-badge required">Required</span>
                <button class="btn btn--sm" id="clear-moodboard" style="margin-left: auto; font-size: 11px; padding: 4px 10px;">Clear All</button>
            </div>
            <!-- Collection Picker -->
            <div class="collection-picker" id="collection-picker">
                <span class="collection-label">Quick Load:</span>
                <div class="collection-chips" id="collection-chips"></div>
            </div>
            <div class="moodboard-grid" id="moodboard-grid"></div>
            <input type="file" id="moodboard-input" accept="image/*" multiple>

            <!-- Style Input -->
            <div class="style-input-container">
                <textarea class="style-input" id="style-input" placeholder="Add style directions (e.g., 'more minimal', 'all red', 'athletic wear', 'sunglasses on every shot')..." rows="2"></textarea>
            </div>

            <!-- Campaign Environments (shown after analyze in Campaign mode) -->
            <div class="environment-picker-container" id="environment-section" style="display: none;">
                <div class="environment-header">
                    <span class="environment-title">Campaign Environments</span>
                    <span class="section-badge">Select 1 each</span>
                </div>
                <div class="environment-picker">
                    <div class="environment-column">
                        <h4 class="environment-label">Indoor</h4>
                        <div class="environment-options" id="indoor-options"></div>
                    </div>
                    <div class="environment-column">
                        <h4 class="environment-label">Outdoor</h4>
                        <div class="environment-options" id="outdoor-options"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 3: Output Configuration -->
        <div class="section">
            <div class="section-header">
                <span class="section-title">3. Output Configuration</span>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <button class="btn btn-secondary btn-sm" id="randomize-outputs-btn" style="display: none; padding: 4px 12px; font-size: 11px;">Randomize</button>
                    <span class="section-badge required">Required</span>
                </div>
            </div>
            <p class="section-hint" style="margin-bottom: var(--space-sm);" id="output-hint">Toggle slots on/off. Select pose and number of people per image.</p>
            <div class="output-grid" id="output-grid"></div>
        </div>

        <!-- Inline Loader -->
        <div class="inline-loader" id="inline-loader">
            <div class="loader-message" id="loader-message">Setting up the Studio...</div>
            <div class="loader-progress" id="loader-progress">Preparing...</div>
        </div>

        <!-- Settings & Actions -->
        <div class="actions-row">
            <div class="settings-row">
                <div class="setting-group">
                    <span class="setting-label">Aspect</span>
                    <div class="aspect-buttons" id="aspect-buttons">
                        <button class="aspect-btn" data-ratio="1:1">1:1</button>
                        <button class="aspect-btn active" data-ratio="3:4">3:4</button>
                        <button class="aspect-btn" data-ratio="4:3">4:3</button>
                        <button class="aspect-btn" data-ratio="9:16">9:16</button>
                        <button class="aspect-btn" data-ratio="16:9">16:9</button>
                    </div>
                </div>
                <div class="setting-group">
                    <span class="setting-label">Resolution</span>
                    <div class="aspect-buttons" id="resolution-buttons">
                        <button class="aspect-btn" data-res="1K">1K</button>
                        <button class="aspect-btn active" data-res="2K">2K</button>
                    </div>
                </div>
            </div>
            <div class="action-buttons">
                <button class="btn action-btn" id="analyze-btn" disabled>Analyze Mood Board</button>
                <button class="btn btn--primary action-btn" id="generate-btn" disabled>
                    <span id="generate-btn-text">Generate 0 images</span>
                </button>
            </div>
        </div>

        <!-- Progress -->
        <div class="progress-section" id="progress-section">
            <div class="progress-header">
                <span class="progress-title">Generating</span>
                <span class="progress-count" id="progress-count">0 / 0</span>
            </div>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
        </div>

        <!-- Results -->
        <div class="results-section" id="results-section">
            <div class="results-header">
                <h2>Results</h2>
            </div>
            <div class="results-grid" id="results-grid"></div>
        </div>
    </div>

    <!-- Lightbox -->
    <div class="lightbox" id="lightbox">
        <div class="lightbox-content">
            <button class="lightbox-close" id="lightbox-close">&times;</button>
            <div class="lightbox-left">
                <img src="" alt="" class="lightbox-image" id="lightbox-image">
            </div>
            <div class="lightbox-right">
                <div class="lightbox-section">
                    <h3 class="lightbox-section-title">Type</h3>
                    <p class="lightbox-model-text" id="lightbox-type"></p>
                </div>
                <div class="lightbox-section">
                    <h3 class="lightbox-section-title">Pose</h3>
                    <p id="lightbox-pose"></p>
                </div>
                <div class="lightbox-section">
                    <h3 class="lightbox-section-title">Prompt</h3>
                    <p class="lightbox-prompt-text" id="lightbox-prompt"></p>
                </div>
                <button class="lightbox-download" id="lightbox-download">Download Image</button>
            </div>
        </div>
    </div>

    <!-- Shared JS -->
    <script src="/shared/js/utils.js"></script>
    <script src="/shared/js/api.js"></script>
    <script src="/shared/js/loader.js"></script>
    <script src="/shared/data/editorial-moods.js"></script>
    <script src="poses.js"></script>
    <script src="pose-pools.js"></script>

    <script>
        // Setset Talent Library (with gender for outfit assignment)
        const TALENT = [
            { id: 'james', name: 'James Wilson', gender: 'male', image: '/shared/images/talent/talent-01_JamesWilson.png' },
            { id: 'maya', name: 'Maya Johnson', gender: 'female', image: '/shared/images/talent/talent-02_MayaJohnson.png' },
            { id: 'river', name: 'River Blake', gender: 'male', image: '/shared/images/talent/talent-03_RiverBlake.png' },
            { id: 'emma', name: 'Emma Sullivan', gender: 'female', image: '/shared/images/talent/talent-04_EmmaSullivan.png' },
            { id: 'marcus', name: 'Marcus Brown', gender: 'male', image: '/shared/images/talent/talent-05_MarcusBrown.png' },
            { id: 'zara', name: 'Zara Mitchell', gender: 'female', image: '/shared/images/talent/talent-06_ZaraMitchell.png' },
            { id: 'sophia', name: 'Sophia Anderson', gender: 'female', image: '/shared/images/talent/talent-07_SophiaAnderson.png' },
            { id: 'liam', name: 'Liam Garcia', gender: 'male', image: '/shared/images/talent/talent-08_LiamGarcia.png' },
            { id: 'nina', name: 'Nina Davis', gender: 'female', image: '/shared/images/talent/talent-09_NinaDavis.png' },
            { id: 'mateo', name: 'Mateo Martinez', gender: 'male', image: '/shared/images/talent/talent-10_AvaMartinez.png' },
            { id: 'luna', name: 'Luna Park', gender: 'female', image: '/shared/images/talent/talent-11_LunaPark.png' },
            { id: 'noah', name: 'Noah Chen', gender: 'male', image: '/shared/images/talent/talent-12_NoahChen.png' },
            { id: 'kai', name: 'Kai Thompson', gender: 'male', image: '/shared/images/talent/talent-13_KaiThompson.png' },
            { id: 'riley', name: 'Riley Morgan', gender: 'male', image: '/shared/images/talent/talent-14_RileyMorgan.png' },
            { id: 'jordan', name: 'Jordan Lee', gender: 'male', image: '/shared/images/talent/talent-15_JordanLee.png' },
            { id: 'isabella', name: 'Isabella Rodriguez', gender: 'female', image: '/shared/images/talent/talent-16_IsabellaRodriguez.png' },
            { id: 'quinn', name: 'Quinn Santos', gender: 'male', image: '/shared/images/talent/talent-17_QuinnSantos.png' },
            { id: 'casey', name: 'Casey White', gender: 'female', image: '/shared/images/talent/talent-18_CaseyWhite.png' },
            { id: 'sam', name: 'Sam Wilson', gender: 'female', image: '/shared/images/talent/talent-19_SamWilson.png' },
            { id: 'drew', name: 'Drew Martinez', gender: 'male', image: '/shared/images/talent/talent-20_DrewMartinez.png' },
            { id: 'avery', name: 'Avery Taylor', gender: 'female', image: '/shared/images/talent/talent-21_AveryTaylor.png' },
            { id: 'parker', name: 'Parker Miller', gender: 'male', image: '/shared/images/talent/talent-22_ParkerMiller.png' },
            { id: 'morgan', name: 'Morgan Kim', gender: 'male', image: '/shared/images/talent/talent-23_MorganKim.png' },
            { id: 'andre', name: 'Andre Jackson', gender: 'male', image: '/shared/images/talent/talent-24_AndreJackson.png' },
            { id: 'damon', name: 'Damon Carter', gender: 'male', image: '/shared/images/talent/talent-25_DamonCarter.png' },
            { id: 'nikolai', name: 'Nikolai Volkov', gender: 'male', image: '/shared/images/talent/talent-26_NikolaiVolkov.png' },
            { id: 'sofia', name: 'Sofia Rodriguez', gender: 'female', image: '/shared/images/talent/talent-27_SofiaRodriguez.png' },
            { id: 'finn', name: 'Finn O\'Connor', gender: 'male', image: '/shared/images/talent/talent-28_FinnOConnor.png' },
            { id: 'clara', name: 'Clara Devereaux', gender: 'female', image: '/shared/images/talent/talent-29_ClaraDevereaux.png' },
            { id: 'zoe', name: 'Simone Park', gender: 'female', image: '/shared/images/talent/talent-30_ZoeWashington.png' }
        ];

        // STUDIO_MESSAGES is now loaded from /shared/js/loader.js

        // State
        const state = {
            mode: 'ecommerce',  // 'ecommerce', 'campaign', 'casting'

            // Talent selection
            selectedTalent: [],      // For ecommerce/campaign: array of IDs
            heroTalent: null,        // For casting: single hero ID
            supportingTalent: [],    // For casting: array of supporting IDs

            // Mood board
            moodboardImages: new Array(24).fill(null),
            styleInput: '',
            analysis: null,

            // Outfit pools - generated during analyze step
            outfits: {
                female: [],  // Array of outfit descriptions for female talent
                male: [],    // Array of outfit descriptions for male talent
                usedFemale: 0,  // Counter for assigning unique outfits
                usedMale: 0
            },

            // Campaign environments - one indoor + one outdoor location with variations
            campaignEnvironments: {
                indoor: [],   // 5 variations of the selected indoor location
                outdoor: []   // 5 variations of the selected outdoor location
            },
            generatedEnvironments: {
                indoor: [],   // 5 generated indoor options to choose from
                outdoor: []   // 5 generated outdoor options to choose from
            },
            selectedEnvironments: {
                indoor: null,  // Selected indoor environment (index)
                outdoor: null  // Selected outdoor environment (index)
            },
            currentIndoorIndex: 0,   // Counter for cycling through indoor variations
            currentOutdoorIndex: 0,  // Counter for cycling through outdoor variations
            useIndoorNext: true,     // Alternates between indoor and outdoor

            // Output configuration - 12 slots
            outputs: new Array(12).fill(null).map(() => ({
                enabled: false,
                poseId: 'pose-pdp-front',
                peopleCount: 1,
                framingId: 'headshot',  // Default framing
                castingStyle: 'studio'  // 'studio' or 'campaign' for casting mode
            })),

            // Settings
            aspectRatio: '3:4',
            resolution: '2K',

            // Results
            results: [],
            lightboxIndex: 0
        };

        // DOM Elements
        const elements = {
            modeTabs: document.querySelectorAll('.mode-tab'),
            talentGrid: document.getElementById('talent-grid'),
            talentCount: document.getElementById('talent-count'),
            talentHint: document.getElementById('talent-hint'),
            moodboardSection: document.getElementById('moodboard-section'),
            moodboardGrid: document.getElementById('moodboard-grid'),
            moodboardInput: document.getElementById('moodboard-input'),
            clearMoodboard: document.getElementById('clear-moodboard'),
            styleInput: document.getElementById('style-input'),
            outputGrid: document.getElementById('output-grid'),
            outputHint: document.getElementById('output-hint'),
            aspectButtons: document.getElementById('aspect-buttons'),
            analyzeBtn: document.getElementById('analyze-btn'),
            generateBtn: document.getElementById('generate-btn'),
            generateBtnText: document.getElementById('generate-btn-text'),
            inlineLoader: document.getElementById('inline-loader'),
            loaderMessage: document.getElementById('loader-message'),
            loaderProgress: document.getElementById('loader-progress'),
            progressSection: document.getElementById('progress-section'),
            progressCount: document.getElementById('progress-count'),
            progressBar: document.getElementById('progress-bar'),
            resultsSection: document.getElementById('results-section'),
            resultsGrid: document.getElementById('results-grid'),
            lightbox: document.getElementById('lightbox'),
            lightboxImage: document.getElementById('lightbox-image'),
            lightboxType: document.getElementById('lightbox-type'),
            lightboxPose: document.getElementById('lightbox-pose'),
            lightboxPrompt: document.getElementById('lightbox-prompt'),
            environmentSection: document.getElementById('environment-section'),
            indoorOptions: document.getElementById('indoor-options'),
            outdoorOptions: document.getElementById('outdoor-options'),
            randomizeOutputsBtn: document.getElementById('randomize-outputs-btn')
        };

        let loadingInterval = null;
        let lastMessageIndex = -1;

        // Initialize
        // Moodboard collections library
        let moodboardLibrary = null;

        async function loadMoodboardLibrary() {
            try {
                const response = await fetch('/shared/data/moodboard-library.json');
                moodboardLibrary = await response.json();
                renderCollectionChips();
            } catch (error) {
                console.error('Failed to load moodboard library:', error);
            }
        }

        function renderCollectionChips() {
            const container = document.getElementById('collection-chips');
            if (!moodboardLibrary || !container) return;

            container.innerHTML = moodboardLibrary.collections.map(collection => `
                <button class="collection-chip" data-collection="${collection.id}" title="${collection.description}">
                    ${collection.name}
                </button>
            `).join('');

            // Add click handlers
            container.querySelectorAll('.collection-chip').forEach(chip => {
                chip.addEventListener('click', () => loadCollection(chip.dataset.collection));
            });
        }

        async function loadCollection(collectionId) {
            const collection = moodboardLibrary?.collections.find(c => c.id === collectionId);
            if (!collection) return;

            // Clear existing moodboard
            state.moodboardImages = new Array(24).fill(null);

            // Update chip states
            document.querySelectorAll('.collection-chip').forEach(chip => {
                chip.classList.toggle('active', chip.dataset.collection === collectionId);
            });

            // Load images from collection (up to 24)
            const imagesToLoad = collection.images.slice(0, 24);

            for (let i = 0; i < imagesToLoad.length; i++) {
                const imagePath = imagesToLoad[i];
                try {
                    // Fetch and convert to base64
                    const response = await fetch(imagePath);
                    const blob = await response.blob();
                    const base64 = await new Promise((resolve) => {
                        const reader = new FileReader();
                        reader.onloadend = () => resolve(reader.result);
                        reader.readAsDataURL(blob);
                    });

                    state.moodboardImages[i] = {
                        url: base64,
                        selected: true,
                        name: imagePath.split('/').pop()
                    };
                } catch (error) {
                    console.error(`Failed to load image: ${imagePath}`, error);
                }
            }

            // Pre-fill style analysis from collection
            if (collection.styleAnalysis) {
                const analysis = collection.styleAnalysis;
                // Combine into a usable analysis string
                state.analysis = `${analysis.aesthetic} ${analysis.clothing} ${analysis.photography} ${analysis.mood}`;
                console.log('Pre-loaded style analysis from collection:', collection.name);
            }

            // Load indoor/outdoor environment pools from collection
            if (collection.environmentPool && collection.environmentPool.indoor && collection.environmentPool.outdoor) {
                state.campaignEnvironments.indoor = [...collection.environmentPool.indoor];
                state.campaignEnvironments.outdoor = [...collection.environmentPool.outdoor];
                state.currentIndoorIndex = 0;
                state.currentOutdoorIndex = 0;
                state.useIndoorNext = Math.random() > 0.5; // Random start
                console.log(`Loaded campaign environments - Indoor: ${state.campaignEnvironments.indoor.length} variations, Outdoor: ${state.campaignEnvironments.outdoor.length} variations`);
            } else {
                state.campaignEnvironments = { indoor: [], outdoor: [] };
            }

            renderMoodboardGrid();
            updateUI();
        }

        function init() {
            loadMoodboardLibrary();
            renderTalentGrid();
            renderMoodboardGrid();
            renderOutputGrid();
            setupEventListeners();
            updateUI();
        }

        // Render Talent Grid
        function renderTalentGrid() {
            const isCasting = state.mode === 'casting';

            elements.talentGrid.innerHTML = TALENT.map(talent => {
                let classes = 'talent-card';
                let badge = '';
                let isDisabled = false;

                if (isCasting) {
                    if (state.heroTalent === talent.id) {
                        classes += ' hero';
                    } else if (state.supportingTalent.includes(talent.id)) {
                        classes += ' supporting';
                    } else if (state.supportingTalent.length >= 3 && !state.heroTalent) {
                        isDisabled = true;
                    }
                } else {
                    if (state.selectedTalent.includes(talent.id)) {
                        classes += ' selected';
                        badge = 'âœ“';
                    } else if (state.selectedTalent.length >= 8) {
                        isDisabled = true;
                    }
                }

                if (isDisabled) classes += ' disabled';

                return `
                    <div class="${classes}" data-id="${talent.id}" data-badge="${badge}" title="${talent.name}">
                        <img src="${talent.image}" alt="${talent.name}">
                        <span class="talent-name">${talent.name}</span>
                    </div>
                `;
            }).join('');

            // Add click handlers
            elements.talentGrid.querySelectorAll('.talent-card').forEach(card => {
                card.addEventListener('click', () => handleTalentClick(card.dataset.id));
            });

            // Update hint and count
            if (isCasting) {
                const heroText = state.heroTalent ? '1 hero' : '0 hero';
                const supportText = `${state.supportingTalent.length} supporting`;
                elements.talentHint.innerHTML = `Click once for HERO (required), click again for supporting. ${heroText}, ${supportText}`;
                elements.talentCount.textContent = state.heroTalent ? '1' : '0';
            } else {
                elements.talentHint.innerHTML = `Select up to 8 models. Selected: <span id="talent-count">${state.selectedTalent.length}</span>/8`;
                elements.talentCount.textContent = state.selectedTalent.length;
            }
        }

        // Handle talent click
        function handleTalentClick(talentId) {
            const isCasting = state.mode === 'casting';

            if (isCasting) {
                // Casting mode: cycle through none -> hero -> supporting -> none
                if (state.heroTalent === talentId) {
                    // Hero -> Supporting
                    state.heroTalent = null;
                    if (state.supportingTalent.length < 3) {
                        state.supportingTalent.push(talentId);
                    }
                } else if (state.supportingTalent.includes(talentId)) {
                    // Supporting -> None
                    state.supportingTalent = state.supportingTalent.filter(id => id !== talentId);
                } else {
                    // None -> Hero (if no hero) or Supporting (if hero exists)
                    if (!state.heroTalent) {
                        state.heroTalent = talentId;
                    } else if (state.supportingTalent.length < 3) {
                        state.supportingTalent.push(talentId);
                    }
                }
            } else {
                // Normal mode: toggle selection
                if (state.selectedTalent.includes(talentId)) {
                    state.selectedTalent = state.selectedTalent.filter(id => id !== talentId);
                } else if (state.selectedTalent.length < 8) {
                    state.selectedTalent.push(talentId);
                }
            }

            renderTalentGrid();
            updateUI();
        }

        // Render Moodboard Grid
        function renderMoodboardGrid() {
            elements.moodboardGrid.innerHTML = state.moodboardImages.map((img, i) => {
                if (img) {
                    return `
                        <div class="upload-slot filled ${img.selected === false ? 'deselected' : ''}" data-index="${i}">
                            <img src="${img.url}" alt="Moodboard ${i + 1}">
                            <button class="remove-btn" data-action="remove">&times;</button>
                        </div>
                    `;
                }
                return `
                    <div class="upload-slot" data-index="${i}">
                        <span class="plus">+</span>
                    </div>
                `;
            }).join('');

            setupMoodboardListeners();
        }

        // Setup moodboard listeners
        function setupMoodboardListeners() {
            elements.moodboardGrid.querySelectorAll('.upload-slot').forEach(slot => {
                const index = parseInt(slot.dataset.index);

                slot.addEventListener('click', (e) => {
                    if (e.target.dataset.action === 'remove') {
                        // Remove and collapse
                        state.moodboardImages[index] = null;
                        const filled = state.moodboardImages.filter(img => img);
                        for (let i = 0; i < 24; i++) {
                            state.moodboardImages[i] = filled[i] || null;
                        }
                        state.analysis = null;
                        elements.analyzeBtn.textContent = 'Analyze Mood Board';
                        elements.analyzeBtn.classList.remove('analyzed');
                        renderMoodboardGrid();
                        updateUI();
                        return;
                    }

                    if (state.moodboardImages[index]) {
                        // Toggle selection
                        state.moodboardImages[index].selected = state.moodboardImages[index].selected === false ? true : false;
                        renderMoodboardGrid();
                        updateUI();
                    } else {
                        // Open file picker
                        elements.moodboardInput.dataset.startIndex = index;
                        elements.moodboardInput.click();
                    }
                });
            });

            // Drag and drop
            elements.moodboardGrid.addEventListener('dragover', (e) => e.preventDefault());
            elements.moodboardGrid.addEventListener('dragenter', () => elements.moodboardGrid.classList.add('drag-over'));
            elements.moodboardGrid.addEventListener('dragleave', (e) => {
                if (!elements.moodboardGrid.contains(e.relatedTarget)) {
                    elements.moodboardGrid.classList.remove('drag-over');
                }
            });
            elements.moodboardGrid.addEventListener('drop', (e) => {
                e.preventDefault();
                elements.moodboardGrid.classList.remove('drag-over');
                const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
                handleFileUpload(files, null);
            });
        }

        // Handle file upload
        function handleFileUpload(files, startIndex) {
            const targetIndices = [];

            if (startIndex !== null) {
                for (let i = 0; i < files.length; i++) {
                    const idx = startIndex + i;
                    if (idx < 24) targetIndices.push(idx);
                }
            } else {
                for (let i = 0; i < files.length; i++) {
                    const emptyIdx = state.moodboardImages.findIndex((img, idx) => !img && !targetIndices.includes(idx));
                    if (emptyIdx !== -1 && emptyIdx < 24) {
                        targetIndices.push(emptyIdx);
                    }
                }
            }

            files.forEach((file, i) => {
                if (i >= targetIndices.length) return;
                const targetIndex = targetIndices[i];

                const reader = new FileReader();
                reader.onload = (e) => {
                    state.moodboardImages[targetIndex] = { file, url: e.target.result, selected: true };
                    state.analysis = null;
                    elements.analyzeBtn.textContent = 'Analyze Mood Board';
                    elements.analyzeBtn.classList.remove('analyzed');
                    renderMoodboardGrid();
                    updateUI();
                };
                reader.readAsDataURL(file);
            });
        }

        // Render Environment Options for Campaign mode
        function renderEnvironmentOptions() {
            const { indoor, outdoor } = state.generatedEnvironments;

            // Render indoor options
            elements.indoorOptions.innerHTML = indoor.map((env, idx) => `
                <button class="environment-option ${state.selectedEnvironments.indoor === idx ? 'selected' : ''}"
                        data-type="indoor" data-index="${idx}">
                    ${env.name || env}
                </button>
            `).join('');

            // Render outdoor options
            elements.outdoorOptions.innerHTML = outdoor.map((env, idx) => `
                <button class="environment-option ${state.selectedEnvironments.outdoor === idx ? 'selected' : ''}"
                        data-type="outdoor" data-index="${idx}">
                    ${env.name || env}
                </button>
            `).join('');

            // Add click handlers
            elements.indoorOptions.querySelectorAll('.environment-option').forEach(btn => {
                btn.addEventListener('click', () => selectEnvironment('indoor', parseInt(btn.dataset.index)));
            });

            elements.outdoorOptions.querySelectorAll('.environment-option').forEach(btn => {
                btn.addEventListener('click', () => selectEnvironment('outdoor', parseInt(btn.dataset.index)));
            });

            // Show section if we have environments and in campaign mode
            const hasEnvironments = indoor.length > 0 || outdoor.length > 0;
            elements.environmentSection.style.display = (hasEnvironments && state.mode === 'campaign') ? 'block' : 'none';
        }

        function selectEnvironment(type, index) {
            // Toggle selection (click again to deselect)
            if (state.selectedEnvironments[type] === index) {
                state.selectedEnvironments[type] = null;
            } else {
                state.selectedEnvironments[type] = index;
            }

            // Update campaign environments based on selection
            updateCampaignEnvironments();
            renderEnvironmentOptions();
        }

        function updateCampaignEnvironments() {
            // When user selects an environment, generate 5 variations of it
            const { indoor, outdoor } = state.generatedEnvironments;
            const { indoor: selectedIndoor, outdoor: selectedOutdoor } = state.selectedEnvironments;

            if (selectedIndoor !== null && indoor[selectedIndoor]) {
                const base = indoor[selectedIndoor].name || indoor[selectedIndoor];
                state.campaignEnvironments.indoor = [
                    `${base}, wide establishing shot`,
                    `${base}, different angle with interesting shadows`,
                    `${base}, intimate corner framing`,
                    `${base}, architectural details visible`,
                    `${base}, soft natural light variation`
                ];
            } else {
                state.campaignEnvironments.indoor = [];
            }

            if (selectedOutdoor !== null && outdoor[selectedOutdoor]) {
                const base = outdoor[selectedOutdoor].name || outdoor[selectedOutdoor];
                state.campaignEnvironments.outdoor = [
                    `${base}, wide establishing shot`,
                    `${base}, different angle with golden hour light`,
                    `${base}, intimate framing near focal point`,
                    `${base}, environmental context visible`,
                    `${base}, dramatic sky or weather variation`
                ];
            } else {
                state.campaignEnvironments.outdoor = [];
            }

            state.currentIndoorIndex = 0;
            state.currentOutdoorIndex = 0;
            state.useIndoorNext = Math.random() > 0.5;

            console.log('[Environments] Updated - Indoor:', state.campaignEnvironments.indoor.length, 'Outdoor:', state.campaignEnvironments.outdoor.length);
        }

        // Render Output Grid
        function renderOutputGrid() {
            // Build pose options with optgroups for visual grouping
            const pdpPoses = POSES.filter(p => p.category === 'pdp');
            const lifestylePoses = POSES.filter(p => p.category === 'lifestyle');

            const poseOptions = `
                <optgroup label="PDP">
                    ${pdpPoses.map(pose => `<option value="${pose.id}">${pose.name}</option>`).join('')}
                </optgroup>
                <optgroup label="Studio">
                    ${lifestylePoses.map(pose => `<option value="${pose.id}">${pose.name}</option>`).join('')}
                </optgroup>
            `;

            // Build framing options
            const framingOptions = FRAMING_OPTIONS.map(f =>
                `<option value="${f.id}">${f.name}</option>`
            ).join('');

            elements.outputGrid.innerHTML = state.outputs.map((output, i) => {
                const isActive = output.enabled;
                const isCasting = state.mode === 'casting';

                return `
                    <div class="output-slot ${isActive ? 'active' : ''}" data-index="${i}">
                        <div class="output-slot-header">
                            <span class="output-slot-number">#${i + 1}</span>
                            <div class="output-toggle ${isActive ? 'active' : ''}" data-index="${i}"></div>
                        </div>
                        <select class="output-pose-select" data-index="${i}" ${!isActive ? 'disabled' : ''}>
                            ${poseOptions}
                        </select>
                        ${isCasting ? `
                        <select class="output-framing-select" data-index="${i}" ${!isActive ? 'disabled' : ''}>
                            ${framingOptions}
                        </select>
                        <select class="output-casting-style-select" data-index="${i}" ${!isActive ? 'disabled' : ''}>
                            <option value="studio">Studio</option>
                            <option value="campaign">Campaign</option>
                        </select>
                        ` : ''}
                        <div class="output-people-row">
                            <span class="output-people-label">People</span>
                            <div class="output-people-controls">
                                <button class="output-people-btn" data-action="decrease" data-index="${i}" ${!isActive || output.peopleCount <= 0 ? 'disabled' : ''}>âˆ’</button>
                                <span class="output-people-count">${output.peopleCount}</span>
                                <button class="output-people-btn" data-action="increase" data-index="${i}" ${!isActive || output.peopleCount >= 4 ? 'disabled' : ''}>+</button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            // Set initial pose values
            elements.outputGrid.querySelectorAll('.output-pose-select').forEach(select => {
                const index = parseInt(select.dataset.index);
                select.value = state.outputs[index].poseId;
            });

            // Set initial framing values (casting mode only)
            elements.outputGrid.querySelectorAll('.output-framing-select').forEach(select => {
                const index = parseInt(select.dataset.index);
                select.value = state.outputs[index].framingId || 'headshot';
            });

            // Set initial casting style values (casting mode only)
            elements.outputGrid.querySelectorAll('.output-casting-style-select').forEach(select => {
                const index = parseInt(select.dataset.index);
                select.value = state.outputs[index].castingStyle || 'studio';
            });

            // Toggle handlers
            elements.outputGrid.querySelectorAll('.output-toggle').forEach(toggle => {
                toggle.addEventListener('click', () => {
                    const index = parseInt(toggle.dataset.index);
                    state.outputs[index].enabled = !state.outputs[index].enabled;
                    renderOutputGrid();
                    updateUI();
                });
            });

            // Pose select handlers
            elements.outputGrid.querySelectorAll('.output-pose-select').forEach(select => {
                select.addEventListener('change', () => {
                    const index = parseInt(select.dataset.index);
                    state.outputs[index].poseId = select.value;
                });
            });

            // Framing select handlers (casting mode only)
            elements.outputGrid.querySelectorAll('.output-framing-select').forEach(select => {
                select.addEventListener('change', () => {
                    const index = parseInt(select.dataset.index);
                    state.outputs[index].framingId = select.value;
                });
            });

            // Casting style select handlers (casting mode only)
            elements.outputGrid.querySelectorAll('.output-casting-style-select').forEach(select => {
                select.addEventListener('change', () => {
                    const index = parseInt(select.dataset.index);
                    state.outputs[index].castingStyle = select.value;
                });
            });

            // People count handlers
            elements.outputGrid.querySelectorAll('.output-people-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const index = parseInt(btn.dataset.index);
                    const action = btn.dataset.action;

                    if (action === 'increase' && state.outputs[index].peopleCount < 4) {
                        state.outputs[index].peopleCount++;
                    } else if (action === 'decrease' && state.outputs[index].peopleCount > 0) {
                        state.outputs[index].peopleCount--;
                    }

                    renderOutputGrid();
                    updateUI();
                });
            });
        }

        // Setup event listeners
        function setupEventListeners() {
            // Mode tabs
            elements.modeTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const newMode = tab.dataset.mode;
                    if (newMode === state.mode) return;

                    // Switch mode
                    state.mode = newMode;

                    // Reset talent selection when switching modes
                    state.selectedTalent = [];
                    state.heroTalent = null;
                    state.supportingTalent = [];

                    // Update tab styling
                    elements.modeTabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');

                    renderTalentGrid();
                    updateUI();
                });
            });

            // File input
            elements.moodboardInput.addEventListener('change', (e) => {
                const startIndex = e.target.dataset.startIndex ? parseInt(e.target.dataset.startIndex) : null;
                handleFileUpload(Array.from(e.target.files), startIndex);
                e.target.value = '';
            });

            // Clear moodboard
            elements.clearMoodboard.addEventListener('click', () => {
                state.moodboardImages = new Array(24).fill(null);
                state.analysis = null;
                elements.analyzeBtn.textContent = 'Analyze Mood Board';
                elements.analyzeBtn.classList.remove('analyzed');
                renderMoodboardGrid();
                updateUI();
            });

            // Style input
            elements.styleInput.addEventListener('input', (e) => {
                state.styleInput = e.target.value;
                // Reset analysis when style input changes
                if (state.analysis) {
                    state.analysis = null;
                    elements.analyzeBtn.classList.remove('analyzed');
                }
                updateUI();
            });

            // Aspect ratio buttons
            elements.aspectButtons.querySelectorAll('.aspect-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    elements.aspectButtons.querySelectorAll('.aspect-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.aspectRatio = btn.dataset.ratio;
                });
            });

            // Resolution buttons
            const resolutionButtons = document.getElementById('resolution-buttons');
            resolutionButtons.querySelectorAll('.aspect-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    resolutionButtons.querySelectorAll('.aspect-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.resolution = btn.dataset.res;
                });
            });

            // Analyze button
            elements.analyzeBtn.addEventListener('click', handleAnalyze);

            // Generate button
            elements.generateBtn.addEventListener('click', handleGenerate);

            // Randomize outputs button (casting mode)
            elements.randomizeOutputsBtn.addEventListener('click', () => {
                // Get available poses (pdp + lifestyle only, no detail)
                const availablePoses = POSES.filter(p => p.category === 'pdp' || p.category === 'lifestyle');

                // Check if any outputs are enabled
                const hasEnabledOutputs = state.outputs.some(o => o.enabled);

                // If none enabled, enable random number (3-6) of outputs
                if (!hasEnabledOutputs) {
                    const numToEnable = Math.floor(Math.random() * 4) + 3; // 3-6 outputs
                    const indices = [];
                    while (indices.length < numToEnable) {
                        const idx = Math.floor(Math.random() * state.outputs.length);
                        if (!indices.includes(idx)) indices.push(idx);
                    }
                    indices.forEach(idx => state.outputs[idx].enabled = true);
                }

                state.outputs.forEach(output => {
                    if (output.enabled) {
                        // Randomize framing
                        output.framingId = FRAMING_OPTIONS[Math.floor(Math.random() * FRAMING_OPTIONS.length)].id;
                        // Randomize casting style
                        output.castingStyle = Math.random() > 0.5 ? 'studio' : 'campaign';
                        // Randomize pose
                        output.poseId = availablePoses[Math.floor(Math.random() * availablePoses.length)].id;
                    }
                });
                renderOutputGrid();
            });

            // Lightbox
            document.getElementById('lightbox-close').addEventListener('click', closeLightbox);
            elements.lightbox.addEventListener('click', (e) => {
                if (e.target === elements.lightbox) closeLightbox();
            });

            document.getElementById('lightbox-download').addEventListener('click', () => {
                const result = state.results[state.lightboxIndex];
                const now = new Date();
                const yy = String(now.getFullYear()).slice(-2);
                const mm = String(now.getMonth() + 1).padStart(2, '0');
                const dd = String(now.getDate()).padStart(2, '0');
                const hh = String(now.getHours()).padStart(2, '0');
                const min = String(now.getMinutes()).padStart(2, '0');
                const num = String(state.lightboxIndex + 1).padStart(2, '0');
                downloadFile(result.url, `Setset_Social_${yy}${mm}${dd}_${hh}${min}_${num}.png`);
            });

            // Keyboard
            document.addEventListener('keydown', (e) => {
                if (!elements.lightbox.classList.contains('visible')) return;
                if (e.key === 'Escape') closeLightbox();
                if (e.key === 'ArrowLeft' && state.lightboxIndex > 0) {
                    state.lightboxIndex--;
                    updateLightboxContent();
                }
                if (e.key === 'ArrowRight' && state.lightboxIndex < state.results.length - 1) {
                    state.lightboxIndex++;
                    updateLightboxContent();
                }
            });
        }

        // Update UI state
        function updateUI() {
            const isCasting = state.mode === 'casting';
            const hasTalent = isCasting ? !!state.heroTalent : state.selectedTalent.length > 0;
            const hasMoodboard = state.moodboardImages.some(img => img && img.selected !== false);
            const hasStyleText = state.styleInput.trim().length > 0;
            const activeOutputs = state.outputs.filter(o => o.enabled);
            const hasOutputs = activeOutputs.length > 0;

            // Enable/disable analyze button - can analyze with images OR text-only
            elements.analyzeBtn.disabled = !hasMoodboard && !hasStyleText;

            // Update analyze button text based on what we're analyzing
            if (state.analysis) {
                elements.analyzeBtn.textContent = 'Re-analyze Style';
            } else if (hasMoodboard && hasStyleText) {
                elements.analyzeBtn.textContent = 'Analyze Style';
            } else if (hasMoodboard) {
                elements.analyzeBtn.textContent = 'Analyze Mood Board';
            } else if (hasStyleText) {
                elements.analyzeBtn.textContent = 'Analyze Style Text';
            } else {
                elements.analyzeBtn.textContent = 'Analyze Style';
            }

            // Enable/disable generate button
            // Casting mode: only needs talent and outputs (no moodboard/analysis required)
            // Other modes: need style source (moodboard or text) AND analysis
            const hasStyleSource = hasMoodboard || hasStyleText;
            const canGenerate = isCasting
                ? (hasTalent && hasOutputs)
                : (hasTalent && hasStyleSource && hasOutputs && state.analysis);
            elements.generateBtn.disabled = !canGenerate;

            // Hide analyze button and moodboard section in casting mode
            elements.analyzeBtn.style.display = isCasting ? 'none' : 'inline-flex';
            if (elements.moodboardSection) {
                elements.moodboardSection.style.display = isCasting ? 'none' : 'block';
            }

            // Update generate button text
            const totalImages = activeOutputs.length;
            let btnText = `Generate ${totalImages} image${totalImages !== 1 ? 's' : ''}`;
            elements.generateBtnText.textContent = btnText;

            // Update output hint based on mode
            if (state.mode === 'ecommerce') {
                elements.outputHint.textContent = 'E-commerce: White studio background. Toggle slots, select pose and people count.';
            } else if (state.mode === 'campaign') {
                elements.outputHint.textContent = 'Campaign: Environmental backgrounds from mood board. Toggle slots, select pose and people count.';
            } else {
                elements.outputHint.textContent = 'Casting: Select talent and generate. Mood & style randomized from editorial pool.';
            }

            // Show/hide randomize button (only in casting mode)
            elements.randomizeOutputsBtn.style.display = isCasting ? 'inline-flex' : 'none';
        }

        // Loading animation
        function startLoadingAnimation(progressText = 'Preparing...') {
            elements.inlineLoader.classList.add('visible');
            elements.loaderProgress.textContent = progressText;

            const initialIdx = Math.floor(Math.random() * STUDIO_MESSAGES.length);
            elements.loaderMessage.textContent = STUDIO_MESSAGES[initialIdx];
            lastMessageIndex = initialIdx;

            loadingInterval = setInterval(() => {
                let idx;
                do {
                    idx = Math.floor(Math.random() * STUDIO_MESSAGES.length);
                } while (idx === lastMessageIndex && STUDIO_MESSAGES.length > 1);
                lastMessageIndex = idx;

                elements.loaderMessage.classList.add('fade-out');
                elements.loaderMessage.classList.remove('fade-in');

                setTimeout(() => {
                    elements.loaderMessage.textContent = STUDIO_MESSAGES[idx];
                    elements.loaderMessage.classList.remove('fade-out');
                    elements.loaderMessage.classList.add('fade-in');
                }, 250);
            }, 2000);
        }

        function updateLoadingProgress(text) {
            elements.loaderProgress.textContent = text;
        }

        function stopLoadingAnimation() {
            if (loadingInterval) {
                clearInterval(loadingInterval);
                loadingInterval = null;
            }
            elements.inlineLoader.classList.remove('visible');
        }

        // Handle Analyze
        async function handleAnalyze() {
            const moodImages = state.moodboardImages.filter(img => img && img.selected !== false);
            const styleText = state.styleInput.trim();
            const hasImages = moodImages.length > 0;
            const hasText = styleText.length > 0;

            if (!hasImages && !hasText) return;

            if (hasImages) {
                startLoadingAnimation(`Analyzing ${moodImages.length} moodboard image${moodImages.length > 1 ? 's' : ''}...`);
            } else {
                startLoadingAnimation('Analyzing style description...');
            }

            try {
                let analysisResult = '';

                if (hasImages) {
                    // Upload moodboard images
                    const uploadPromises = moodImages.map(img => api.uploadBase64(img.url));
                    const uploadResults = await Promise.all(uploadPromises);
                    const moodboardUrls = uploadResults.map(r => r.url);

                    // Analysis prompt for images
                    const analysisPrompt = `Analyze these images and create a comprehensive style guide for image generation. Write as a single flowing paragraph that can be used directly in prompts. Include:

1. CLOTHING AESTHETIC: Describe the overall fashion aesthetic and vibe (minimalist, luxury, streetwear, bohemian, tailored, relaxed, etc.). Focus on the STYLE and MOOD of the clothing rather than specific items. Mention textures, fits, silhouettes, and color palettes that define the look. Do NOT list specific garments - describe the fashion direction instead.

2. PHOTOGRAPHY STYLE: Is it analog/film-like or digital? Note any grain, color grading, filters, or processing effects. Describe color palette and tones (warm, cool, muted, saturated).

3. LIGHTING: Describe the lighting approach (natural, studio, dramatic, soft, harsh, backlit, etc.).

4. POSES & COMPOSITION: Note typical body language, poses, framing, and compositional elements.

5. MOOD & ENVIRONMENT: Describe the atmosphere, settings, and overall mood.

IMPORTANT:
- Do NOT mention specific clothing items like "paisley jacket" or "blue dress" - instead describe the style aesthetic
- Do NOT mention any brand names, designer labels, or logos
- Focus on the VIBE and AESTHETIC rather than specific pieces
- Write one cohesive paragraph that flows naturally and can generate VARIED outfits in the same style`;

                    const result = await api.analyzeImages(moodboardUrls, analysisPrompt);
                    if (result.content) {
                        analysisResult = result.content;
                    }
                } else if (hasText) {
                    // Text-only analysis - generate style guide from brand/aesthetic description
                    const textPrompt = `Based on this style description: "${styleText}"

Create a comprehensive fashion style guide for image generation. Write as a single flowing paragraph. Describe:

1. CLOTHING AESTHETIC: The overall fashion vibe, silhouettes, fits, textures, and color palettes that define this look. Be specific about the style direction.

2. PHOTOGRAPHY STYLE: What kind of photography would suit this aesthetic (clean digital, film-like, editorial, etc.).

3. MOOD: The overall atmosphere and feeling.

IMPORTANT:
- Do NOT mention any brand names, designer labels, or logos in your response
- Do NOT say "in the style of [brand]" - instead describe the aesthetic qualities
- Focus on describing the LOOK and FEEL, not the brand
- Write one cohesive paragraph that can generate VARIED outfits in this style`;

                    // Use a simple text analysis via the analyze endpoint with no images
                    const result = await fetch('/api/analyze', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            images: [],
                            prompt: textPrompt
                        })
                    }).then(r => r.json());

                    if (result.content) {
                        analysisResult = result.content;
                    }
                }

                if (analysisResult) {
                    state.analysis = analysisResult;
                    console.log('Style analysis stored:', state.analysis);

                    // Generate outfit pools based on the analysis
                    updateLoadingProgress('Generating outfit variations...');

                    // Count how many outfits we need per gender based on active outputs
                    const activeOutputs = state.outputs.filter(o => o.enabled);
                    // Generate more than needed for variety
                    const outfitCount = Math.max(activeOutputs.length + 4, 8);

                    try {
                        const outfitResponse = await fetch('/api/generate-outfits', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                brandAnalysis: analysisResult,
                                styleText: styleText,
                                femaleCount: outfitCount,
                                maleCount: outfitCount
                            })
                        });

                        const outfits = await outfitResponse.json();

                        if (outfits.female && outfits.male) {
                            state.outfits.female = outfits.female;
                            state.outfits.male = outfits.male;
                            state.outfits.usedFemale = 0;
                            state.outfits.usedMale = 0;
                            console.log(`Outfits generated: ${outfits.female.length} female, ${outfits.male.length} male`);
                            console.log('Female outfits sample:', outfits.female.slice(0, 2));
                            console.log('Male outfits sample:', outfits.male.slice(0, 2));
                        } else {
                            console.warn('Outfits response missing female or male pools:', outfits);
                        }
                    } catch (outfitError) {
                        console.error('Outfit generation error:', outfitError);
                        // Continue without outfits - will use generic clothing instruction
                    }

                    // Generate environment options for Campaign mode
                    if (state.mode === 'campaign') {
                        updateLoadingProgress('Generating environment options...');
                        try {
                            const envResponse = await fetch('/api/generate-environments', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    brandAnalysis: analysisResult,
                                    styleText: styleText
                                })
                            });
                            const environments = await envResponse.json();
                            if (environments.indoor && environments.outdoor) {
                                state.generatedEnvironments.indoor = environments.indoor;
                                state.generatedEnvironments.outdoor = environments.outdoor;
                                // Auto-select first of each
                                state.selectedEnvironments.indoor = 0;
                                state.selectedEnvironments.outdoor = 0;
                                console.log(`Environments generated: ${environments.indoor.length} indoor, ${environments.outdoor.length} outdoor`);
                                updateCampaignEnvironments();
                                renderEnvironmentOptions();
                            }
                        } catch (envError) {
                            console.error('Environment generation error:', envError);
                        }
                    }
                }

                elements.analyzeBtn.textContent = 'Re-analyze';
                elements.analyzeBtn.classList.add('analyzed');

                updateUI();
            } catch (error) {
                console.error('Analysis error:', error);
                alert('Failed to analyze: ' + error.message);
            } finally {
                stopLoadingAnimation();
            }
        }

        // Handle Generate
        async function handleGenerate() {
            // Casting mode doesn't require analysis (uses random editorial moods)
            if (!state.analysis && state.mode !== 'casting') {
                alert('Please analyze the mood board first');
                return;
            }

            const activeOutputs = state.outputs
                .map((o, i) => ({ ...o, index: i }))
                .filter(o => o.enabled);

            if (activeOutputs.length === 0) return;

            state.results = [];
            elements.resultsGrid.innerHTML = '';
            elements.progressSection.classList.add('visible');
            startLoadingAnimation(`Generating ${activeOutputs.length} images...`);

            // Generate outfits if pools are empty but we have analysis (e.g., pre-loaded from collection)
            if ((!state.outfits.female || state.outfits.female.length === 0) && state.analysis) {
                console.log('[Generate] Outfit pools empty, generating outfits from analysis...');
                updateLoadingProgress('Generating outfit variations...');
                const outfitCount = Math.max(activeOutputs.length + 4, 8);
                try {
                    const outfitResponse = await fetch('/api/generate-outfits', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            brandAnalysis: state.analysis,
                            styleText: state.styleInput,
                            femaleCount: outfitCount,
                            maleCount: outfitCount
                        })
                    });
                    const outfits = await outfitResponse.json();
                    if (outfits.female && outfits.male) {
                        state.outfits.female = outfits.female;
                        state.outfits.male = outfits.male;
                        console.log(`[Generate] Outfits generated: ${outfits.female.length} female, ${outfits.male.length} male`);
                    }
                } catch (err) {
                    console.error('[Generate] Outfit generation error:', err);
                }
            }

            // Reset outfit counters for fresh distribution each generation
            state.outfits.usedFemale = 0;
            state.outfits.usedMale = 0;
            console.log(`[Generate] Outfit pools: ${state.outfits.female?.length || 0} female, ${state.outfits.male?.length || 0} male`);

            // Reset environment indices for campaign mode cycling
            state.currentIndoorIndex = 0;
            state.currentOutdoorIndex = 0;
            state.useIndoorNext = Math.random() > 0.5; // Random start each generation
            if (state.campaignEnvironments.indoor.length > 0) {
                console.log(`[Generate] Campaign locations - Indoor: ${state.campaignEnvironments.indoor[0]?.substring(0, 40)}..., Outdoor: ${state.campaignEnvironments.outdoor[0]?.substring(0, 40)}...`);
            }

            let completed = 0;
            const total = activeOutputs.length;
            elements.progressCount.textContent = `0 / ${total}`;
            elements.progressBar.style.width = '0%';

            // Get talent based on mode
            const isCasting = state.mode === 'casting';
            let allTalentData = [];

            if (isCasting) {
                // Hero is always included
                const heroData = TALENT.find(t => t.id === state.heroTalent);
                const supportingData = state.supportingTalent.map(id => TALENT.find(t => t.id === id)).filter(Boolean);
                allTalentData = [heroData, ...supportingData].filter(Boolean);
            } else {
                allTalentData = state.selectedTalent.map(id => TALENT.find(t => t.id === id)).filter(Boolean);
            }

            // Fisher-Yates shuffle for proper randomization
            function shuffle(array) {
                const arr = [...array];
                for (let i = arr.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                }
                return arr;
            }

            // Separate by gender, shuffle each, then interleave for fallback pool
            const females = shuffle(allTalentData.filter(t => t.gender === 'female'));
            const males = shuffle(allTalentData.filter(t => t.gender === 'male'));

            // Interleave: female, male, female, male... (or male, female if more males)
            const interleaved = [];
            const maxLen = Math.max(females.length, males.length);
            for (let i = 0; i < maxLen; i++) {
                if (i < females.length) interleaved.push(females[i]);
                if (i < males.length) interleaved.push(males[i]);
            }

            console.log(`[Talent] Selected: ${females.length} female, ${males.length} male, interleaved: ${interleaved.map(t => t.name).join(', ')}`);

            const talentAssignments = new Map();

            // Track usage count for each talent to ensure even distribution
            const talentUsageCount = new Map();
            allTalentData.forEach(t => talentUsageCount.set(t.id, 0));

            // Pre-assign talent to ALL slots, ensuring maximum variety
            // Strategy: For each slot, pick the least-used talent(s) that maintain gender balance
            // EXCEPTION: In casting mode, single-person slots ALWAYS use the hero
            activeOutputs.forEach((output, idx) => {
                const count = output.peopleCount;
                if (count === 0) return;

                if (count === 1) {
                    // CASTING MODE: Single person slots always use the hero
                    if (isCasting) {
                        const hero = allTalentData[0]; // Hero is always first in casting mode
                        talentUsageCount.set(hero.id, talentUsageCount.get(hero.id) + 1);
                        talentAssignments.set(output.index, [hero]);
                        return;
                    }

                    // E-commerce/Campaign: pick least-used talent, alternating genders
                    const targetGender = idx % 2 === 0 ? 'female' : 'male';
                    const genderPool = allTalentData.filter(t => t.gender === targetGender);
                    const fallbackPool = allTalentData.filter(t => t.gender !== targetGender);

                    // Sort by usage count (least used first)
                    const sortByUsage = (pool) => [...pool].sort((a, b) =>
                        talentUsageCount.get(a.id) - talentUsageCount.get(b.id)
                    );

                    let chosen;
                    const sortedGenderPool = sortByUsage(genderPool);
                    const sortedFallbackPool = sortByUsage(fallbackPool);

                    if (sortedGenderPool.length > 0) {
                        chosen = sortedGenderPool[0];
                    } else if (sortedFallbackPool.length > 0) {
                        chosen = sortedFallbackPool[0];
                    } else {
                        chosen = interleaved[0];
                    }

                    talentUsageCount.set(chosen.id, talentUsageCount.get(chosen.id) + 1);
                    talentAssignments.set(output.index, [chosen]);
                } else {
                    // Multi-person shots
                    // CASTING MODE: Hero is always first, then add supporting cast
                    if (isCasting) {
                        const hero = allTalentData[0];
                        const chosen = [hero];
                        talentUsageCount.set(hero.id, talentUsageCount.get(hero.id) + 1);

                        // Get supporting cast (everyone except hero), sorted by usage
                        const supporting = [...allTalentData]
                            .filter(t => t.id !== hero.id)
                            .sort((a, b) => talentUsageCount.get(a.id) - talentUsageCount.get(b.id));

                        // Add least-used supporting cast members
                        for (let i = 0; i < count - 1 && i < supporting.length; i++) {
                            chosen.push(supporting[i]);
                            talentUsageCount.set(supporting[i].id, talentUsageCount.get(supporting[i].id) + 1);
                        }

                        talentAssignments.set(output.index, chosen);
                        return;
                    }

                    // E-commerce/Campaign: pick N least-used talents, trying to balance genders
                    const sortedByUsage = [...allTalentData].sort((a, b) =>
                        talentUsageCount.get(a.id) - talentUsageCount.get(b.id)
                    );

                    const chosen = [];
                    const femalesNeeded = Math.ceil(count / 2);
                    const malesNeeded = count - femalesNeeded;

                    // Get least-used females
                    const availableFemales = sortedByUsage.filter(t => t.gender === 'female');
                    chosen.push(...availableFemales.slice(0, femalesNeeded));

                    // Get least-used males
                    const availableMales = sortedByUsage.filter(t => t.gender === 'male');
                    chosen.push(...availableMales.slice(0, malesNeeded));

                    // If we don't have enough of one gender, fill from the other
                    while (chosen.length < count && chosen.length < allTalentData.length) {
                        const remaining = sortedByUsage.filter(t => !chosen.includes(t));
                        if (remaining.length > 0) {
                            chosen.push(remaining[0]);
                        } else {
                            break;
                        }
                    }

                    // Update usage counts
                    chosen.forEach(t => {
                        talentUsageCount.set(t.id, talentUsageCount.get(t.id) + 1);
                    });

                    talentAssignments.set(output.index, chosen);
                }
            });

            console.log('[Talent Distribution]', [...talentAssignments.entries()].map(([idx, talents]) =>
                `Slot ${idx + 1}: ${talents.map(t => t.name).join(', ')}`
            ).join(' | '));

            // Helper to get talent for an output
            function getTalentForOutput(output) {
                const count = output.peopleCount;
                if (count === 0) return [];

                // Use pre-assigned talent for all slots
                if (talentAssignments.has(output.index)) {
                    return talentAssignments.get(output.index);
                }

                // Fallback (shouldn't happen)
                if (isCasting) {
                    // Hero is always first
                    const result = [allTalentData[0]]; // Hero
                    if (count > 1 && allTalentData.length > 1) {
                        // Add random supporting cast from interleaved pool
                        const supporting = interleaved.filter(t => t.id !== allTalentData[0].id);
                        result.push(...supporting.slice(0, count - 1));
                    }
                    return result;
                } else {
                    // Use interleaved pool to ensure gender mix in multi-person shots
                    return interleaved.slice(0, Math.min(count, interleaved.length));
                }
            }

            // Upload ALL talent images ONCE before generation starts
            console.log('Uploading talent images...');
            updateLoadingProgress('Uploading talent images...');
            const talentUrlMap = new Map();

            const uploadTalentPromises = allTalentData.map(async (talent) => {
                const url = talent.image;
                if (url.startsWith('/') || url.startsWith('./')) {
                    const response = await fetch(url);
                    const blob = await response.blob();
                    const file = new File([blob], 'image.png', { type: blob.type });
                    const result = await api.uploadImage(file);
                    talentUrlMap.set(talent.id, result.url);
                    console.log(`Uploaded ${talent.name}: ${result.url}`);
                } else {
                    talentUrlMap.set(talent.id, url);
                }
            });
            await Promise.all(uploadTalentPromises);
            console.log('All talent images uploaded!');
            updateLoadingProgress(`Generating ${activeOutputs.length} images...`);

            // Generate for each active output
            const startTime = Date.now();
            console.log(`[Parallel] Starting ${activeOutputs.length} requests at ${new Date().toLocaleTimeString()}`);

            const promises = activeOutputs.map(async (output) => {
                const slotStart = Date.now();
                try {
                    const talentForOutput = getTalentForOutput(output);
                    const pose = POSES.find(p => p.id === output.poseId) || POSES[0];

                    if (talentForOutput.length === 0) {
                        console.log('No talent for output, skipping...');
                        return;
                    }

                    // Build prompt (pass talent array for outfit assignment by gender)
                    const prompt = buildPrompt(output, talentForOutput, pose);

                    // Get pre-uploaded URLs for this output's talent
                    const imageUrls = talentForOutput.map(t => talentUrlMap.get(t.id));
                    console.log(`[Parallel] Slot ${output.index + 1} STARTED at +${Date.now() - startTime}ms`);

                    // Generate
                    const params = {
                        prompt,
                        image_urls: imageUrls,
                        num_images: 1,
                        aspect_ratio: state.aspectRatio,
                        resolution: state.resolution,
                        output_format: 'png'
                    };

                    const data = await api.remixImage('nano-pro', params);

                    if (data.images && data.images.length > 0) {
                        console.log(`[Parallel] Slot ${output.index + 1} FINISHED at +${Date.now() - startTime}ms (took ${Date.now() - slotStart}ms)`);
                        state.results.push({
                            url: data.images[0].url,
                            prompt,
                            type: state.mode.charAt(0).toUpperCase() + state.mode.slice(1),
                            pose: pose.name,
                            peopleCount: output.peopleCount
                        });
                        renderResults();
                    }
                } catch (error) {
                    console.error('Generation error:', error);
                }

                completed++;
                elements.progressCount.textContent = `${completed} / ${total}`;
                elements.progressBar.style.width = `${(completed / total) * 100}%`;
            });

            await Promise.all(promises);
            stopLoadingAnimation();
            elements.progressSection.classList.remove('visible');
        }

        // Build prompt based on mode and output
        function buildPrompt(output, talentArray, pose) {
            const numPeople = talentArray.length;
            let analysis = state.analysis || '';
            const styleInput = state.styleInput.trim();

            // Remove brand names first
            const brandBlacklist = [
                'Gucci', 'Louis Vuitton', 'LV', 'Prada', 'Chanel', 'Dior', 'HermÃ¨s', 'Hermes',
                'Burberry', 'Balenciaga', 'Versace', 'Fendi', 'Givenchy', 'Saint Laurent', 'YSL',
                'Bottega Veneta', 'Valentino', 'Alexander McQueen', 'Celine', 'Loewe', 'Moncler',
                'Off-White', 'Supreme', 'Nike', 'Adidas', 'Zara', 'H&M', 'Uniqlo', 'Reformation',
                'Rolex', 'Cartier', 'Tiffany', 'Bulgari', 'Van Cleef', 'Armani', 'Dolce & Gabbana',
                'Tom Ford', 'Marc Jacobs', 'Coach', 'Michael Kors', 'Kate Spade', 'Ralph Lauren',
                'Calvin Klein', 'Tommy Hilfiger', 'Hugo Boss', 'Stella McCartney', 'Acne Studios'
            ];
            brandBlacklist.forEach(brand => {
                const regex = new RegExp(`\\b${brand}\\b`, 'gi');
                analysis = analysis.replace(regex, '');
            });
            analysis = analysis.replace(/\s{2,}/g, ' ').trim();

            // Anti-splitting instruction
            const noSplitting = 'Generate ONE SINGLE unified image only. Do NOT create a collage, grid, triptych, diptych, split screen, or multiple panels. The output must be one continuous photograph.';

            // Get specific outfit based on talent gender
            const getOutfitForTalent = (talent) => {
                const gender = talent.gender || 'female';
                const pool = gender === 'male' ? state.outfits.male : state.outfits.female;
                const usedKey = gender === 'male' ? 'usedMale' : 'usedFemale';

                console.log(`[Outfit Debug] Talent: ${talent.name}, Gender: ${gender}, Pool size: ${pool?.length || 0}, Counter: ${state.outfits[usedKey]}`);

                if (pool && pool.length > 0) {
                    // Get next outfit from pool (cycling through)
                    const index = state.outfits[usedKey] % pool.length;
                    state.outfits[usedKey]++;
                    const outfit = pool[index];
                    console.log(`[Outfit Debug] Selected outfit #${index}: ${outfit?.substring(0, 60)}...`);
                    return outfit;
                }
                console.warn(`[Outfit Debug] No ${gender} outfits in pool!`);
                return null;
            };

            // Build outfit instruction based on talent
            let clothingInstruction = '';
            if (numPeople === 1) {
                const talent = talentArray[0];
                const outfit = getOutfitForTalent(talent);
                console.log(`Outfit assignment: ${talent.name} (${talent.gender}) -> ${outfit?.substring(0, 50)}...`);
                if (outfit) {
                    clothingInstruction = `OUTFIT: ${outfit}.`;
                } else if (styleInput) {
                    clothingInstruction = `Dress them in: ${styleInput}.`;
                } else {
                    clothingInstruction = 'Dress them in an outfit that fits the aesthetic.';
                }
            } else {
                // Multiple people - assign outfits to each
                const outfitDescriptions = talentArray.map((talent, i) => {
                    const outfit = getOutfitForTalent(talent);
                    if (outfit) {
                        return `Person ${i + 1}: ${outfit}`;
                    }
                    return null;
                }).filter(Boolean);

                if (outfitDescriptions.length > 0) {
                    clothingInstruction = `OUTFITS: ${outfitDescriptions.join('. ')}.`;
                } else if (styleInput) {
                    clothingInstruction = `Dress them in varied outfits: ${styleInput}.`;
                } else {
                    clothingInstruction = 'Dress each person in different outfits that fit the aesthetic.';
                }
            }

            // People text - critical for multi-person shots
            const peopleText = numPeople === 1
                ? 'this exact person from the reference image'
                : `these exact ${numPeople} people from the reference images together in the same shot`;

            // Style directive - always add to prompt if provided (e.g., "sunglasses on every shot")
            const styleDirective = styleInput ? `IMPORTANT STYLE DIRECTIVE: ${styleInput}.` : '';

            let prompt = '';

            // Get pose prompt from POSE_PROMPTS based on the selected pose
            const getPosePrompt = (poseId) => {
                // Check if POSE_PROMPTS exists and has this pose
                if (typeof POSE_PROMPTS !== 'undefined' && POSE_PROMPTS[poseId]) {
                    const prompts = POSE_PROMPTS[poseId];
                    // Pick a random variation from the pose's prompt templates
                    return prompts[Math.floor(Math.random() * prompts.length)];
                }
                // Fallback to pose-pools.js for generic poses
                if (typeof getRandomPose === 'function') {
                    return getRandomPose('ecom-editorial');
                }
                return 'standing naturally with relaxed posture, direct gaze';
            };

            // Map pose categories to determine if it's a lifestyle/editorial pose
            const isLifestylePose = pose && (
                pose.category === 'lifestyle' ||
                pose.id.includes('lifestyle') ||
                ['sitting', 'walking', 'leaning', 'editorial', 'pocket', 'brush', 'adjust', 'laying', 'armscrossed'].some(
                    type => pose.id.toLowerCase().includes(type) || pose.name.toLowerCase().includes(type)
                )
            );

            // Get the specific pose prompt for this output's selected pose
            const selectedPosePrompt = getPosePrompt(pose.id);

            // Multi-person pose variety instruction
            const poseVarietyInstruction = numPeople > 1
                ? 'IMPORTANT: Give each person a DIFFERENT natural pose and body position. Vary their stance, arm positions, and where they look. Avoid having everyone do the same pose or lean into each other. Create visual interest through contrasting poses.'
                : '';

            if (state.mode === 'ecommerce') {
                // E-commerce: Always white studio background
                const groupInstruction = numPeople > 1
                    ? `Place ${peopleText} standing together in the same frame. ${poseVarietyInstruction} `
                    : '';

                // Use the selected pose prompt, replacing [PRODUCT_DESCRIPTION] with outfit
                let poseInstruction = selectedPosePrompt.replace('[PRODUCT_DESCRIPTION]', clothingInstruction);

                // Build prompt using the actual selected pose
                prompt = `${noSplitting} ${styleDirective} ${groupInstruction}${poseInstruction} ${analysis}. Clean white studio background, professional e-commerce lighting.`;
            } else if (state.mode === 'campaign') {
                // Campaign: Alternate between indoor and outdoor locations
                // Use the selected pose but in environmental setting
                let poseInstruction = selectedPosePrompt
                    .replace('[PRODUCT_DESCRIPTION]', clothingInstruction)
                    .replace(/white studio/gi, 'editorial campaign setting')
                    .replace(/studio/gi, 'location');

                // Alternate between indoor and outdoor, cycling through variations
                let environmentDescription = '';
                const hasIndoor = state.campaignEnvironments.indoor.length > 0;
                const hasOutdoor = state.campaignEnvironments.outdoor.length > 0;

                if (hasIndoor || hasOutdoor) {
                    if (state.useIndoorNext && hasIndoor) {
                        // Get next indoor variation
                        const idx = state.currentIndoorIndex % state.campaignEnvironments.indoor.length;
                        environmentDescription = state.campaignEnvironments.indoor[idx];
                        state.currentIndoorIndex++;
                        console.log(`[Campaign] Indoor variation ${idx + 1}: ${environmentDescription.substring(0, 50)}...`);
                    } else if (hasOutdoor) {
                        // Get next outdoor variation
                        const idx = state.currentOutdoorIndex % state.campaignEnvironments.outdoor.length;
                        environmentDescription = state.campaignEnvironments.outdoor[idx];
                        state.currentOutdoorIndex++;
                        console.log(`[Campaign] Outdoor variation ${idx + 1}: ${environmentDescription.substring(0, 50)}...`);
                    }
                    // Alternate for next image
                    state.useIndoorNext = !state.useIndoorNext;
                }

                const environmentClause = environmentDescription
                    ? `Shot in: ${environmentDescription}.`
                    : 'Use the environmental style, locations, and mood from the reference images.';

                prompt = `${noSplitting} ${styleDirective} Place ${peopleText} in an editorial campaign setting. ${poseVarietyInstruction} ${poseInstruction} ${analysis}. ${environmentClause} Fashion editorial style, creative composition, dramatic lighting, high-end fashion campaign aesthetic.`;
            } else if (state.mode === 'casting') {
                // Casting: Editorial variety with random moods from curated pool
                // Get gender of primary talent (hero) for mood selection
                const primaryGender = talentArray[0]?.gender || 'female';

                // Get random editorial mood based on gender
                const mood = getRandomEditorialMood(primaryGender);
                console.log(`[Casting] Selected mood: ${mood.name} for ${primaryGender}`);

                // Get framing from output slot - this controls body composition
                const framing = getFramingById(output.framingId || 'headshot');
                console.log(`[Casting] Framing: ${framing.name}`);

                // Get casting style (studio or campaign)
                const castingStyle = output.castingStyle || 'studio';
                console.log(`[Casting] Style: ${castingStyle}`);

                // Get pose instruction but strip out body framing words (framing selector takes precedence)
                let poseInstruction = selectedPosePrompt.replace('[PRODUCT_DESCRIPTION]', clothingInstruction);
                // Remove conflicting framing terms from pose - framing selector controls this
                poseInstruction = poseInstruction
                    .replace(/Full-body portrait/gi, 'Portrait')
                    .replace(/full-body/gi, '')
                    .replace(/full body/gi, '')
                    .replace(/half-body/gi, '')
                    .replace(/half body/gi, '')
                    .replace(/three-quarter/gi, '')
                    .replace(/head to toe/gi, '')
                    .replace(/from waist up/gi, '')
                    .replace(/from thighs up/gi, '')
                    .replace(/from chest up/gi, '')
                    .replace(/close-up/gi, '')
                    .replace(/closeup/gi, '')
                    .replace(/headshot/gi, '')
                    .trim();
                console.log(`[Casting] Pose: ${pose.name}`);

                // Build the editorial prompt
                const groupInstruction = numPeople > 1
                    ? `Place ${peopleText} together in the frame. ${poseVarietyInstruction} `
                    : `Feature ${peopleText}. `;

                // Different background based on casting style
                const backgroundInstruction = castingStyle === 'studio'
                    ? 'Clean studio environment with professional lighting, seamless backdrop or simple studio setting.'
                    : 'Editorial campaign setting with environmental context, location-based backdrop.';

                // Framing comes FIRST to set the shot composition, then pose for body position
                prompt = `${noSplitting} ${styleDirective} ${groupInstruction}FRAMING: ${framing.prompt}. ${poseInstruction} ${backgroundInstruction} EDITORIAL STYLE: ${mood.prompt}. High-end fashion editorial photography.`;
            }

            return prompt;
        }

        // Render results
        function renderResults() {
            if (state.results.length === 0) {
                elements.resultsSection.classList.remove('visible');
                return;
            }

            elements.resultsSection.classList.add('visible');
            elements.resultsGrid.innerHTML = state.results.map((result, index) => `
                <div class="result-card" onclick="openLightbox(${index})">
                    <img src="${result.url}" alt="Result ${index + 1}">
                </div>
            `).join('');
        }

        // Lightbox
        window.openLightbox = function(index) {
            state.lightboxIndex = index;
            updateLightboxContent();
            elements.lightbox.classList.add('visible');
        };

        function updateLightboxContent() {
            const result = state.results[state.lightboxIndex];
            elements.lightboxImage.src = result.url;
            elements.lightboxType.textContent = result.type;
            elements.lightboxPose.textContent = result.pose;
            elements.lightboxPrompt.textContent = result.prompt;
        }

        function closeLightbox() {
            elements.lightbox.classList.remove('visible');
        }

        // Initialize
        init();
    </script>
</body>
</html>
