<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SocialSet v2</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ“±</text></svg>">
    <link rel="stylesheet" href="/shared/css/tokens.css">
    <link rel="stylesheet" href="/shared/css/base.css">
    <link rel="stylesheet" href="/shared/css/components.css">
    <style>
        .container {
            max-width: 1200px;
        }

        /* Mode Tabs - Main navigation */
        .mode-tabs {
            display: flex;
            gap: 0;
            margin-bottom: var(--space-lg);
            border-bottom: 2px solid var(--gainsboro);
        }

        .mode-tab {
            padding: 14px 32px;
            font-size: var(--text-md);
            font-weight: 600;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            color: var(--slate);
            cursor: pointer;
            transition: all var(--transition-fast);
            margin-bottom: -2px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .mode-tab:hover {
            color: var(--jet);
        }

        .mode-tab.active {
            color: var(--jet);
            border-bottom-color: var(--jet);
        }

        /* Section styling */
        .section {
            background: var(--white);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-md);
            padding: var(--space-md);
            margin-bottom: var(--space-md);
        }

        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--space-sm);
        }

        .section-title {
            font-size: var(--text-sm);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--carbon);
        }

        .section-badge {
            font-size: var(--text-2xs);
            padding: 2px 8px;
            border-radius: var(--radius-sm);
            background: var(--off-white);
            color: var(--slate);
        }

        .section-badge.required {
            background: var(--jet);
            color: var(--white);
        }

        .section-hint {
            font-size: var(--text-xs);
            color: var(--ash-grey);
            margin-top: var(--space-xs);
        }

        /* Talent Grid - 12 columns x 2 rows */
        .talent-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: var(--space-xs);
        }

        @media (min-width: 800px) {
            .talent-grid {
                grid-template-columns: repeat(12, 1fr);
            }
        }

        .talent-card {
            position: relative;
            aspect-ratio: 3/4;
            border-radius: var(--radius-sm);
            overflow: hidden;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all var(--transition-fast);
        }

        .talent-card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .talent-card:hover {
            border-color: var(--ash-grey);
        }

        .talent-card.selected {
            border-color: var(--jet);
        }

        .talent-card.selected::after {
            content: attr(data-badge);
            position: absolute;
            top: 4px;
            right: 4px;
            min-width: 20px;
            height: 20px;
            padding: 0 4px;
            background: var(--jet);
            color: var(--white);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 600;
        }

        .talent-card.hero {
            border-color: #dc2626;
        }

        .talent-card.hero::after {
            content: 'HERO';
            background: #dc2626;
        }

        .talent-card.supporting {
            border-color: #2563eb;
        }

        .talent-card.supporting::after {
            content: '+';
            background: #2563eb;
        }

        .talent-card.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .talent-card .talent-name {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 2px 4px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 9px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Talent Source Toggle */
        .talent-source-toggle {
            display: flex;
            gap: var(--space-xs);
            margin-bottom: var(--space-sm);
        }

        .talent-source-btn {
            flex: 1;
            padding: 8px 12px;
            font-size: var(--text-xs);
            font-weight: 500;
            background: var(--off-white);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-sm);
            color: var(--slate);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .talent-source-btn:hover {
            border-color: var(--ash-grey);
        }

        .talent-source-btn.active {
            background: var(--jet);
            border-color: var(--jet);
            color: var(--white);
        }

        /* Custom Talent Upload Grid */
        .custom-talent-grid {
            display: none;
        }

        .custom-talent-grid.visible {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: var(--space-xs);
        }

        @media (min-width: 800px) {
            .custom-talent-grid.visible {
                grid-template-columns: repeat(8, 1fr);
            }
        }

        .custom-talent-slot {
            aspect-ratio: 3/4;
            border: 2px dashed var(--gainsboro);
            border-radius: var(--radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            background: var(--off-white);
            transition: all var(--transition-fast);
        }

        .custom-talent-slot:hover {
            border-color: var(--ash-grey);
        }

        .custom-talent-slot.filled {
            border-style: solid;
            border-color: var(--jet);
        }

        .custom-talent-slot.filled img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .custom-talent-slot .slot-icon {
            font-size: 20px;
            color: var(--ash-grey);
        }

        .custom-talent-slot .remove-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 20px;
            height: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 12px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .custom-talent-slot.filled:hover .remove-btn {
            display: flex;
        }

        .custom-talent-slot .model-label {
            position: absolute;
            bottom: 4px;
            left: 4px;
            min-width: 24px;
            height: 24px;
            padding: 0 6px;
            background: var(--jet);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--transition-fast);
        }

        .custom-talent-slot .model-label:hover {
            background: #333;
            transform: scale(1.1);
        }

        .custom-talent-slot .model-label[data-model="A"] { background: #dc2626; }
        .custom-talent-slot .model-label[data-model="B"] { background: #2563eb; }
        .custom-talent-slot .model-label[data-model="C"] { background: #16a34a; }
        .custom-talent-slot .model-label[data-model="D"] { background: #9333ea; }

        /* Custom Talent Drag & Drop */
        .custom-talent-grid.drag-over {
            background: rgba(0, 0, 0, 0.03);
            border-radius: var(--radius-md);
        }

        .custom-talent-grid.drag-over .custom-talent-slot:not(.filled) {
            border-color: var(--jet);
            background: rgba(0, 0, 0, 0.05);
        }

        .custom-talent-slot.drag-over {
            border-color: var(--jet) !important;
            background: rgba(0, 0, 0, 0.08) !important;
        }

        .custom-talent-slot.dragging {
            opacity: 0.5;
        }

        /* Collection Picker */
        .collection-picker {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            margin-bottom: var(--space-sm);
            padding-bottom: var(--space-sm);
            border-bottom: 1px solid var(--gainsboro);
        }

        .collection-label {
            font-size: var(--text-xs);
            color: var(--slate);
            white-space: nowrap;
        }

        .collection-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .collection-chip {
            padding: 4px 10px;
            font-size: 11px;
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-sm);
            background: var(--off-white);
            color: var(--carbon);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .collection-chip:hover {
            border-color: var(--ash-grey);
            background: var(--white);
        }

        .collection-chip.active {
            border-color: var(--jet);
            background: var(--jet);
            color: var(--white);
        }

        /* Mood Board Grid */
        .moodboard-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: var(--space-xs);
        }

        @media (min-width: 800px) {
            .moodboard-grid {
                grid-template-columns: repeat(12, 1fr);
            }
        }

        .upload-slot {
            aspect-ratio: 3/4;
            border: 1px dashed var(--gainsboro);
            border-radius: var(--radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            background: var(--off-white);
            transition: all var(--transition-fast);
        }

        .upload-slot:hover {
            border-color: var(--ash-grey);
        }

        .upload-slot.filled {
            border-style: solid;
            border-color: transparent;
        }

        .upload-slot.filled img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .upload-slot .plus {
            font-size: 18px;
            font-weight: 300;
            color: var(--ash-grey);
        }

        .upload-slot .remove-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 20px;
            height: 20px;
            background: rgba(0,0,0,0.7);
            color: var(--white);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 12px;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .upload-slot.filled:hover .remove-btn {
            display: flex;
        }

        .upload-slot.deselected {
            opacity: 0.4;
        }

        .upload-slot.deselected img {
            filter: grayscale(100%);
        }

        /* Style input */
        .style-input-container {
            margin-top: var(--space-sm);
            display: flex;
            gap: var(--space-sm);
            align-items: stretch;
        }

        .style-input {
            flex: 1;
            padding: 10px 14px;
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-sm);
            font-size: var(--text-sm);
            font-family: inherit;
            resize: none;
            min-height: 40px;
        }

        .style-input:focus {
            outline: none;
            border-color: var(--jet);
        }

        .style-input::placeholder {
            color: var(--ash-grey);
        }

        /* Output Grid */
        .output-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: var(--space-sm);
        }

        @media (min-width: 600px) {
            .output-grid {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        @media (min-width: 900px) {
            .output-grid {
                grid-template-columns: repeat(6, 1fr);
            }
        }

        .output-slot {
            background: var(--white);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-sm);
            padding: var(--space-sm);
            display: flex;
            flex-direction: column;
            gap: var(--space-xs);
        }

        .output-slot.active {
            border-color: var(--ash-grey);
            background: var(--off-white);
        }

        .output-slot-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: var(--text-xs);
            color: var(--slate);
        }

        .output-slot-number {
            font-weight: 600;
        }

        .output-toggle {
            width: 32px;
            height: 18px;
            background: var(--gainsboro);
            border-radius: 9px;
            position: relative;
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .output-toggle.active {
            background: var(--jet);
        }

        .output-toggle::after {
            content: '';
            position: absolute;
            width: 14px;
            height: 14px;
            background: var(--white);
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: all var(--transition-fast);
        }

        .output-toggle.active::after {
            left: 16px;
        }

        .output-pose-select {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-xs);
            font-size: var(--text-xs);
            background: var(--white);
            cursor: pointer;
        }

        .output-pose-select:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .output-framing-select {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-xs);
            font-size: var(--text-xs);
            background: var(--white);
            cursor: pointer;
            margin-top: 4px;
        }

        .output-framing-select:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .output-selects-row {
            display: flex;
            gap: 4px;
        }

        .output-selects-row select {
            flex: 1;
        }

        .output-people-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: var(--space-xs);
        }

        .output-people-label {
            font-size: var(--text-xs);
            color: var(--slate);
        }

        .output-people-controls {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .output-people-btn {
            width: 22px;
            height: 22px;
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-xs);
            background: var(--white);
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--transition-fast);
        }

        .output-people-btn:hover:not(:disabled) {
            border-color: var(--jet);
        }

        .output-people-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .output-people-count {
            min-width: 20px;
            text-align: center;
            font-size: var(--text-sm);
            font-weight: 600;
        }

        /* Drag hover state */
        .moodboard-grid.drag-over {
            background: rgba(0, 0, 0, 0.03);
            border-radius: var(--radius-md);
        }

        .moodboard-grid.drag-over .upload-slot:not(.filled) {
            border-color: var(--jet);
            background: rgba(0, 0, 0, 0.05);
        }

        /* Inline loader */
        .inline-loader {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: var(--space-lg);
            background: var(--off-white);
            border-radius: var(--radius-md);
            margin-bottom: var(--space-md);
        }

        .inline-loader.visible {
            display: flex;
        }

        .loader-message {
            font-size: var(--text-lg);
            font-weight: 600;
            background: linear-gradient(90deg,
                rgba(0, 47, 167, 0.4) 0%,
                rgba(0, 47, 167, 1) 50%,
                rgba(0, 47, 167, 0.4) 100%);
            background-size: 200% 100%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: sweep 2s ease-in-out infinite;
        }

        .loader-message.fade-out {
            animation: fade-out 0.25s ease-out forwards;
        }

        .loader-message.fade-in {
            animation: fade-in 0.25s ease-out forwards, sweep 2s ease-in-out infinite;
        }

        @keyframes sweep {
            0% { background-position: 100% 0; }
            100% { background-position: -100% 0; }
        }

        @keyframes fade-out {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        @keyframes fade-in {
            0% { opacity: 0; }
            100% { opacity: 1; }
        }

        .loader-progress {
            font-size: var(--text-sm);
            color: var(--slate);
            margin-top: var(--space-xs);
        }

        /* Actions row */
        .actions-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--space-md);
            background: var(--white);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-md);
            margin-bottom: var(--space-md);
            flex-wrap: wrap;
            gap: var(--space-sm);
        }

        .settings-row {
            display: flex;
            align-items: center;
            gap: var(--space-lg);
            flex-wrap: wrap;
        }

        .setting-group {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }

        .setting-label {
            font-size: var(--text-xs);
            color: var(--slate);
            font-weight: 500;
        }

        .aspect-buttons {
            display: flex;
            gap: 4px;
        }

        .aspect-btn {
            padding: 6px 12px;
            font-size: var(--text-xs);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-sm);
            background: var(--off-white);
            color: var(--slate);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .aspect-btn:hover {
            border-color: var(--ash-grey);
        }

        .aspect-btn.active {
            background: var(--jet);
            color: var(--white);
            border-color: var(--jet);
        }

        .action-buttons {
            display: flex;
            gap: var(--space-sm);
        }

        .action-btn {
            padding: 12px 24px;
            font-size: 14px;
            min-width: 160px;
            text-align: center;
        }

        .btn-cost {
            opacity: 0.7;
            margin-left: 6px;
            font-weight: 400;
        }

        .btn.analyzed {
            background: #22c55e;
            border-color: #22c55e;
            color: var(--white);
        }

        .btn.analyzed:hover {
            background: #16a34a;
            border-color: #16a34a;
        }

        /* Results section */
        .results-section {
            display: none;
            margin-left: calc(-50vw + 50%);
            margin-right: calc(-50vw + 50%);
            padding-left: var(--space-lg);
            padding-right: var(--space-lg);
            max-width: 100vw;
        }

        .results-section.visible {
            display: block;
        }

        .results-header {
            max-width: 1200px;
            margin: 0 auto var(--space-md);
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: var(--space-md);
            max-width: 1400px;
            margin: 0 auto;
        }

        @media (min-width: 900px) {
            .results-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        .result-card {
            cursor: pointer;
            border-radius: var(--radius-md);
            overflow: hidden;
            transition: transform var(--transition-fast);
        }

        .result-card:hover {
            transform: scale(1.02);
        }

        .result-card img {
            width: 100%;
            aspect-ratio: 3/4;
            object-fit: cover;
        }

        /* Progress section */
        .progress-section {
            display: none;
            margin-bottom: var(--space-md);
        }

        .progress-section.visible {
            display: block;
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: var(--space-xs);
        }

        .progress-title {
            font-size: var(--text-xs);
            font-weight: 600;
            text-transform: uppercase;
            color: var(--slate);
        }

        .progress-count {
            font-size: var(--text-sm);
            font-weight: 600;
        }

        .progress-bar-container {
            height: 6px;
            background: var(--off-white);
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: var(--jet);
            border-radius: 3px;
            transition: width 0.3s ease;
            width: 0%;
        }

        input[type="file"] {
            display: none;
        }

        /* Pose dropdown optgroup styling */
        .output-pose-select optgroup {
            font-weight: 600;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.03em;
            color: var(--slate);
            background: var(--off-white);
            padding: 8px 0 4px 0;
        }

        .output-pose-select option {
            font-weight: 400;
            font-size: 13px;
            text-transform: none;
            letter-spacing: normal;
            color: var(--carbon);
            background: var(--white);
            padding: 4px 8px;
        }

        /* Environment Picker */
        .environment-picker-container {
            margin-top: var(--space-md);
            padding: var(--space-md);
            background: var(--off-white);
            border-radius: var(--radius-md);
            border: 1px solid var(--gainsboro);
        }

        .environment-header {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            margin-bottom: var(--space-md);
        }

        .environment-title {
            font-size: var(--text-sm);
            font-weight: 600;
            color: var(--carbon);
        }

        .environment-picker {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-md);
        }

        .environment-column {
            display: flex;
            flex-direction: column;
            gap: var(--space-xs);
        }

        .environment-label {
            font-size: var(--text-xs);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--slate);
            margin: 0 0 4px 0;
        }

        .environment-options {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .environment-option {
            padding: 8px 10px;
            background: var(--white);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-sm);
            font-size: 11px;
            color: var(--carbon);
            cursor: pointer;
            transition: all var(--transition-fast);
            text-align: left;
            line-height: 1.3;
        }

        .environment-option:hover {
            border-color: var(--slate);
        }

        .environment-option.selected {
            background: var(--jet);
            color: var(--white);
            border-color: var(--jet);
        }

        .environment-option.selected:hover {
            background: var(--carbon);
            border-color: var(--carbon);
        }

        @media (max-width: 600px) {
            .environment-picker {
                grid-template-columns: 1fr;
            }
        }

        /* Mood Picker for Casting Mode */
        .mood-picker-container {
            margin-top: var(--space-md);
            padding: var(--space-md);
            background: var(--off-white);
            border-radius: var(--radius-md);
            border: 1px solid var(--gainsboro);
        }

        .mood-picker-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--space-sm);
        }

        .mood-picker-title {
            font-size: var(--text-sm);
            font-weight: 600;
            color: var(--carbon);
        }

        .mood-picker-subtitle {
            font-size: var(--text-xs);
            color: var(--slate);
            margin-bottom: var(--space-sm);
        }

        .mood-picker-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }

        @media (min-width: 600px) {
            .mood-picker-grid {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        @media (min-width: 900px) {
            .mood-picker-grid {
                grid-template-columns: repeat(6, 1fr);
            }
        }

        .mood-chip {
            padding: 6px 10px;
            background: var(--white);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-sm);
            font-size: 10px;
            color: var(--carbon);
            cursor: pointer;
            transition: all var(--transition-fast);
            text-align: center;
            line-height: 1.3;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .mood-chip:hover {
            border-color: var(--slate);
        }

        .mood-chip.selected {
            background: var(--jet);
            color: var(--white);
            border-color: var(--jet);
        }

        .mood-chip.selected:hover {
            background: var(--carbon);
            border-color: var(--carbon);
        }

        .mood-picker-actions {
            display: flex;
            gap: var(--space-sm);
            margin-top: var(--space-sm);
        }

        .mood-picker-btn {
            padding: 4px 12px;
            font-size: 11px;
            background: var(--white);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .mood-picker-btn:hover {
            border-color: var(--jet);
        }

        /* Location Picker for Campaign Mode */
        .location-picker-container {
            margin-top: var(--space-md);
            padding: var(--space-md);
            background: var(--off-white);
            border-radius: var(--radius-md);
            border: 1px solid var(--gainsboro);
        }

        .location-picker-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--space-sm);
        }

        .location-picker-title {
            font-size: var(--text-sm);
            font-weight: 600;
            color: var(--carbon);
        }

        .location-picker-subtitle {
            font-size: var(--text-xs);
            color: var(--slate);
            margin-bottom: var(--space-sm);
        }

        .location-picker-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-md);
        }

        @media (max-width: 600px) {
            .location-picker-columns {
                grid-template-columns: 1fr;
            }
        }

        .location-column {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .location-column-label {
            font-size: var(--text-xs);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--slate);
            margin-bottom: 4px;
        }

        .location-options {
            display: flex;
            flex-direction: column;
            gap: 4px;
            max-height: 200px;
            overflow-y: auto;
        }

        .location-chip {
            padding: 6px 10px;
            background: var(--white);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-sm);
            font-size: 10px;
            color: var(--carbon);
            cursor: pointer;
            transition: all var(--transition-fast);
            text-align: left;
            line-height: 1.3;
        }

        .location-chip:hover {
            border-color: var(--slate);
        }

        .location-chip.selected {
            background: var(--jet);
            color: var(--white);
            border-color: var(--jet);
        }

        .location-chip.selected:hover {
            background: var(--carbon);
            border-color: var(--carbon);
        }

        .location-picker-actions {
            display: flex;
            gap: var(--space-sm);
            margin-top: var(--space-sm);
        }

        .location-picker-btn {
            padding: 4px 12px;
            font-size: 11px;
            background: var(--white);
            border: 1px solid var(--gainsboro);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .location-picker-btn:hover {
            border-color: var(--jet);
        }

        /* Simplified Output Section */
        .output-simple {
            display: flex;
            flex-direction: column;
            gap: var(--space-md);
        }

        .output-row {
            display: flex;
            align-items: center;
            gap: var(--space-md);
        }

        .output-label {
            font-size: var(--text-sm);
            font-weight: 500;
            color: var(--carbon);
            min-width: 120px;
        }

        .output-slider-container {
            flex: 1;
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }

        .output-slider {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--gainsboro);
            border-radius: 3px;
            outline: none;
        }

        .output-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--jet);
            border-radius: 50%;
            cursor: pointer;
        }

        .output-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: var(--jet);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .output-slider-value {
            font-size: var(--text-md);
            font-weight: 600;
            color: var(--jet);
            min-width: 24px;
            text-align: center;
        }

        .slider-label-left,
        .slider-label-right {
            font-size: var(--text-xs);
            color: var(--slate);
            min-width: 45px;
        }

        .slider-label-left {
            text-align: right;
        }

        .slider-label-right {
            text-align: left;
        }

        .pose-mode-info {
            margin-top: var(--space-md);
            padding: var(--space-sm) var(--space-md);
            background: var(--off-white);
            border-radius: var(--radius-sm);
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }

        .pose-mode-label {
            font-size: var(--text-xs);
            color: var(--slate);
        }

        .pose-mode-value {
            font-size: var(--text-xs);
            font-weight: 500;
            color: var(--carbon);
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="hero">
            <h1>SocialSet v2</h1>
            <p class="hero-subtitle">Generate Instagram content for E-commerce, Campaigns, and Casting</p>
        </div>

        <!-- Mode Tabs -->
        <div class="mode-tabs">
            <button class="mode-tab active" data-mode="ecommerce">E-commerce</button>
            <button class="mode-tab" data-mode="campaign">Campaign</button>
            <button class="mode-tab" data-mode="casting">Casting</button>
        </div>

        <!-- Section 1: Talent Selection -->
        <div class="section">
            <div class="section-header">
                <span class="section-title">1. Select Talent</span>
                <span class="section-badge required">Required</span>
            </div>
            <!-- Talent Source Toggle -->
            <div class="talent-source-toggle">
                <button class="talent-source-btn active" data-source="setset">Setset Models</button>
                <button class="talent-source-btn" data-source="custom">Upload Your Own</button>
            </div>
            <!-- Setset Talent Grid -->
            <div class="talent-grid" id="talent-grid"></div>
            <!-- Custom Talent Upload Grid -->
            <div class="custom-talent-grid" id="custom-talent-grid">
                <div class="custom-talent-slot" data-slot="0"><span class="slot-icon">+</span></div>
                <div class="custom-talent-slot" data-slot="1"><span class="slot-icon">+</span></div>
                <div class="custom-talent-slot" data-slot="2"><span class="slot-icon">+</span></div>
                <div class="custom-talent-slot" data-slot="3"><span class="slot-icon">+</span></div>
                <div class="custom-talent-slot" data-slot="4"><span class="slot-icon">+</span></div>
                <div class="custom-talent-slot" data-slot="5"><span class="slot-icon">+</span></div>
                <div class="custom-talent-slot" data-slot="6"><span class="slot-icon">+</span></div>
                <div class="custom-talent-slot" data-slot="7"><span class="slot-icon">+</span></div>
            </div>
            <input type="file" id="custom-talent-input" accept="image/*" multiple style="display: none;">
            <p class="section-hint" id="talent-hint">Select up to 4 models. Selected: <span id="talent-count">0</span>/4</p>
        </div>

        <!-- Section 2: Mood Board -->
        <div class="section" id="moodboard-section">
            <div class="section-header">
                <span class="section-title">2. Mood Board</span>
                <span class="section-badge required">Required</span>
                <button class="btn btn--sm" id="clear-moodboard" style="margin-left: auto; font-size: 11px; padding: 4px 10px;">Clear All</button>
            </div>
            <!-- Collection Picker -->
            <div class="collection-picker" id="collection-picker">
                <span class="collection-label">Quick Load:</span>
                <div class="collection-chips" id="collection-chips"></div>
            </div>
            <div class="moodboard-grid" id="moodboard-grid"></div>
            <input type="file" id="moodboard-input" accept="image/*" multiple>

            <!-- Style Input -->
            <div class="style-input-container">
                <textarea class="style-input" id="style-input" placeholder="Add style directions (e.g., 'more minimal', 'all red', 'athletic wear', 'sunglasses on every shot')..." rows="2"></textarea>
            </div>

            <!-- Casting Moods (shown in Casting mode) -->
            <div class="mood-picker-container" id="casting-mood-section" style="display: none;">
                <div class="mood-picker-header">
                    <span class="mood-picker-title">Editorial Moods</span>
                    <span class="section-badge">Optional</span>
                </div>
                <p class="mood-picker-subtitle">Select moods to cycle through, or leave empty for random variety</p>
                <div class="mood-picker-grid" id="casting-mood-grid"></div>
                <div class="mood-picker-actions">
                    <button class="mood-picker-btn" id="clear-moods-btn">Clear All</button>
                    <button class="mood-picker-btn" id="random-moods-btn">Random 5</button>
                </div>
            </div>

            <!-- Campaign Locations (shown in Campaign mode) -->
            <div class="location-picker-container" id="campaign-location-section" style="display: none;">
                <div class="location-picker-header">
                    <span class="location-picker-title">Location Presets</span>
                    <span class="section-badge">Optional</span>
                </div>
                <p class="location-picker-subtitle">Select locations to use, or leave empty to derive from mood board</p>
                <div class="location-picker-columns">
                    <div class="location-column">
                        <h4 class="location-column-label">Indoor</h4>
                        <div class="location-options" id="campaign-indoor-locations"></div>
                    </div>
                    <div class="location-column">
                        <h4 class="location-column-label">Outdoor</h4>
                        <div class="location-options" id="campaign-outdoor-locations"></div>
                    </div>
                </div>
                <div class="location-picker-actions">
                    <button class="location-picker-btn" id="clear-locations-btn">Clear All</button>
                    <button class="location-picker-btn" id="random-locations-btn">Random Pair</button>
                </div>
            </div>

            <!-- Campaign Environments (shown after analyze in Campaign mode) -->
            <div class="environment-picker-container" id="environment-section" style="display: none;">
                <div class="environment-header">
                    <span class="environment-title">Campaign Environments</span>
                    <span class="section-badge">Select 1 each</span>
                </div>
                <div class="environment-picker">
                    <div class="environment-column">
                        <h4 class="environment-label">Indoor</h4>
                        <div class="environment-options" id="indoor-options"></div>
                    </div>
                    <div class="environment-column">
                        <h4 class="environment-label">Outdoor</h4>
                        <div class="environment-options" id="outdoor-options"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 3: Output Configuration (Simplified) -->
        <div class="section">
            <div class="section-header">
                <span class="section-title">3. Output</span>
                <span class="section-badge required">Required</span>
            </div>
            <p class="section-hint" style="margin-bottom: var(--space-sm);" id="output-hint">Select how many images to generate. Poses auto-selected based on mode.</p>

            <div class="output-simple">
                <div class="output-row">
                    <label class="output-label">Images</label>
                    <div class="output-slider-container">
                        <input type="range" id="image-count-slider" min="1" max="12" value="6" class="output-slider">
                        <span class="output-slider-value" id="image-count-value">6</span>
                    </div>
                </div>
                <div class="output-row" id="group-mix-row">
                    <label class="output-label">Group shots</label>
                    <div class="output-slider-container">
                        <span class="slider-label-left">Solo</span>
                        <input type="range" id="group-mix-slider" min="0" max="100" value="50" class="output-slider">
                        <span class="slider-label-right">Groups</span>
                    </div>
                </div>
            </div>

            <div class="pose-mode-info" id="pose-mode-info">
                <span class="pose-mode-label">Poses:</span>
                <span class="pose-mode-value" id="pose-mode-value">Editorial studio poses</span>
            </div>
        </div>

        <!-- Inline Loader -->
        <div class="inline-loader" id="inline-loader">
            <div class="loader-message" id="loader-message">Setting up the Studio...</div>
            <div class="loader-progress" id="loader-progress">Preparing...</div>
        </div>

        <!-- Settings & Actions -->
        <div class="actions-row">
            <div class="settings-row">
                <div class="setting-group">
                    <span class="setting-label">Aspect</span>
                    <div class="aspect-buttons" id="aspect-buttons">
                        <button class="aspect-btn" data-ratio="1:1">1:1</button>
                        <button class="aspect-btn active" data-ratio="4:5">4:5</button>
                        <button class="aspect-btn" data-ratio="3:4">3:4</button>
                        <button class="aspect-btn" data-ratio="9:16">9:16</button>
                        <button class="aspect-btn" data-ratio="16:9">16:9</button>
                    </div>
                </div>
                <div class="setting-group">
                    <span class="setting-label">Resolution</span>
                    <div class="aspect-buttons" id="resolution-buttons">
                        <button class="aspect-btn" data-res="1K">1K</button>
                        <button class="aspect-btn active" data-res="2K">2K</button>
                    </div>
                </div>
                <div class="setting-group">
                    <span class="setting-label">Energy</span>
                    <div class="aspect-buttons" id="energy-buttons">
                        <button class="aspect-btn" data-energy="masculine">Masculine</button>
                        <button class="aspect-btn active" data-energy="balanced">Balanced</button>
                        <button class="aspect-btn" data-energy="feminine">Feminine</button>
                    </div>
                </div>
            </div>
            <div class="action-buttons">
                <button class="btn action-btn" id="analyze-btn" disabled>Analyze Mood Board</button>
                <button class="btn btn--primary action-btn" id="generate-btn" disabled>
                    <span id="generate-btn-text">Generate 0 images</span>
                    <span class="btn-cost" id="cost-display">$0.00</span>
                </button>
            </div>
        </div>

        <!-- Progress -->
        <div class="progress-section" id="progress-section">
            <div class="progress-header">
                <span class="progress-title">Generating</span>
                <span class="progress-count" id="progress-count">0 / 0</span>
            </div>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
        </div>

        <!-- Results -->
        <div class="results-section" id="results-section">
            <div class="results-header">
                <h2>Results</h2>
            </div>
            <div class="results-grid" id="results-grid"></div>
        </div>
    </div>

    <!-- Lightbox -->
    <div class="lightbox" id="lightbox">
        <div class="lightbox-content">
            <button class="lightbox-close" id="lightbox-close">&times;</button>
            <div class="lightbox-left">
                <img src="" alt="" class="lightbox-image" id="lightbox-image">
            </div>
            <div class="lightbox-right">
                <div class="lightbox-section">
                    <h3 class="lightbox-section-title">Type</h3>
                    <p class="lightbox-model-text" id="lightbox-type"></p>
                </div>
                <div class="lightbox-section">
                    <h3 class="lightbox-section-title">Pose</h3>
                    <p id="lightbox-pose"></p>
                </div>
                <div class="lightbox-section">
                    <h3 class="lightbox-section-title">Prompt</h3>
                    <p class="lightbox-prompt-text" id="lightbox-prompt"></p>
                </div>
                <button class="lightbox-download" id="lightbox-download">Download Image</button>
            </div>
        </div>
    </div>

    <!-- Shared JS -->
    <script src="/shared/js/utils.js"></script>
    <script src="/shared/js/api.js"></script>
    <script src="/shared/js/models.js"></script>
    <script src="/shared/js/loader.js"></script>
    <script src="/shared/data/editorial-moods.js"></script>
    <script src="/shared/data/editorial-locations.js"></script>
    <script src="poses.js"></script>
    <script src="pose-pools.js"></script>

    <script>
        // Setset Talent Library (with gender for outfit assignment)
        const TALENT = [
            { id: 'james', name: 'James Wilson', gender: 'male', image: '/shared/images/talent/talent-01_JamesWilson.png', thumb: '/shared/images/talent/thumbs/talent-01_JamesWilson.png' },
            { id: 'maya', name: 'Maya Johnson', gender: 'female', image: '/shared/images/talent/talent-02_MayaJohnson.png', thumb: '/shared/images/talent/thumbs/talent-02_MayaJohnson.png' },
            { id: 'river', name: 'River Blake', gender: 'male', image: '/shared/images/talent/talent-03_RiverBlake.png', thumb: '/shared/images/talent/thumbs/talent-03_RiverBlake.png' },
            { id: 'emma', name: 'Emma Sullivan', gender: 'female', image: '/shared/images/talent/talent-04_EmmaSullivan.png', thumb: '/shared/images/talent/thumbs/talent-04_EmmaSullivan.png' },
            { id: 'marcus', name: 'Marcus Brown', gender: 'male', image: '/shared/images/talent/talent-05_MarcusBrown.png', thumb: '/shared/images/talent/thumbs/talent-05_MarcusBrown.png' },
            { id: 'zara', name: 'Zara Mitchell', gender: 'female', image: '/shared/images/talent/talent-06_ZaraMitchell.png', thumb: '/shared/images/talent/thumbs/talent-06_ZaraMitchell.png' },
            { id: 'sophia', name: 'Sophia Anderson', gender: 'female', image: '/shared/images/talent/talent-07_SophiaAnderson.png', thumb: '/shared/images/talent/thumbs/talent-07_SophiaAnderson.png' },
            { id: 'liam', name: 'Liam Garcia', gender: 'male', image: '/shared/images/talent/talent-08_LiamGarcia.png', thumb: '/shared/images/talent/thumbs/talent-08_LiamGarcia.png' },
            { id: 'nina', name: 'Nina Davis', gender: 'female', image: '/shared/images/talent/talent-09_NinaDavis.png', thumb: '/shared/images/talent/thumbs/talent-09_NinaDavis.png' },
            { id: 'mateo', name: 'Mateo Martinez', gender: 'male', image: '/shared/images/talent/talent-10_AvaMartinez.png', thumb: '/shared/images/talent/thumbs/talent-10_AvaMartinez.png' },
            { id: 'luna', name: 'Luna Park', gender: 'female', image: '/shared/images/talent/talent-11_LunaPark.png', thumb: '/shared/images/talent/thumbs/talent-11_LunaPark.png' },
            { id: 'noah', name: 'Noah Chen', gender: 'male', image: '/shared/images/talent/talent-12_NoahChen.png', thumb: '/shared/images/talent/thumbs/talent-12_NoahChen.png' },
            { id: 'kai', name: 'Mia Parker', gender: 'male', image: '/shared/images/talent/talent-13_MiaParker.png', thumb: '/shared/images/talent/thumbs/talent-13_MiaParker.png' },
            { id: 'riley', name: 'Riley Morgan', gender: 'male', image: '/shared/images/talent/talent-14_RileyMorgan.png', thumb: '/shared/images/talent/thumbs/talent-14_RileyMorgan.png' },
            { id: 'jordan', name: 'Jordan Lee', gender: 'male', image: '/shared/images/talent/talent-15_JordanLee.png', thumb: '/shared/images/talent/thumbs/talent-15_JordanLee.png' },
            { id: 'isabella', name: 'Isabella Rodriguez', gender: 'female', image: '/shared/images/talent/talent-16_IsabellaRodriguez.png', thumb: '/shared/images/talent/thumbs/talent-16_IsabellaRodriguez.png' },
            { id: 'quinn', name: 'Quinn Santos', gender: 'male', image: '/shared/images/talent/talent-17_QuinnSantos.png', thumb: '/shared/images/talent/thumbs/talent-17_QuinnSantos.png' },
            { id: 'casey', name: 'Casey White', gender: 'female', image: '/shared/images/talent/talent-18_CaseyWhite.png', thumb: '/shared/images/talent/thumbs/talent-18_CaseyWhite.png' },
            { id: 'sam', name: 'Sam Wilson', gender: 'female', image: '/shared/images/talent/talent-19_SamWilson.png', thumb: '/shared/images/talent/thumbs/talent-19_SamWilson.png' },
            { id: 'drew', name: 'Drew Martinez', gender: 'male', image: '/shared/images/talent/talent-20_DrewMartinez.png', thumb: '/shared/images/talent/thumbs/talent-20_DrewMartinez.png' },
            { id: 'avery', name: 'Avery Taylor', gender: 'female', image: '/shared/images/talent/talent-21_AveryTaylor.png', thumb: '/shared/images/talent/thumbs/talent-21_AveryTaylor.png' },
            { id: 'parker', name: 'Parker Miller', gender: 'male', image: '/shared/images/talent/talent-22_ParkerMiller.png', thumb: '/shared/images/talent/thumbs/talent-22_ParkerMiller.png' },
            { id: 'morgan', name: 'Morgan Kim', gender: 'male', image: '/shared/images/talent/talent-23_MorganKim.png', thumb: '/shared/images/talent/thumbs/talent-23_MorganKim.png' },
            { id: 'andre', name: 'Andre Jackson', gender: 'male', image: '/shared/images/talent/talent-24_AndreJackson.png', thumb: '/shared/images/talent/thumbs/talent-24_AndreJackson.png' },
            { id: 'damon', name: 'Damon Carter', gender: 'male', image: '/shared/images/talent/talent-25_DamonCarter.png', thumb: '/shared/images/talent/thumbs/talent-25_DamonCarter.png' },
            { id: 'nikolai', name: 'Nikolai Volkov', gender: 'male', image: '/shared/images/talent/talent-26_NikolaiVolkov.png', thumb: '/shared/images/talent/thumbs/talent-26_NikolaiVolkov.png' },
            { id: 'sofia', name: 'Sofia Rodriguez', gender: 'female', image: '/shared/images/talent/talent-27_SofiaRodriguez.png', thumb: '/shared/images/talent/thumbs/talent-27_SofiaRodriguez.png' },
            { id: 'finn', name: 'Finn O\'Connor', gender: 'male', image: '/shared/images/talent/talent-28_FinnOConnor.png', thumb: '/shared/images/talent/thumbs/talent-28_FinnOConnor.png' },
            { id: 'clara', name: 'Clara Devereaux', gender: 'female', image: '/shared/images/talent/talent-29_ClaraDevereaux.png', thumb: '/shared/images/talent/thumbs/talent-29_ClaraDevereaux.png' },
            { id: 'simone', name: 'Zoe Washington', gender: 'female', image: '/shared/images/talent/talent-30_ZoeWashington.png', thumb: '/shared/images/talent/thumbs/talent-30_ZoeWashington.png' },
            { id: 'emily', name: 'Emily Hart', gender: 'female', image: '/shared/images/talent/talent-31_EmilyHart.png', thumb: '/shared/images/talent/thumbs/talent-31_EmilyHart.png' },
            { id: 'alex', name: 'Alex Stone', gender: 'male', image: '/shared/images/talent/talent-32_AlexStone.png', thumb: '/shared/images/talent/thumbs/talent-32_AlexStone.png' }
        ];

        // STUDIO_MESSAGES is now loaded from /shared/js/loader.js

        // State
        const state = {
            mode: 'ecommerce',  // 'ecommerce', 'campaign', 'casting'

            // Talent source and selection
            talentSource: 'setset',  // 'setset' or 'custom'
            selectedTalent: [],      // For ecommerce/campaign: array of IDs
            heroTalent: null,        // For casting: single hero ID
            supportingTalent: [],    // For casting: array of supporting IDs
            customTalentImages: new Array(8).fill(null),  // Custom uploaded talent images: {url, modelId}
            modelLabels: ['A', 'B', 'C', 'D'],  // Available model labels
            sceneElements: null,  // For custom talent: {environments, activities, props, poses, interactions, energy, lighting, mood}

            // Mood board
            moodboardImages: new Array(24).fill(null),
            styleInput: '',
            analysis: null,

            // Outfit pools - generated during analyze step
            outfits: {
                female: [],  // Array of outfit descriptions for female talent
                male: [],    // Array of outfit descriptions for male talent
                usedFemale: 0,  // Counter for assigning unique outfits
                usedMale: 0
            },

            // Campaign environments - one indoor + one outdoor location with variations
            campaignEnvironments: {
                indoor: [],   // 5 variations of the selected indoor location
                outdoor: []   // 5 variations of the selected outdoor location
            },
            generatedEnvironments: {
                indoor: [],   // 5 generated indoor options to choose from
                outdoor: []   // 5 generated outdoor options to choose from
            },
            selectedEnvironments: {
                indoor: null,  // Selected indoor environment (index)
                outdoor: null  // Selected outdoor environment (index)
            },
            currentIndoorIndex: 0,   // Counter for cycling through indoor variations
            currentOutdoorIndex: 0,  // Counter for cycling through outdoor variations
            useIndoorNext: true,     // Alternates between indoor and outdoor

            // Casting mode moods - selected from editorial pool
            selectedCastingMoods: [],  // Array of mood IDs to cycle through

            // Campaign mode locations - pre-selected from library
            selectedCampaignLocations: {
                indoor: [],   // Array of indoor location IDs
                outdoor: []   // Array of outdoor location IDs
            },
            currentLocationIndoorIdx: 0,  // Cycling index for indoor
            currentLocationOutdoorIdx: 0, // Cycling index for outdoor

            // Simplified output configuration
            imageCount: 6,      // Number of images to generate (1-12)
            groupMix: 50,       // 0 = all solo shots, 100 = all group shots (2-3 people)

            // Settings
            aspectRatio: '4:5',
            resolution: '2K',
            energy: 'balanced',  // 'masculine', 'balanced', or 'feminine'

            // Results
            results: [],
            lightboxIndex: 0
        };

        // DOM Elements
        const elements = {
            modeTabs: document.querySelectorAll('.mode-tab'),
            talentSourceBtns: document.querySelectorAll('.talent-source-btn'),
            talentGrid: document.getElementById('talent-grid'),
            customTalentGrid: document.getElementById('custom-talent-grid'),
            customTalentInput: document.getElementById('custom-talent-input'),
            talentCount: document.getElementById('talent-count'),
            talentHint: document.getElementById('talent-hint'),
            moodboardSection: document.getElementById('moodboard-section'),
            moodboardGrid: document.getElementById('moodboard-grid'),
            moodboardInput: document.getElementById('moodboard-input'),
            clearMoodboard: document.getElementById('clear-moodboard'),
            styleInput: document.getElementById('style-input'),
            imageCountSlider: document.getElementById('image-count-slider'),
            imageCountValue: document.getElementById('image-count-value'),
            groupMixSlider: document.getElementById('group-mix-slider'),
            groupMixRow: document.getElementById('group-mix-row'),
            poseModeInfo: document.getElementById('pose-mode-info'),
            poseModeValue: document.getElementById('pose-mode-value'),
            outputHint: document.getElementById('output-hint'),
            aspectButtons: document.getElementById('aspect-buttons'),
            energyButtons: document.getElementById('energy-buttons'),
            analyzeBtn: document.getElementById('analyze-btn'),
            generateBtn: document.getElementById('generate-btn'),
            generateBtnText: document.getElementById('generate-btn-text'),
            costDisplay: document.getElementById('cost-display'),
            inlineLoader: document.getElementById('inline-loader'),
            loaderMessage: document.getElementById('loader-message'),
            loaderProgress: document.getElementById('loader-progress'),
            progressSection: document.getElementById('progress-section'),
            progressCount: document.getElementById('progress-count'),
            progressBar: document.getElementById('progress-bar'),
            resultsSection: document.getElementById('results-section'),
            resultsGrid: document.getElementById('results-grid'),
            lightbox: document.getElementById('lightbox'),
            lightboxImage: document.getElementById('lightbox-image'),
            lightboxType: document.getElementById('lightbox-type'),
            lightboxPose: document.getElementById('lightbox-pose'),
            lightboxPrompt: document.getElementById('lightbox-prompt'),
            environmentSection: document.getElementById('environment-section'),
            indoorOptions: document.getElementById('indoor-options'),
            outdoorOptions: document.getElementById('outdoor-options'),
            castingMoodSection: document.getElementById('casting-mood-section'),
            castingMoodGrid: document.getElementById('casting-mood-grid'),
            clearMoodsBtn: document.getElementById('clear-moods-btn'),
            randomMoodsBtn: document.getElementById('random-moods-btn'),
            campaignLocationSection: document.getElementById('campaign-location-section'),
            campaignIndoorLocations: document.getElementById('campaign-indoor-locations'),
            campaignOutdoorLocations: document.getElementById('campaign-outdoor-locations'),
            clearLocationsBtn: document.getElementById('clear-locations-btn'),
            randomLocationsBtn: document.getElementById('random-locations-btn')
        };

        let loadingInterval = null;
        let lastMessageIndex = -1;

        // Initialize
        // Moodboard collections library
        let moodboardLibrary = null;

        async function loadMoodboardLibrary() {
            try {
                const response = await fetch('/shared/data/moodboard-library.json');
                moodboardLibrary = await response.json();
                renderCollectionChips();
            } catch (error) {
                console.error('Failed to load moodboard library:', error);
            }
        }

        function renderCollectionChips() {
            const container = document.getElementById('collection-chips');
            if (!moodboardLibrary || !container) return;

            container.innerHTML = moodboardLibrary.collections.map(collection => `
                <button class="collection-chip" data-collection="${collection.id}" title="${collection.description}">
                    ${collection.name}
                </button>
            `).join('');

            // Add click handlers
            container.querySelectorAll('.collection-chip').forEach(chip => {
                chip.addEventListener('click', () => loadCollection(chip.dataset.collection));
            });
        }

        async function loadCollection(collectionId) {
            const collection = moodboardLibrary?.collections.find(c => c.id === collectionId);
            if (!collection) return;

            // Clear existing moodboard
            state.moodboardImages = new Array(24).fill(null);

            // Update chip states
            document.querySelectorAll('.collection-chip').forEach(chip => {
                chip.classList.toggle('active', chip.dataset.collection === collectionId);
            });

            // Load images from collection (up to 24)
            const imagesToLoad = collection.images.slice(0, 24);

            for (let i = 0; i < imagesToLoad.length; i++) {
                const imagePath = imagesToLoad[i];
                try {
                    // Fetch and convert to base64
                    const response = await fetch(imagePath);
                    const blob = await response.blob();
                    const base64 = await new Promise((resolve) => {
                        const reader = new FileReader();
                        reader.onloadend = () => resolve(reader.result);
                        reader.readAsDataURL(blob);
                    });

                    state.moodboardImages[i] = {
                        url: base64,
                        selected: true,
                        name: imagePath.split('/').pop()
                    };
                } catch (error) {
                    console.error(`Failed to load image: ${imagePath}`, error);
                }
            }

            // Pre-fill style analysis from collection
            if (collection.styleAnalysis) {
                const analysis = collection.styleAnalysis;
                // Combine into a usable analysis string
                state.analysis = `${analysis.aesthetic} ${analysis.clothing} ${analysis.photography} ${analysis.mood}`;
                console.log('Pre-loaded style analysis from collection:', collection.name);
            }

            // Load indoor/outdoor environment pools from collection
            if (collection.environmentPool && collection.environmentPool.indoor && collection.environmentPool.outdoor) {
                state.campaignEnvironments.indoor = [...collection.environmentPool.indoor];
                state.campaignEnvironments.outdoor = [...collection.environmentPool.outdoor];
                state.currentIndoorIndex = 0;
                state.currentOutdoorIndex = 0;
                state.useIndoorNext = Math.random() > 0.5; // Random start
                console.log(`Loaded campaign environments - Indoor: ${state.campaignEnvironments.indoor.length} variations, Outdoor: ${state.campaignEnvironments.outdoor.length} variations`);
            } else {
                state.campaignEnvironments = { indoor: [], outdoor: [] };
            }

            renderMoodboardGrid();
            updateUI();
        }

        function init() {
            loadMoodboardLibrary();
            renderTalentGrid();
            renderMoodboardGrid();
            renderCastingMoodPicker();
            renderCampaignLocationPicker();
            setupOutputSliders();
            setupEventListeners();
            setupMoodPickerHandlers();
            setupLocationPickerHandlers();
            updateUI();
        }

        // Render Talent Grid
        function renderTalentGrid() {
            const isCasting = state.mode === 'casting';

            elements.talentGrid.innerHTML = TALENT.map(talent => {
                let classes = 'talent-card';
                let badge = '';
                let isDisabled = false;

                if (isCasting) {
                    if (state.heroTalent === talent.id) {
                        classes += ' hero';
                    } else if (state.supportingTalent.includes(talent.id)) {
                        classes += ' supporting';
                    } else if (state.supportingTalent.length >= 3 && !state.heroTalent) {
                        isDisabled = true;
                    }
                } else {
                    if (state.selectedTalent.includes(talent.id)) {
                        classes += ' selected';
                        badge = 'âœ“';
                    } else if (state.selectedTalent.length >= 8) {
                        isDisabled = true;
                    }
                }

                if (isDisabled) classes += ' disabled';

                return `
                    <div class="${classes}" data-id="${talent.id}" data-badge="${badge}" title="${talent.name}">
                        <img src="${talent.thumb}" alt="${talent.name}">
                        <span class="talent-name">${talent.name}</span>
                    </div>
                `;
            }).join('');

            // Add click handlers
            elements.talentGrid.querySelectorAll('.talent-card').forEach(card => {
                card.addEventListener('click', () => handleTalentClick(card.dataset.id));
            });

            // Update hint and count
            if (isCasting) {
                const heroText = state.heroTalent ? '1 hero' : '0 hero';
                const supportText = `${state.supportingTalent.length} supporting`;
                elements.talentHint.innerHTML = `Click once for HERO (required), click again for supporting. ${heroText}, ${supportText}`;
                elements.talentCount.textContent = state.heroTalent ? '1' : '0';
            } else {
                elements.talentHint.innerHTML = `Select up to 8 models. Selected: <span id="talent-count">${state.selectedTalent.length}</span>/8`;
                elements.talentCount.textContent = state.selectedTalent.length;
            }
        }

        // Handle talent click
        function handleTalentClick(talentId) {
            const isCasting = state.mode === 'casting';

            if (isCasting) {
                // Casting mode: cycle through none -> hero -> supporting -> none
                if (state.heroTalent === talentId) {
                    // Hero -> Supporting
                    state.heroTalent = null;
                    if (state.supportingTalent.length < 3) {
                        state.supportingTalent.push(talentId);
                    }
                } else if (state.supportingTalent.includes(talentId)) {
                    // Supporting -> None
                    state.supportingTalent = state.supportingTalent.filter(id => id !== talentId);
                } else {
                    // None -> Hero (if no hero) or Supporting (if hero exists)
                    if (!state.heroTalent) {
                        state.heroTalent = talentId;
                    } else if (state.supportingTalent.length < 3) {
                        state.supportingTalent.push(talentId);
                    }
                }
            } else {
                // Normal mode: toggle selection
                if (state.selectedTalent.includes(talentId)) {
                    state.selectedTalent = state.selectedTalent.filter(id => id !== talentId);
                } else if (state.selectedTalent.length < 8) {
                    state.selectedTalent.push(talentId);
                }
            }

            renderTalentGrid();
            updateUI();
        }

        // Render Moodboard Grid
        function renderMoodboardGrid() {
            elements.moodboardGrid.innerHTML = state.moodboardImages.map((img, i) => {
                if (img) {
                    return `
                        <div class="upload-slot filled ${img.selected === false ? 'deselected' : ''}" data-index="${i}">
                            <img src="${img.url}" alt="Moodboard ${i + 1}">
                            <button class="remove-btn" data-action="remove">&times;</button>
                        </div>
                    `;
                }
                return `
                    <div class="upload-slot" data-index="${i}">
                        <span class="plus">+</span>
                    </div>
                `;
            }).join('');

            setupMoodboardListeners();
        }

        // Render Casting Mood Picker
        function renderCastingMoodPicker() {
            // Get all unique moods (combine male and female - many are shared)
            const allMoods = [...EDITORIAL_MOODS_FEMALE, ...EDITORIAL_MOODS_MALE];
            const uniqueMoods = [];
            const seenIds = new Set();

            for (const mood of allMoods) {
                if (!seenIds.has(mood.id)) {
                    seenIds.add(mood.id);
                    uniqueMoods.push(mood);
                }
            }

            // Sort alphabetically
            uniqueMoods.sort((a, b) => a.name.localeCompare(b.name));

            elements.castingMoodGrid.innerHTML = uniqueMoods.map(mood => {
                const isSelected = state.selectedCastingMoods.includes(mood.id);
                return `
                    <div class="mood-chip ${isSelected ? 'selected' : ''}" data-mood-id="${mood.id}" title="${mood.name}">
                        ${mood.name}
                    </div>
                `;
            }).join('');

            // Add click handlers
            elements.castingMoodGrid.querySelectorAll('.mood-chip').forEach(chip => {
                chip.addEventListener('click', () => {
                    const moodId = chip.dataset.moodId;
                    const idx = state.selectedCastingMoods.indexOf(moodId);
                    if (idx >= 0) {
                        state.selectedCastingMoods.splice(idx, 1);
                    } else {
                        state.selectedCastingMoods.push(moodId);
                    }
                    renderCastingMoodPicker();
                });
            });
        }

        // Setup mood picker button handlers
        function setupMoodPickerHandlers() {
            elements.clearMoodsBtn.addEventListener('click', () => {
                state.selectedCastingMoods = [];
                renderCastingMoodPicker();
            });

            elements.randomMoodsBtn.addEventListener('click', () => {
                // Get all unique mood IDs
                const allMoods = [...EDITORIAL_MOODS_FEMALE, ...EDITORIAL_MOODS_MALE];
                const uniqueIds = [...new Set(allMoods.map(m => m.id))];

                // Shuffle and pick 5
                const shuffled = uniqueIds.sort(() => Math.random() - 0.5);
                state.selectedCastingMoods = shuffled.slice(0, 5);
                renderCastingMoodPicker();
            });
        }

        // Render Campaign Location Picker
        function renderCampaignLocationPicker() {
            // Render indoor locations
            elements.campaignIndoorLocations.innerHTML = INDOOR_LOCATIONS.map(loc => {
                const isSelected = state.selectedCampaignLocations.indoor.includes(loc.id);
                return `
                    <div class="location-chip ${isSelected ? 'selected' : ''}" data-location-id="${loc.id}" data-type="indoor" title="${loc.prompt}">
                        ${loc.name}
                    </div>
                `;
            }).join('');

            // Render outdoor locations
            elements.campaignOutdoorLocations.innerHTML = OUTDOOR_LOCATIONS.map(loc => {
                const isSelected = state.selectedCampaignLocations.outdoor.includes(loc.id);
                return `
                    <div class="location-chip ${isSelected ? 'selected' : ''}" data-location-id="${loc.id}" data-type="outdoor" title="${loc.prompt}">
                        ${loc.name}
                    </div>
                `;
            }).join('');

            // Add click handlers
            document.querySelectorAll('#campaign-indoor-locations .location-chip, #campaign-outdoor-locations .location-chip').forEach(chip => {
                chip.addEventListener('click', () => {
                    const locId = chip.dataset.locationId;
                    const type = chip.dataset.type;
                    const arr = state.selectedCampaignLocations[type];
                    const idx = arr.indexOf(locId);
                    if (idx >= 0) {
                        arr.splice(idx, 1);
                    } else {
                        arr.push(locId);
                    }
                    renderCampaignLocationPicker();
                    updateUI();
                });
            });
        }

        // Setup location picker button handlers
        function setupLocationPickerHandlers() {
            elements.clearLocationsBtn.addEventListener('click', () => {
                state.selectedCampaignLocations = { indoor: [], outdoor: [] };
                renderCampaignLocationPicker();
                updateUI();
            });

            elements.randomLocationsBtn.addEventListener('click', () => {
                // Pick 1 random indoor and 1 random outdoor
                const randomIndoor = INDOOR_LOCATIONS[Math.floor(Math.random() * INDOOR_LOCATIONS.length)];
                const randomOutdoor = OUTDOOR_LOCATIONS[Math.floor(Math.random() * OUTDOOR_LOCATIONS.length)];
                state.selectedCampaignLocations = {
                    indoor: [randomIndoor.id],
                    outdoor: [randomOutdoor.id]
                };
                renderCampaignLocationPicker();
                updateUI();
            });
        }

        // Setup moodboard listeners
        function setupMoodboardListeners() {
            elements.moodboardGrid.querySelectorAll('.upload-slot').forEach(slot => {
                const index = parseInt(slot.dataset.index);

                slot.addEventListener('click', (e) => {
                    if (e.target.dataset.action === 'remove') {
                        // Remove and collapse
                        state.moodboardImages[index] = null;
                        const filled = state.moodboardImages.filter(img => img);
                        for (let i = 0; i < 24; i++) {
                            state.moodboardImages[i] = filled[i] || null;
                        }
                        state.analysis = null;
                        elements.analyzeBtn.textContent = 'Analyze Mood Board';
                        elements.analyzeBtn.classList.remove('analyzed');
                        renderMoodboardGrid();
                        updateUI();
                        return;
                    }

                    if (state.moodboardImages[index]) {
                        // Toggle selection
                        state.moodboardImages[index].selected = state.moodboardImages[index].selected === false ? true : false;
                        renderMoodboardGrid();
                        updateUI();
                    } else {
                        // Open file picker
                        elements.moodboardInput.dataset.startIndex = index;
                        elements.moodboardInput.click();
                    }
                });
            });

            // Drag and drop
            elements.moodboardGrid.addEventListener('dragover', (e) => e.preventDefault());
            elements.moodboardGrid.addEventListener('dragenter', () => elements.moodboardGrid.classList.add('drag-over'));
            elements.moodboardGrid.addEventListener('dragleave', (e) => {
                if (!elements.moodboardGrid.contains(e.relatedTarget)) {
                    elements.moodboardGrid.classList.remove('drag-over');
                }
            });
            elements.moodboardGrid.addEventListener('drop', (e) => {
                e.preventDefault();
                elements.moodboardGrid.classList.remove('drag-over');
                const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
                handleFileUpload(files, null);
            });
        }

        // Handle file upload
        function handleFileUpload(files, startIndex) {
            const targetIndices = [];

            if (startIndex !== null) {
                for (let i = 0; i < files.length; i++) {
                    const idx = startIndex + i;
                    if (idx < 24) targetIndices.push(idx);
                }
            } else {
                for (let i = 0; i < files.length; i++) {
                    const emptyIdx = state.moodboardImages.findIndex((img, idx) => !img && !targetIndices.includes(idx));
                    if (emptyIdx !== -1 && emptyIdx < 24) {
                        targetIndices.push(emptyIdx);
                    }
                }
            }

            files.forEach((file, i) => {
                if (i >= targetIndices.length) return;
                const targetIndex = targetIndices[i];

                const reader = new FileReader();
                reader.onload = (e) => {
                    state.moodboardImages[targetIndex] = { file, url: e.target.result, selected: true };
                    state.analysis = null;
                    elements.analyzeBtn.textContent = 'Analyze Mood Board';
                    elements.analyzeBtn.classList.remove('analyzed');
                    renderMoodboardGrid();
                    updateUI();
                };
                reader.readAsDataURL(file);
            });
        }

        // Handle custom talent upload
        function handleCustomTalentUpload(files, startIndex) {
            files.forEach((file, i) => {
                const targetIndex = startIndex + i;
                if (targetIndex >= 8) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    // Auto-assign model label based on existing uploads
                    const usedModels = state.customTalentImages
                        .filter(img => img !== null)
                        .map(img => img.modelId);
                    // Find first unused model label, or default to 'A'
                    const modelId = state.modelLabels.find(m => !usedModels.includes(m)) || 'A';

                    state.customTalentImages[targetIndex] = {
                        file,
                        url: e.target.result,
                        modelId: modelId
                    };
                    renderCustomTalentGrid();
                    updateCustomTalentHint();
                    updateUI();
                };
                reader.readAsDataURL(file);
            });
        }

        // Cycle model label on click
        window.cycleModelLabel = function(index, event) {
            event.stopPropagation();
            const image = state.customTalentImages[index];
            if (!image) return;

            const currentIdx = state.modelLabels.indexOf(image.modelId);
            const nextIdx = (currentIdx + 1) % state.modelLabels.length;
            image.modelId = state.modelLabels[nextIdx];
            renderCustomTalentGrid();
            updateCustomTalentHint();
        };

        // Render custom talent grid
        function renderCustomTalentGrid() {
            const slots = elements.customTalentGrid.querySelectorAll('.custom-talent-slot');
            slots.forEach((slot, idx) => {
                const image = state.customTalentImages[idx];
                if (image) {
                    slot.classList.add('filled');
                    slot.setAttribute('draggable', 'true');
                    slot.innerHTML = `
                        <img src="${image.url}" alt="Custom talent ${idx + 1}">
                        <button class="model-label" data-model="${image.modelId}" onclick="cycleModelLabel(${idx}, event)" title="Click to change model">${image.modelId}</button>
                        <button class="remove-btn" onclick="removeCustomTalent(${idx}, event)">Ã—</button>
                    `;
                } else {
                    slot.classList.remove('filled');
                    slot.removeAttribute('draggable');
                    slot.innerHTML = '<span class="slot-icon">+</span>';
                }
            });
            // Re-setup drag handlers after render
            setupCustomTalentDragReorder();
        }

        // Remove custom talent image
        window.removeCustomTalent = function(index, event) {
            if (event) event.stopPropagation();
            state.customTalentImages[index] = null;
            renderCustomTalentGrid();
            updateCustomTalentHint();
            updateUI();
        };

        // Update hint for custom talent
        function updateCustomTalentHint() {
            const images = state.customTalentImages.filter(img => img !== null);
            const count = images.length;

            // Count unique models
            const uniqueModels = [...new Set(images.map(img => img.modelId))];
            const modelSummary = uniqueModels.length > 0
                ? ` (${uniqueModels.length} model${uniqueModels.length > 1 ? 's' : ''}: ${uniqueModels.join(', ')})`
                : '';

            elements.talentHint.innerHTML = `Upload images, click label to assign model. ${count} uploaded${modelSummary}`;
            elements.talentCount.textContent = count;
        }

        // Setup drag reordering for custom talent grid (using event delegation)
        let draggedSlotIndex = null;
        let dragReorderInitialized = false;

        function setupCustomTalentDragReorder() {
            // Only setup once - use event delegation
            if (dragReorderInitialized) return;
            dragReorderInitialized = true;

            const grid = elements.customTalentGrid;

            grid.addEventListener('dragstart', (e) => {
                const slot = e.target.closest('.custom-talent-slot');
                if (!slot) return;

                const idx = parseInt(slot.dataset.slot);
                if (!state.customTalentImages[idx]) {
                    e.preventDefault();
                    return;
                }

                draggedSlotIndex = idx;
                slot.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', idx.toString());
            });

            grid.addEventListener('dragend', (e) => {
                const slot = e.target.closest('.custom-talent-slot');
                if (slot) slot.classList.remove('dragging');
                draggedSlotIndex = null;
                grid.querySelectorAll('.custom-talent-slot').forEach(s => s.classList.remove('drag-over'));
            });

            grid.addEventListener('dragover', (e) => {
                const slot = e.target.closest('.custom-talent-slot');
                if (!slot) return;

                e.preventDefault();
                const idx = parseInt(slot.dataset.slot);
                if (draggedSlotIndex !== null && draggedSlotIndex !== idx) {
                    slot.classList.add('drag-over');
                }
            });

            grid.addEventListener('dragleave', (e) => {
                const slot = e.target.closest('.custom-talent-slot');
                if (slot && !slot.contains(e.relatedTarget)) {
                    slot.classList.remove('drag-over');
                }
            });

            grid.addEventListener('drop', (e) => {
                const slot = e.target.closest('.custom-talent-slot');
                if (!slot) return;

                e.preventDefault();
                e.stopPropagation();
                slot.classList.remove('drag-over');

                const idx = parseInt(slot.dataset.slot);

                // Handle reordering within grid (not file drops)
                if (draggedSlotIndex !== null && draggedSlotIndex !== idx && !e.dataTransfer.files.length) {
                    // Swap images
                    const temp = state.customTalentImages[draggedSlotIndex];
                    state.customTalentImages[draggedSlotIndex] = state.customTalentImages[idx];
                    state.customTalentImages[idx] = temp;
                    renderCustomTalentGrid();
                    updateCustomTalentHint();
                }

                draggedSlotIndex = null;
            });
        }

        // Render Environment Options for Campaign mode
        function renderEnvironmentOptions() {
            const { indoor, outdoor } = state.generatedEnvironments;

            // Render indoor options
            elements.indoorOptions.innerHTML = indoor.map((env, idx) => `
                <button class="environment-option ${state.selectedEnvironments.indoor === idx ? 'selected' : ''}"
                        data-type="indoor" data-index="${idx}">
                    ${env.name || env}
                </button>
            `).join('');

            // Render outdoor options
            elements.outdoorOptions.innerHTML = outdoor.map((env, idx) => `
                <button class="environment-option ${state.selectedEnvironments.outdoor === idx ? 'selected' : ''}"
                        data-type="outdoor" data-index="${idx}">
                    ${env.name || env}
                </button>
            `).join('');

            // Add click handlers
            elements.indoorOptions.querySelectorAll('.environment-option').forEach(btn => {
                btn.addEventListener('click', () => selectEnvironment('indoor', parseInt(btn.dataset.index)));
            });

            elements.outdoorOptions.querySelectorAll('.environment-option').forEach(btn => {
                btn.addEventListener('click', () => selectEnvironment('outdoor', parseInt(btn.dataset.index)));
            });

            // Show section if we have environments and in campaign mode
            const hasEnvironments = indoor.length > 0 || outdoor.length > 0;
            elements.environmentSection.style.display = (hasEnvironments && state.mode === 'campaign') ? 'block' : 'none';
        }

        function selectEnvironment(type, index) {
            // Toggle selection (click again to deselect)
            if (state.selectedEnvironments[type] === index) {
                state.selectedEnvironments[type] = null;
            } else {
                state.selectedEnvironments[type] = index;
            }

            // Update campaign environments based on selection
            updateCampaignEnvironments();
            renderEnvironmentOptions();
        }

        function updateCampaignEnvironments() {
            // When user selects an environment, generate 5 variations of it
            const { indoor, outdoor } = state.generatedEnvironments;
            const { indoor: selectedIndoor, outdoor: selectedOutdoor } = state.selectedEnvironments;

            if (selectedIndoor !== null && indoor[selectedIndoor]) {
                const base = indoor[selectedIndoor].name || indoor[selectedIndoor];
                state.campaignEnvironments.indoor = [
                    `${base}, wide establishing shot`,
                    `${base}, different angle with interesting shadows`,
                    `${base}, intimate corner framing`,
                    `${base}, architectural details visible`,
                    `${base}, soft natural light variation`
                ];
            } else {
                state.campaignEnvironments.indoor = [];
            }

            if (selectedOutdoor !== null && outdoor[selectedOutdoor]) {
                const base = outdoor[selectedOutdoor].name || outdoor[selectedOutdoor];
                state.campaignEnvironments.outdoor = [
                    `${base}, wide establishing shot`,
                    `${base}, different angle with golden hour light`,
                    `${base}, intimate framing near focal point`,
                    `${base}, environmental context visible`,
                    `${base}, dramatic sky or weather variation`
                ];
            } else {
                state.campaignEnvironments.outdoor = [];
            }

            state.currentIndoorIndex = 0;
            state.currentOutdoorIndex = 0;
            state.useIndoorNext = Math.random() > 0.5;

            console.log('[Environments] Updated - Indoor:', state.campaignEnvironments.indoor.length, 'Outdoor:', state.campaignEnvironments.outdoor.length);
        }

        // Setup output sliders (simplified - no more per-slot config)
        function setupOutputSliders() {
            // Image count slider
            elements.imageCountSlider.addEventListener('input', (e) => {
                state.imageCount = parseInt(e.target.value);
                elements.imageCountValue.textContent = state.imageCount;
                updateUI();
            });

            // Group mix slider (solo vs groups)
            elements.groupMixSlider.addEventListener('input', (e) => {
                state.groupMix = parseInt(e.target.value);
                updateUI();
            });
        }

        // Update pose mode info display based on current mode
        function updatePoseModeInfo() {
            const modeText = {
                'ecommerce': 'Editorial studio poses â€¢ White background',
                'campaign': 'Lifestyle poses â€¢ Location environments',
                'casting': 'Editorial portrait variety â€¢ Moods from pool'
            };
            elements.poseModeValue.textContent = modeText[state.mode] || modeText['ecommerce'];
        }

        // Setup event listeners
        function setupEventListeners() {
            // Mode tabs
            elements.modeTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const newMode = tab.dataset.mode;
                    if (newMode === state.mode) return;

                    // Switch mode
                    state.mode = newMode;

                    // Reset talent selection when switching modes
                    state.selectedTalent = [];
                    state.heroTalent = null;
                    state.supportingTalent = [];

                    // Update tab styling
                    elements.modeTabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');

                    renderTalentGrid();
                    updateUI();
                });
            });

            // Talent source toggle
            elements.talentSourceBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    const newSource = btn.dataset.source;
                    if (newSource === state.talentSource) return;

                    state.talentSource = newSource;

                    // Update button styling
                    elements.talentSourceBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');

                    // Toggle grid visibility
                    if (newSource === 'custom') {
                        elements.talentGrid.style.display = 'none';
                        elements.customTalentGrid.classList.add('visible');
                        updateCustomTalentHint();
                    } else {
                        elements.talentGrid.style.display = '';
                        elements.customTalentGrid.classList.remove('visible');
                        renderTalentGrid();
                    }
                    updateUI();
                });
            });

            // Custom talent upload slots
            elements.customTalentGrid.querySelectorAll('.custom-talent-slot').forEach(slot => {
                slot.addEventListener('click', (e) => {
                    // Don't trigger file upload if clicking on remove or model label buttons
                    if (e.target.classList.contains('remove-btn') || e.target.classList.contains('model-label')) return;
                    const slotIndex = parseInt(slot.dataset.slot);
                    elements.customTalentInput.dataset.slotIndex = slotIndex;
                    elements.customTalentInput.click();
                });
            });

            // Custom talent file input
            elements.customTalentInput.addEventListener('change', (e) => {
                const slotIndex = parseInt(e.target.dataset.slotIndex || '0');
                handleCustomTalentUpload(Array.from(e.target.files), slotIndex);
                e.target.value = '';
            });

            // Custom talent drag and drop - grid level (for dropping files from desktop)
            elements.customTalentGrid.addEventListener('dragover', (e) => {
                e.preventDefault();
                elements.customTalentGrid.classList.add('drag-over');
            });

            elements.customTalentGrid.addEventListener('dragleave', (e) => {
                if (!elements.customTalentGrid.contains(e.relatedTarget)) {
                    elements.customTalentGrid.classList.remove('drag-over');
                }
            });

            elements.customTalentGrid.addEventListener('drop', (e) => {
                e.preventDefault();
                elements.customTalentGrid.classList.remove('drag-over');

                // Handle file drops from desktop
                if (e.dataTransfer.files.length > 0) {
                    const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
                    if (files.length > 0) {
                        // Find first empty slot
                        const startIndex = state.customTalentImages.findIndex(img => img === null);
                        if (startIndex !== -1) {
                            handleCustomTalentUpload(files, startIndex);
                        }
                    }
                }
            });

            // Setup drag and drop for reordering within the grid
            setupCustomTalentDragReorder();

            // File input
            elements.moodboardInput.addEventListener('change', (e) => {
                const startIndex = e.target.dataset.startIndex ? parseInt(e.target.dataset.startIndex) : null;
                handleFileUpload(Array.from(e.target.files), startIndex);
                e.target.value = '';
            });

            // Clear moodboard
            elements.clearMoodboard.addEventListener('click', () => {
                state.moodboardImages = new Array(24).fill(null);
                state.analysis = null;
                elements.analyzeBtn.textContent = 'Analyze Mood Board';
                elements.analyzeBtn.classList.remove('analyzed');
                renderMoodboardGrid();
                updateUI();
            });

            // Style input
            elements.styleInput.addEventListener('input', (e) => {
                state.styleInput = e.target.value;
                // Reset analysis when style input changes
                if (state.analysis) {
                    state.analysis = null;
                    elements.analyzeBtn.classList.remove('analyzed');
                }
                updateUI();
            });

            // Aspect ratio buttons
            elements.aspectButtons.querySelectorAll('.aspect-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    elements.aspectButtons.querySelectorAll('.aspect-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.aspectRatio = btn.dataset.ratio;
                });
            });

            // Resolution buttons
            const resolutionButtons = document.getElementById('resolution-buttons');
            resolutionButtons.querySelectorAll('.aspect-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    resolutionButtons.querySelectorAll('.aspect-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.resolution = btn.dataset.res;
                });
            });

            // Energy buttons
            elements.energyButtons.querySelectorAll('.aspect-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    elements.energyButtons.querySelectorAll('.aspect-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.energy = btn.dataset.energy;
                });
            });

            // Analyze button
            elements.analyzeBtn.addEventListener('click', handleAnalyze);

            // Generate button
            elements.generateBtn.addEventListener('click', handleGenerate);

            // Randomize removed - simplified output system now auto-varies poses

            // Lightbox
            document.getElementById('lightbox-close').addEventListener('click', closeLightbox);
            elements.lightbox.addEventListener('click', (e) => {
                if (e.target === elements.lightbox) closeLightbox();
            });

            document.getElementById('lightbox-download').addEventListener('click', () => {
                const result = state.results[state.lightboxIndex];
                const now = new Date();
                const yy = String(now.getFullYear()).slice(-2);
                const mm = String(now.getMonth() + 1).padStart(2, '0');
                const dd = String(now.getDate()).padStart(2, '0');
                const hh = String(now.getHours()).padStart(2, '0');
                const min = String(now.getMinutes()).padStart(2, '0');
                const num = String(state.lightboxIndex + 1).padStart(2, '0');
                downloadFile(result.url, `Setset_Social_${yy}${mm}${dd}_${hh}${min}_${num}.png`);
            });

            // Keyboard
            document.addEventListener('keydown', (e) => {
                if (!elements.lightbox.classList.contains('visible')) return;
                if (e.key === 'Escape') closeLightbox();
                if (e.key === 'ArrowLeft' && state.lightboxIndex > 0) {
                    state.lightboxIndex--;
                    updateLightboxContent();
                }
                if (e.key === 'ArrowRight' && state.lightboxIndex < state.results.length - 1) {
                    state.lightboxIndex++;
                    updateLightboxContent();
                }
            });
        }

        // Update UI state
        function updateUI() {
            const isCasting = state.mode === 'casting';
            // Check for talent based on source mode
            const hasSetsetTalent = isCasting ? !!state.heroTalent : state.selectedTalent.length > 0;
            const hasCustomTalent = state.customTalentImages.some(img => img !== null);
            const hasTalent = state.talentSource === 'custom' ? hasCustomTalent : hasSetsetTalent;

            const hasMoodboard = state.moodboardImages.some(img => img && img.selected !== false);
            const hasStyleText = state.styleInput.trim().length > 0;
            const hasOutputs = state.imageCount > 0;

            // Enable/disable analyze button - can analyze with images OR text-only
            elements.analyzeBtn.disabled = !hasMoodboard && !hasStyleText;

            // Update analyze button text based on what we're analyzing
            // Custom talent mode: only analyzes for environment, not outfits
            const isCustomTalent = state.talentSource === 'custom';
            if (state.analysis) {
                elements.analyzeBtn.textContent = isCustomTalent ? 'Re-analyze Environment' : 'Re-analyze Style';
            } else if (isCustomTalent) {
                elements.analyzeBtn.textContent = 'Analyze Environment';
            } else if (hasMoodboard && hasStyleText) {
                elements.analyzeBtn.textContent = 'Analyze Style';
            } else if (hasMoodboard) {
                elements.analyzeBtn.textContent = 'Analyze Mood Board';
            } else if (hasStyleText) {
                elements.analyzeBtn.textContent = 'Analyze Style Text';
            } else {
                elements.analyzeBtn.textContent = 'Analyze Style';
            }

            // Enable/disable generate button
            // Casting mode: only needs talent (no moodboard/analysis required)
            // E-commerce: needs talent and analysis
            // Campaign: needs talent, analysis, and optionally locations
            // Custom talent: needs uploaded images and moodboard analysis (for environment)
            const hasStyleSource = hasMoodboard || hasStyleText;
            let canGenerate;
            if (isCasting) {
                canGenerate = hasTalent;
            } else if (state.talentSource === 'custom') {
                // Custom talent needs uploaded images + moodboard for environment context
                canGenerate = hasCustomTalent && hasStyleSource && state.analysis;
            } else {
                canGenerate = hasTalent && hasStyleSource && state.analysis;
            }
            elements.generateBtn.disabled = !canGenerate;

            // Hide analyze button and moodboard section in casting mode
            elements.analyzeBtn.style.display = isCasting ? 'none' : 'inline-flex';
            if (elements.moodboardSection) {
                elements.moodboardSection.style.display = isCasting ? 'none' : 'block';
            }

            // Show casting mood picker only in casting mode
            if (elements.castingMoodSection) {
                elements.castingMoodSection.style.display = isCasting ? 'block' : 'none';
            }

            // Show campaign location picker only in campaign mode
            if (elements.campaignLocationSection) {
                elements.campaignLocationSection.style.display = state.mode === 'campaign' ? 'block' : 'none';
            }

            // Update generate button text and cost
            const totalImages = state.imageCount;
            let btnText = `Generate ${totalImages} image${totalImages !== 1 ? 's' : ''}`;
            elements.generateBtnText.textContent = btnText;

            // Calculate and display cost (using nano-pro at $0.15 per image)
            const costPerImage = 0.15;
            const totalCost = totalImages * costPerImage;
            elements.costDisplay.textContent = formatCost(totalCost);

            // Update output hint based on mode
            if (state.mode === 'ecommerce') {
                elements.outputHint.textContent = 'White studio background with varied editorial poses.';
            } else if (state.mode === 'campaign') {
                const locCount = state.selectedCampaignLocations.indoor.length + state.selectedCampaignLocations.outdoor.length;
                const locText = locCount > 0
                    ? `${locCount} location${locCount > 1 ? 's' : ''} selected.`
                    : 'Locations from mood board.';
                elements.outputHint.textContent = `Lifestyle poses in environments. ${locText}`;
            } else {
                const moodText = state.selectedCastingMoods.length > 0
                    ? `${state.selectedCastingMoods.length} mood${state.selectedCastingMoods.length > 1 ? 's' : ''} selected.`
                    : 'Random moods from pool.';
                elements.outputHint.textContent = `Editorial portrait variety. ${moodText}`;
            }

            // Update pose mode info
            updatePoseModeInfo();
        }

        // Loading animation
        function startLoadingAnimation(progressText = 'Preparing...') {
            elements.inlineLoader.classList.add('visible');
            elements.loaderProgress.textContent = progressText;

            const initialIdx = Math.floor(Math.random() * STUDIO_MESSAGES.length);
            elements.loaderMessage.textContent = STUDIO_MESSAGES[initialIdx];
            lastMessageIndex = initialIdx;

            loadingInterval = setInterval(() => {
                let idx;
                do {
                    idx = Math.floor(Math.random() * STUDIO_MESSAGES.length);
                } while (idx === lastMessageIndex && STUDIO_MESSAGES.length > 1);
                lastMessageIndex = idx;

                elements.loaderMessage.classList.add('fade-out');
                elements.loaderMessage.classList.remove('fade-in');

                setTimeout(() => {
                    elements.loaderMessage.textContent = STUDIO_MESSAGES[idx];
                    elements.loaderMessage.classList.remove('fade-out');
                    elements.loaderMessage.classList.add('fade-in');
                }, 250);
            }, 2000);
        }

        function updateLoadingProgress(text) {
            elements.loaderProgress.textContent = text;
        }

        function stopLoadingAnimation() {
            if (loadingInterval) {
                clearInterval(loadingInterval);
                loadingInterval = null;
            }
            elements.inlineLoader.classList.remove('visible');
        }

        // Handle Analyze
        async function handleAnalyze() {
            const moodImages = state.moodboardImages.filter(img => img && img.selected !== false);
            const styleText = state.styleInput.trim();
            const hasImages = moodImages.length > 0;
            const hasText = styleText.length > 0;

            if (!hasImages && !hasText) return;

            if (hasImages) {
                startLoadingAnimation(`Analyzing ${moodImages.length} moodboard image${moodImages.length > 1 ? 's' : ''}...`);
            } else {
                startLoadingAnimation('Analyzing style description...');
            }

            try {
                let analysisResult = '';

                if (hasImages) {
                    // Upload moodboard images with resilience - continue even if some fail
                    const uploadPromises = moodImages.map(img =>
                        api.uploadBase64(img.url).catch(err => {
                            console.warn('Upload failed for image, skipping:', err.message);
                            return null;
                        })
                    );
                    const uploadResults = await Promise.all(uploadPromises);
                    const moodboardUrls = uploadResults.filter(r => r !== null).map(r => r.url);

                    if (moodboardUrls.length === 0) {
                        throw new Error('All image uploads failed. Please try again.');
                    }

                    if (moodboardUrls.length < moodImages.length) {
                        console.log(`[Analyze] ${moodImages.length - moodboardUrls.length} uploads failed, continuing with ${moodboardUrls.length} images`);
                    }

                    // Different analysis prompts for custom talent vs standard mode
                    let analysisPrompt;

                    if (state.talentSource === 'custom') {
                        // Custom talent mode: focus on environments, activities, props, energy - NOT clothing
                        analysisPrompt = `Analyze these images to extract SCENE ELEMENTS for a fashion campaign. The models already have their outfits - we need variety in settings, actions, and energy.

Return a JSON object with these arrays (5-8 items each):

{
  "environments": ["specific location 1", "specific location 2", ...],
  "activities": ["activity or action 1", "activity 2", ...],
  "props": ["prop or accessory 1", "prop 2", ...],
  "poses": ["pose or body language 1", "pose 2", ...],
  "interactions": ["interaction type 1", "interaction 2", ...],
  "energy": ["energy/vibe 1", "energy 2", ...],
  "lighting": ["lighting style 1", "lighting style 2", ...],
  "mood": ["mood/atmosphere 1", "mood 2", ...]
}

EXAMPLES:
- environments: "urban cycling path", "mountain road at golden hour", "indoor cycling studio", "coastal trail with ocean view", "city street with motion blur", "park with morning mist"
- activities: "riding a road bike", "adjusting helmet straps", "drinking from water bottle", "stretching against bike", "checking phone for route", "locking up bicycle"
- props: "road bicycle", "cycling helmet", "water bottle", "cycling sunglasses", "bike lock", "cycling gloves", "bike pump", "energy gel"
- poses: "mid-stride dynamic movement", "leaning casually on handlebars", "looking over shoulder", "crouched adjusting gear", "standing tall triumphant", "relaxed seated position"
- interactions: "two riders chatting", "helping adjust gear", "high-fiving after ride", "pointing at view", "sharing water", "riding side by side"
- energy: "high intensity sprint", "relaxed casual cruise", "focused determination", "playful fun", "serene peaceful", "competitive racing"
- lighting: "harsh midday sun", "soft golden hour", "overcast diffused", "dramatic backlit silhouette", "dappled forest light", "urban neon mixed"
- mood: "energetic adventure", "peaceful morning", "intense training", "weekend leisure", "urban commuter hustle", "nature escape"

Extract SPECIFIC elements from these images. Be detailed and varied. Return ONLY valid JSON, no other text.`;
                    } else {
                        // Standard mode: focus on style and outfits
                        analysisPrompt = `Analyze these images and create a comprehensive style guide for image generation. Write as a single flowing paragraph that can be used directly in prompts. Include:

1. CLOTHING AESTHETIC: Describe the overall fashion aesthetic and vibe (minimalist, luxury, streetwear, bohemian, tailored, relaxed, etc.). Focus on the STYLE and MOOD of the clothing rather than specific items. Mention textures, fits, silhouettes, and color palettes that define the look. Do NOT list specific garments - describe the fashion direction instead.

2. PHOTOGRAPHY STYLE: Is it analog/film-like or digital? Note any grain, color grading, filters, or processing effects. Describe color palette and tones (warm, cool, muted, saturated).

3. LIGHTING: Describe the lighting approach (natural, studio, dramatic, soft, harsh, backlit, etc.).

4. POSES & COMPOSITION: Note typical body language, poses, framing, and compositional elements.

5. MOOD & ENVIRONMENT: Describe the atmosphere, settings, and overall mood.

IMPORTANT:
- Do NOT mention specific clothing items like "paisley jacket" or "blue dress" - instead describe the style aesthetic
- Do NOT mention any brand names, designer labels, or logos
- Focus on the VIBE and AESTHETIC rather than specific pieces
- Write one cohesive paragraph that flows naturally and can generate VARIED outfits in the same style`;
                    }

                    const result = await api.analyzeImages(moodboardUrls, analysisPrompt);
                    if (result.content) {
                        analysisResult = result.content;
                    }
                } else if (hasText) {
                    // Text-only analysis - generate style guide from brand/aesthetic description
                    const textPrompt = `Based on this style description: "${styleText}"

Create a comprehensive fashion style guide for image generation. Write as a single flowing paragraph. Describe:

1. CLOTHING AESTHETIC: The overall fashion vibe, silhouettes, fits, textures, and color palettes that define this look. Be specific about the style direction.

2. PHOTOGRAPHY STYLE: What kind of photography would suit this aesthetic (clean digital, film-like, editorial, etc.).

3. MOOD: The overall atmosphere and feeling.

IMPORTANT:
- Do NOT mention any brand names, designer labels, or logos in your response
- Do NOT say "in the style of [brand]" - instead describe the aesthetic qualities
- Focus on describing the LOOK and FEEL, not the brand
- Write one cohesive paragraph that can generate VARIED outfits in this style`;

                    // Use a simple text analysis via the analyze endpoint with no images
                    const result = await fetch('/api/analyze', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            images: [],
                            prompt: textPrompt
                        })
                    }).then(r => r.json());

                    if (result.content) {
                        analysisResult = result.content;
                    }
                }

                if (analysisResult) {
                    state.analysis = analysisResult;
                    console.log('Style analysis stored:', state.analysis);

                    // For custom talent mode, parse the JSON scene elements
                    if (state.talentSource === 'custom') {
                        try {
                            // Extract JSON from the response (might have markdown code blocks)
                            let jsonStr = analysisResult;

                            // Remove markdown code blocks if present
                            jsonStr = jsonStr.replace(/```json\s*/gi, '').replace(/```\s*/g, '');

                            // Find the JSON object
                            const startIdx = jsonStr.indexOf('{');
                            const endIdx = jsonStr.lastIndexOf('}');
                            if (startIdx !== -1 && endIdx !== -1 && endIdx > startIdx) {
                                jsonStr = jsonStr.substring(startIdx, endIdx + 1);
                            }

                            // Try to repair truncated JSON - fix common issues
                            // 1. Unclosed strings at the end
                            jsonStr = jsonStr.replace(/,\s*"[^"]*$/, '');  // Remove incomplete last item
                            jsonStr = jsonStr.replace(/:\s*"[^"]*$/, ': ""');  // Close unclosed value string

                            // 2. Make sure all arrays are closed
                            const openBrackets = (jsonStr.match(/\[/g) || []).length;
                            const closeBrackets = (jsonStr.match(/\]/g) || []).length;
                            for (let i = 0; i < openBrackets - closeBrackets; i++) {
                                // Find the last incomplete array and close it
                                jsonStr = jsonStr.replace(/,\s*$/, '') + ']';
                            }

                            // 3. Make sure object is closed
                            if (!jsonStr.trim().endsWith('}')) {
                                jsonStr = jsonStr.replace(/,\s*$/, '') + '}';
                            }

                            // 4. Fix trailing commas before closing brackets
                            jsonStr = jsonStr.replace(/,\s*\]/g, ']');
                            jsonStr = jsonStr.replace(/,\s*\}/g, '}');

                            console.log('[Analyze] Cleaned JSON:', jsonStr.substring(0, 200) + '...');

                            state.sceneElements = JSON.parse(jsonStr);
                            console.log('[Analyze] Scene elements parsed:', state.sceneElements);
                            console.log(`  - ${state.sceneElements.environments?.length || 0} environments`);
                            console.log(`  - ${state.sceneElements.activities?.length || 0} activities`);
                            console.log(`  - ${state.sceneElements.props?.length || 0} props`);
                            console.log(`  - ${state.sceneElements.poses?.length || 0} poses`);
                            console.log(`  - ${state.sceneElements.interactions?.length || 0} interactions`);
                            console.log(`  - ${state.sceneElements.energy?.length || 0} energy types`);
                            console.log(`  - ${state.sceneElements.lighting?.length || 0} lighting styles`);
                            console.log(`  - ${state.sceneElements.mood?.length || 0} moods`);
                        } catch (parseError) {
                            console.warn('[Analyze] Could not parse scene elements as JSON, using as raw text:', parseError);
                            console.warn('[Analyze] Raw result:', analysisResult);
                            state.sceneElements = null;
                        }
                    }

                    // Only generate outfit pools if using Setset talent (not custom uploads)
                    // Custom uploads already have models in the right outfits
                    if (state.talentSource !== 'custom') {
                        // Generate outfit pools based on the analysis
                        updateLoadingProgress('Generating outfit variations...');

                        // Count how many outfits we need per gender based on image count
                        // Generate more than needed for variety
                        const outfitCount = Math.max(state.imageCount + 4, 8);

                        try {
                            const outfitResponse = await fetch('/api/generate-outfits', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    brandAnalysis: analysisResult,
                                    styleText: styleText,
                                    femaleCount: outfitCount,
                                    maleCount: outfitCount
                                })
                            });

                            const outfits = await outfitResponse.json();

                            if (outfits.female && outfits.male) {
                                state.outfits.female = outfits.female;
                                state.outfits.male = outfits.male;
                                state.outfits.usedFemale = 0;
                                state.outfits.usedMale = 0;
                                console.log(`Outfits generated: ${outfits.female.length} female, ${outfits.male.length} male`);
                                console.log('Female outfits sample:', outfits.female.slice(0, 2));
                                console.log('Male outfits sample:', outfits.male.slice(0, 2));
                            } else {
                                console.warn('Outfits response missing female or male pools:', outfits);
                            }
                        } catch (outfitError) {
                            console.error('Outfit generation error:', outfitError);
                            // Continue without outfits - will use generic clothing instruction
                        }
                    } else {
                        console.log('[Analyze] Skipping outfit generation - using custom talent with existing outfits');
                    }

                    // Generate environment options for Campaign mode only (not custom talent)
                    // Custom talent mode uses moodboard style directly, or location presets if selected
                    if (state.mode === 'campaign' && state.talentSource !== 'custom') {
                        updateLoadingProgress('Generating environment options...');
                        try {
                            const envResponse = await fetch('/api/generate-environments', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    brandAnalysis: analysisResult,
                                    styleText: styleText
                                })
                            });
                            const environments = await envResponse.json();
                            if (environments.indoor && environments.outdoor) {
                                state.generatedEnvironments.indoor = environments.indoor;
                                state.generatedEnvironments.outdoor = environments.outdoor;
                                // Auto-select first of each
                                state.selectedEnvironments.indoor = 0;
                                state.selectedEnvironments.outdoor = 0;
                                console.log(`Environments generated: ${environments.indoor.length} indoor, ${environments.outdoor.length} outdoor`);
                                updateCampaignEnvironments();
                                renderEnvironmentOptions();
                            }
                        } catch (envError) {
                            console.error('Environment generation error:', envError);
                        }
                    }
                }

                elements.analyzeBtn.textContent = 'Re-analyze';
                elements.analyzeBtn.classList.add('analyzed');

                updateUI();
            } catch (error) {
                console.error('Analysis error:', error);
                alert('Failed to analyze: ' + error.message);
            } finally {
                stopLoadingAnimation();
            }
        }

        // Handle Generate
        async function handleGenerate() {
            // Casting mode doesn't require analysis (uses random editorial moods)
            if (!state.analysis && state.mode !== 'casting') {
                alert('Please analyze the mood board first');
                return;
            }

            // Custom talent mode: use image-to-image remix with uploaded images
            if (state.talentSource === 'custom') {
                return handleGenerateCustomTalent();
            }

            // Create virtual outputs based on simplified state
            // Distribute solo vs group shots based on groupMix slider
            const activeOutputs = [];
            const totalImages = state.imageCount;
            const groupRatio = state.groupMix / 100;
            const numGroupShots = Math.round(totalImages * groupRatio);

            // Create array of people counts, then shuffle for variety
            const peopleCounts = [];
            for (let i = 0; i < totalImages; i++) {
                if (i < numGroupShots) {
                    // Group shot: randomly 2 or 3 people
                    peopleCounts.push(Math.random() < 0.5 ? 2 : 3);
                } else {
                    peopleCounts.push(1); // Solo shot
                }
            }
            // Shuffle to mix solo and group shots randomly
            for (let i = peopleCounts.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [peopleCounts[i], peopleCounts[j]] = [peopleCounts[j], peopleCounts[i]];
            }

            for (let i = 0; i < totalImages; i++) {
                activeOutputs.push({
                    index: i,
                    peopleCount: peopleCounts[i],
                    // Pose will be auto-selected based on mode
                    poseId: null
                });
            }

            if (activeOutputs.length === 0) return;

            state.results = [];
            elements.resultsGrid.innerHTML = '';
            elements.progressSection.classList.add('visible');
            startLoadingAnimation(`Generating ${activeOutputs.length} images...`);

            // Generate outfits if pools are empty but we have analysis (e.g., pre-loaded from collection)
            if ((!state.outfits.female || state.outfits.female.length === 0) && state.analysis) {
                console.log('[Generate] Outfit pools empty, generating outfits from analysis...');
                updateLoadingProgress('Generating outfit variations...');
                const outfitCount = Math.max(activeOutputs.length + 4, 8);
                try {
                    const outfitResponse = await fetch('/api/generate-outfits', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            brandAnalysis: state.analysis,
                            styleText: state.styleInput,
                            femaleCount: outfitCount,
                            maleCount: outfitCount
                        })
                    });
                    const outfits = await outfitResponse.json();
                    if (outfits.female && outfits.male) {
                        state.outfits.female = outfits.female;
                        state.outfits.male = outfits.male;
                        console.log(`[Generate] Outfits generated: ${outfits.female.length} female, ${outfits.male.length} male`);
                    }
                } catch (err) {
                    console.error('[Generate] Outfit generation error:', err);
                }
            }

            // Reset outfit counters for fresh distribution each generation
            state.outfits.usedFemale = 0;
            state.outfits.usedMale = 0;
            console.log(`[Generate] Outfit pools: ${state.outfits.female?.length || 0} female, ${state.outfits.male?.length || 0} male`);

            // Reset environment indices for campaign mode cycling
            state.currentIndoorIndex = 0;
            state.currentOutdoorIndex = 0;
            state.useIndoorNext = Math.random() > 0.5; // Random start each generation
            if (state.campaignEnvironments.indoor.length > 0) {
                console.log(`[Generate] Campaign locations - Indoor: ${state.campaignEnvironments.indoor[0]?.substring(0, 40)}..., Outdoor: ${state.campaignEnvironments.outdoor[0]?.substring(0, 40)}...`);
            }

            let completed = 0;
            const total = activeOutputs.length;
            elements.progressCount.textContent = `0 / ${total}`;
            elements.progressBar.style.width = '0%';

            // Get talent based on mode
            const isCasting = state.mode === 'casting';
            let allTalentData = [];

            if (isCasting) {
                // Hero is always included
                const heroData = TALENT.find(t => t.id === state.heroTalent);
                const supportingData = state.supportingTalent.map(id => TALENT.find(t => t.id === id)).filter(Boolean);
                allTalentData = [heroData, ...supportingData].filter(Boolean);
            } else {
                allTalentData = state.selectedTalent.map(id => TALENT.find(t => t.id === id)).filter(Boolean);
            }

            // Fisher-Yates shuffle for proper randomization
            function shuffle(array) {
                const arr = [...array];
                for (let i = arr.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                }
                return arr;
            }

            // Separate by gender, shuffle each, then interleave for fallback pool
            const females = shuffle(allTalentData.filter(t => t.gender === 'female'));
            const males = shuffle(allTalentData.filter(t => t.gender === 'male'));

            // Interleave: female, male, female, male... (or male, female if more males)
            const interleaved = [];
            const maxLen = Math.max(females.length, males.length);
            for (let i = 0; i < maxLen; i++) {
                if (i < females.length) interleaved.push(females[i]);
                if (i < males.length) interleaved.push(males[i]);
            }

            console.log(`[Talent] Selected: ${females.length} female, ${males.length} male, interleaved: ${interleaved.map(t => t.name).join(', ')}`);

            const talentAssignments = new Map();

            // Track usage count for each talent to ensure even distribution
            const talentUsageCount = new Map();
            allTalentData.forEach(t => talentUsageCount.set(t.id, 0));

            // Pre-assign talent to ALL slots, ensuring maximum variety
            // Strategy: For each slot, pick the least-used talent(s) that maintain gender balance
            // EXCEPTION: In casting mode, single-person slots ALWAYS use the hero
            activeOutputs.forEach((output, idx) => {
                const count = output.peopleCount;
                if (count === 0) return;

                if (count === 1) {
                    // CASTING MODE: Single person slots always use the hero
                    if (isCasting) {
                        const hero = allTalentData[0]; // Hero is always first in casting mode
                        talentUsageCount.set(hero.id, talentUsageCount.get(hero.id) + 1);
                        talentAssignments.set(output.index, [hero]);
                        return;
                    }

                    // E-commerce/Campaign: pick least-used talent, alternating genders
                    const targetGender = idx % 2 === 0 ? 'female' : 'male';
                    const genderPool = allTalentData.filter(t => t.gender === targetGender);
                    const fallbackPool = allTalentData.filter(t => t.gender !== targetGender);

                    // Sort by usage count (least used first)
                    const sortByUsage = (pool) => [...pool].sort((a, b) =>
                        talentUsageCount.get(a.id) - talentUsageCount.get(b.id)
                    );

                    let chosen;
                    const sortedGenderPool = sortByUsage(genderPool);
                    const sortedFallbackPool = sortByUsage(fallbackPool);

                    if (sortedGenderPool.length > 0) {
                        chosen = sortedGenderPool[0];
                    } else if (sortedFallbackPool.length > 0) {
                        chosen = sortedFallbackPool[0];
                    } else {
                        chosen = interleaved[0];
                    }

                    talentUsageCount.set(chosen.id, talentUsageCount.get(chosen.id) + 1);
                    talentAssignments.set(output.index, [chosen]);
                } else {
                    // Multi-person shots
                    // CASTING MODE: Hero is always first, then add supporting cast
                    if (isCasting) {
                        const hero = allTalentData[0];
                        const chosen = [hero];
                        talentUsageCount.set(hero.id, talentUsageCount.get(hero.id) + 1);

                        // Get supporting cast (everyone except hero), sorted by usage
                        const supporting = [...allTalentData]
                            .filter(t => t.id !== hero.id)
                            .sort((a, b) => talentUsageCount.get(a.id) - talentUsageCount.get(b.id));

                        // Add least-used supporting cast members
                        for (let i = 0; i < count - 1 && i < supporting.length; i++) {
                            chosen.push(supporting[i]);
                            talentUsageCount.set(supporting[i].id, talentUsageCount.get(supporting[i].id) + 1);
                        }

                        talentAssignments.set(output.index, chosen);
                        return;
                    }

                    // E-commerce/Campaign: pick N least-used talents, trying to balance genders
                    const sortedByUsage = [...allTalentData].sort((a, b) =>
                        talentUsageCount.get(a.id) - talentUsageCount.get(b.id)
                    );

                    const chosen = [];
                    const femalesNeeded = Math.ceil(count / 2);
                    const malesNeeded = count - femalesNeeded;

                    // Get least-used females
                    const availableFemales = sortedByUsage.filter(t => t.gender === 'female');
                    chosen.push(...availableFemales.slice(0, femalesNeeded));

                    // Get least-used males
                    const availableMales = sortedByUsage.filter(t => t.gender === 'male');
                    chosen.push(...availableMales.slice(0, malesNeeded));

                    // If we don't have enough of one gender, fill from the other
                    while (chosen.length < count && chosen.length < allTalentData.length) {
                        const remaining = sortedByUsage.filter(t => !chosen.includes(t));
                        if (remaining.length > 0) {
                            chosen.push(remaining[0]);
                        } else {
                            break;
                        }
                    }

                    // Update usage counts
                    chosen.forEach(t => {
                        talentUsageCount.set(t.id, talentUsageCount.get(t.id) + 1);
                    });

                    talentAssignments.set(output.index, chosen);
                }
            });

            console.log('[Talent Distribution]', [...talentAssignments.entries()].map(([idx, talents]) =>
                `Slot ${idx + 1}: ${talents.map(t => t.name).join(', ')}`
            ).join(' | '));

            // Helper to get talent for an output
            function getTalentForOutput(output) {
                const count = output.peopleCount;
                if (count === 0) return [];

                // Use pre-assigned talent for all slots
                if (talentAssignments.has(output.index)) {
                    return talentAssignments.get(output.index);
                }

                // Fallback (shouldn't happen)
                if (isCasting) {
                    // Hero is always first
                    const result = [allTalentData[0]]; // Hero
                    if (count > 1 && allTalentData.length > 1) {
                        // Add random supporting cast from interleaved pool
                        const supporting = interleaved.filter(t => t.id !== allTalentData[0].id);
                        result.push(...supporting.slice(0, count - 1));
                    }
                    return result;
                } else {
                    // Use interleaved pool to ensure gender mix in multi-person shots
                    return interleaved.slice(0, Math.min(count, interleaved.length));
                }
            }

            // Upload ALL talent images ONCE before generation starts
            console.log('Uploading talent images...');
            updateLoadingProgress('Uploading talent images...');
            const talentUrlMap = new Map();

            const uploadTalentPromises = allTalentData.map(async (talent) => {
                const url = talent.image;
                if (url.startsWith('/') || url.startsWith('./')) {
                    const response = await fetch(url);
                    const blob = await response.blob();
                    const file = new File([blob], 'image.png', { type: blob.type });
                    const result = await api.uploadImage(file);
                    talentUrlMap.set(talent.id, result.url);
                    console.log(`Uploaded ${talent.name}: ${result.url}`);
                } else {
                    talentUrlMap.set(talent.id, url);
                }
            });
            await Promise.all(uploadTalentPromises);
            console.log('All talent images uploaded!');
            updateLoadingProgress(`Generating ${activeOutputs.length} images...`);

            // Generate for each active output
            const startTime = Date.now();
            console.log(`[Parallel] Starting ${activeOutputs.length} requests at ${new Date().toLocaleTimeString()}`);

            const promises = activeOutputs.map(async (output) => {
                const slotStart = Date.now();
                try {
                    const talentForOutput = getTalentForOutput(output);

                    // Auto-select pose based on mode using pose pools
                    let poseDescription;
                    if (state.mode === 'ecommerce') {
                        // E-commerce: editorial studio poses
                        poseDescription = getPoseForMode('ecommerce');
                    } else if (state.mode === 'campaign') {
                        // Campaign: lifestyle poses (mix of walking, leaning, editorial, pocket)
                        poseDescription = getPoseForMode('campaign');
                    } else {
                        // Casting: editorial variety
                        poseDescription = getPoseForMode('casting');
                    }

                    // Create a virtual pose object for compatibility
                    const pose = {
                        id: `auto-${output.index}`,
                        name: state.mode === 'ecommerce' ? 'Editorial Studio' :
                              state.mode === 'campaign' ? 'Lifestyle' : 'Editorial',
                        poseDescription: poseDescription
                    };

                    if (talentForOutput.length === 0) {
                        console.log('No talent for output, skipping...');
                        return;
                    }

                    // Build prompt (pass talent array for outfit assignment by gender)
                    const prompt = buildPrompt(output, talentForOutput, pose);

                    // Get pre-uploaded URLs for this output's talent
                    const imageUrls = talentForOutput.map(t => talentUrlMap.get(t.id));
                    console.log(`[Parallel] Slot ${output.index + 1} STARTED at +${Date.now() - startTime}ms`);

                    // Generate
                    const params = {
                        prompt,
                        image_urls: imageUrls,
                        num_images: 1,
                        aspect_ratio: state.aspectRatio,
                        resolution: state.resolution,
                        output_format: 'png'
                    };

                    const data = await api.remixImage('nano-pro', params);

                    if (data.images && data.images.length > 0) {
                        console.log(`[Parallel] Slot ${output.index + 1} FINISHED at +${Date.now() - startTime}ms (took ${Date.now() - slotStart}ms)`);
                        state.results.push({
                            url: data.images[0].url,
                            prompt,
                            type: state.mode.charAt(0).toUpperCase() + state.mode.slice(1),
                            pose: pose.name,
                            peopleCount: output.peopleCount
                        });
                        renderResults();
                    }
                } catch (error) {
                    console.error('Generation error:', error);
                }

                completed++;
                elements.progressCount.textContent = `${completed} / ${total}`;
                elements.progressBar.style.width = `${(completed / total) * 100}%`;
            });

            await Promise.all(promises);
            stopLoadingAnimation();
            elements.progressSection.classList.remove('visible');
        }

        // Handle generation with custom uploaded talent images
        async function handleGenerateCustomTalent() {
            const customImages = state.customTalentImages.filter(img => img !== null);
            if (customImages.length === 0) {
                alert('Please upload at least one talent image');
                return;
            }

            state.results = [];
            elements.resultsGrid.innerHTML = '';
            elements.progressSection.classList.add('visible');
            startLoadingAnimation(`Generating ${state.imageCount} images from your uploads...`);

            let completed = 0;
            const total = state.imageCount;
            elements.progressCount.textContent = `0 / ${total}`;
            elements.progressBar.style.width = '0%';

            // Group images by model ID for smart selection
            const imagesByModel = {};
            customImages.forEach(img => {
                if (!imagesByModel[img.modelId]) {
                    imagesByModel[img.modelId] = [];
                }
                imagesByModel[img.modelId].push(img);
            });

            const uniqueModels = Object.keys(imagesByModel);
            console.log(`[Custom Talent] ${customImages.length} images across ${uniqueModels.length} models: ${uniqueModels.join(', ')}`);

            // Upload custom talent images to FAL (with model ID tracking)
            console.log('Uploading custom talent images...');
            updateLoadingProgress('Uploading your images...');
            const uploadedImages = []; // {url, modelId}

            for (const img of customImages) {
                try {
                    const result = await api.uploadBase64(img.url);
                    uploadedImages.push({ url: result.url, modelId: img.modelId });
                    console.log(`Uploaded custom talent (Model ${img.modelId}): ${result.url}`);
                } catch (err) {
                    console.warn('Failed to upload custom image:', err);
                }
            }

            if (uploadedImages.length === 0) {
                stopLoadingAnimation();
                elements.progressSection.classList.remove('visible');
                alert('Failed to upload images. Please try again.');
                return;
            }

            // Group uploaded images by model
            const uploadedByModel = {};
            uploadedImages.forEach(img => {
                if (!uploadedByModel[img.modelId]) {
                    uploadedByModel[img.modelId] = [];
                }
                uploadedByModel[img.modelId].push(img.url);
            });

            updateLoadingProgress(`Generating ${total} campaign images...`);

            // Get environment descriptions from analysis or generated environments
            const getEnvironment = (index) => {
                // Check for pre-selected library locations first
                const useIndoor = index % 2 === 0;
                const locations = useIndoor ? state.selectedCampaignLocations.indoor : state.selectedCampaignLocations.outdoor;
                const locationLib = useIndoor ? (typeof INDOOR_LOCATIONS !== 'undefined' ? INDOOR_LOCATIONS : []) : (typeof OUTDOOR_LOCATIONS !== 'undefined' ? OUTDOOR_LOCATIONS : []);

                if (locations && locations.length > 0) {
                    const locIdx = index % locations.length;
                    const locId = locations[locIdx];
                    const loc = locationLib.find(l => l.id === locId);
                    if (loc) return loc.prompt;
                }

                // Fall back to generated environments
                const envPool = useIndoor ? state.generatedEnvironments.indoor : state.generatedEnvironments.outdoor;
                if (envPool && envPool.length > 0) {
                    return envPool[index % envPool.length];
                }

                // No specific environments - use moodboard-derived style
                // Return null to signal we should use moodboard directly
                return null;
            };

            // Determine shot distribution based on groupMix slider
            const groupRatio = state.groupMix / 100;
            const numGroupShots = Math.round(total * groupRatio);
            const availableModels = Object.keys(uploadedByModel);
            const canDoGroupShots = availableModels.length >= 2;

            // Build shot assignments
            const shots = [];
            for (let i = 0; i < total; i++) {
                const isGroupShot = i < numGroupShots && canDoGroupShots;
                if (isGroupShot) {
                    // Group shot: pick 2-3 different models
                    const numPeople = Math.random() < 0.5 ? 2 : Math.min(3, availableModels.length);
                    const shuffledModels = [...availableModels].sort(() => Math.random() - 0.5);
                    const selectedModels = shuffledModels.slice(0, numPeople);
                    // Pick a random image from each selected model
                    const imageUrls = selectedModels.map(modelId => {
                        const urls = uploadedByModel[modelId];
                        return urls[Math.floor(Math.random() * urls.length)];
                    });
                    shots.push({ isGroup: true, peopleCount: numPeople, imageUrls, models: selectedModels });
                } else {
                    // Solo shot: pick random model and random image
                    const modelId = availableModels[Math.floor(Math.random() * availableModels.length)];
                    const urls = uploadedByModel[modelId];
                    const imageUrl = urls[Math.floor(Math.random() * urls.length)];
                    shots.push({ isGroup: false, peopleCount: 1, imageUrls: [imageUrl], models: [modelId] });
                }
            }

            // Shuffle shots to mix solo and group randomly
            for (let i = shots.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shots[i], shots[j]] = [shots[j], shots[i]];
            }

            console.log(`[Custom Talent] Shot distribution: ${shots.filter(s => s.isGroup).length} group, ${shots.filter(s => !s.isGroup).length} solo`);

            // Helper to pick random element from array
            const pickRandom = (arr) => arr && arr.length > 0 ? arr[Math.floor(Math.random() * arr.length)] : null;

            // Build scene description from parsed elements
            const buildSceneDescription = (isGroup) => {
                const se = state.sceneElements;
                if (!se) return null;

                const parts = [];

                // Environment (required)
                const env = pickRandom(se.environments);
                if (env) parts.push(env);

                // Activity/action
                const activity = pickRandom(se.activities);
                if (activity) parts.push(activity);

                // Props (50% chance)
                if (Math.random() < 0.5) {
                    const prop = pickRandom(se.props);
                    if (prop) parts.push(`with ${prop}`);
                }

                // Pose or interaction depending on shot type
                if (isGroup) {
                    const interaction = pickRandom(se.interactions);
                    if (interaction) parts.push(interaction);
                } else {
                    const pose = pickRandom(se.poses);
                    if (pose) parts.push(pose);
                }

                // Energy
                const energy = pickRandom(se.energy);
                if (energy) parts.push(`${energy} energy`);

                // Lighting
                const lighting = pickRandom(se.lighting);
                if (lighting) parts.push(lighting);

                // Mood
                const mood = pickRandom(se.mood);
                if (mood) parts.push(`${mood} atmosphere`);

                return parts.length > 0 ? parts.join(', ') : null;
            };

            // Generate images in parallel
            const startTime = Date.now();
            console.log(`[Custom Talent] Starting ${total} image-to-image generations`);

            const promises = shots.map((shot, i) => {
                // Build varied scene for each shot
                const sceneDescription = buildSceneDescription(shot.isGroup);
                const environment = getEnvironment(i);

                // Build prompt based on solo vs group
                // Priority: scene elements > selected locations > moodboard style
                let prompt;
                let envInstruction;

                if (sceneDescription) {
                    // Use rich scene elements from moodboard analysis
                    envInstruction = `Scene: ${sceneDescription}.`;
                } else if (environment) {
                    envInstruction = `Place ${shot.isGroup ? 'these people' : 'this person'} in: ${environment}.`;
                } else {
                    envInstruction = `Use the environment style, lighting, and mood from the moodboard reference images.`;
                }

                if (shot.isGroup) {
                    prompt = `High-end fashion editorial photograph featuring ${shot.peopleCount} people together in the same shot.
${envInstruction}
Keep their exact faces, bodies, poses, and OUTFITS unchanged - just combine them naturally in this new setting.
They should be interacting naturally as in a campaign photo - standing together, walking together, or posed as a group.
Professional fashion photography. Editorial quality. Sharp focus on all subjects.
${state.styleInput ? `Additional style: ${state.styleInput}` : ''}
Do NOT change their clothing. Keep the same outfits from the reference images.
Generate ONE SINGLE unified image only. Do NOT create a collage or split screen.`;
                } else {
                    prompt = `High-end fashion editorial photograph.
${envInstruction}
Keep their exact face, body, pose, and OUTFIT unchanged - just transform the background and lighting to match the style.
Professional fashion photography. Editorial quality. Sharp focus on the subject.
${state.styleInput ? `Additional style: ${state.styleInput}` : ''}
Do NOT change their clothing. Keep the same outfit from the reference image.`;
                }

                console.log(`[Custom Talent] Slot ${i + 1} scene: ${sceneDescription || environment || 'moodboard style'}`);


                return (async () => {
                    try {
                        console.log(`[Custom Talent] Slot ${i + 1} STARTED (${shot.isGroup ? 'group: ' + shot.models.join('+') : 'solo: ' + shot.models[0]})`);

                        const params = {
                            prompt,
                            image_urls: shot.imageUrls,
                            num_images: 1,
                            aspect_ratio: state.aspectRatio,
                            resolution: state.resolution,
                            output_format: 'png'
                        };

                        const data = await api.remixImage('nano-pro', params);

                        if (data.images && data.images.length > 0) {
                            console.log(`[Custom Talent] Slot ${i + 1} FINISHED at +${Date.now() - startTime}ms`);
                            state.results.push({
                                url: data.images[0].url,
                                prompt,
                                type: shot.isGroup ? 'Campaign (Group)' : 'Campaign (Custom)',
                                pose: 'Original',
                                peopleCount: shot.peopleCount,
                                models: shot.models
                            });
                            renderResults();
                        }
                    } catch (error) {
                        console.error(`[Custom Talent] Slot ${i + 1} error:`, error);
                    }

                    completed++;
                    elements.progressCount.textContent = `${completed} / ${total}`;
                    elements.progressBar.style.width = `${(completed / total) * 100}%`;
                })();
            });

            await Promise.all(promises);
            stopLoadingAnimation();
            elements.progressSection.classList.remove('visible');
        }

        // Build prompt based on mode and output
        function buildPrompt(output, talentArray, pose) {
            const numPeople = talentArray.length;
            let analysis = state.analysis || '';
            const styleInput = state.styleInput.trim();

            // Remove brand names first
            const brandBlacklist = [
                'Gucci', 'Louis Vuitton', 'LV', 'Prada', 'Chanel', 'Dior', 'HermÃ¨s', 'Hermes',
                'Burberry', 'Balenciaga', 'Versace', 'Fendi', 'Givenchy', 'Saint Laurent', 'YSL',
                'Bottega Veneta', 'Valentino', 'Alexander McQueen', 'Celine', 'Loewe', 'Moncler',
                'Off-White', 'Supreme', 'Nike', 'Adidas', 'Zara', 'H&M', 'Uniqlo', 'Reformation',
                'Rolex', 'Cartier', 'Tiffany', 'Bulgari', 'Van Cleef', 'Armani', 'Dolce & Gabbana',
                'Tom Ford', 'Marc Jacobs', 'Coach', 'Michael Kors', 'Kate Spade', 'Ralph Lauren',
                'Calvin Klein', 'Tommy Hilfiger', 'Hugo Boss', 'Stella McCartney', 'Acne Studios'
            ];
            brandBlacklist.forEach(brand => {
                const regex = new RegExp(`\\b${brand}\\b`, 'gi');
                analysis = analysis.replace(regex, '');
            });
            analysis = analysis.replace(/\s{2,}/g, ' ').trim();

            // Anti-splitting instruction
            const noSplitting = 'Generate ONE SINGLE unified image only. Do NOT create a collage, grid, triptych, diptych, split screen, or multiple panels. The output must be one continuous photograph.';

            // Get specific outfit based on talent gender
            const getOutfitForTalent = (talent) => {
                const gender = talent.gender || 'female';
                const pool = gender === 'male' ? state.outfits.male : state.outfits.female;
                const usedKey = gender === 'male' ? 'usedMale' : 'usedFemale';

                console.log(`[Outfit Debug] Talent: ${talent.name}, Gender: ${gender}, Pool size: ${pool?.length || 0}, Counter: ${state.outfits[usedKey]}`);

                if (pool && pool.length > 0) {
                    // Get next outfit from pool (cycling through)
                    const index = state.outfits[usedKey] % pool.length;
                    state.outfits[usedKey]++;
                    const outfit = pool[index];
                    console.log(`[Outfit Debug] Selected outfit #${index}: ${outfit?.substring(0, 60)}...`);
                    return outfit;
                }
                console.warn(`[Outfit Debug] No ${gender} outfits in pool!`);
                return null;
            };

            // Build outfit instruction based on talent
            let clothingInstruction = '';
            if (numPeople === 1) {
                const talent = talentArray[0];
                const outfit = getOutfitForTalent(talent);
                console.log(`Outfit assignment: ${talent.name} (${talent.gender}) -> ${outfit?.substring(0, 50)}...`);
                if (outfit) {
                    clothingInstruction = `OUTFIT: ${outfit}.`;
                } else if (styleInput) {
                    clothingInstruction = `Dress them in: ${styleInput}.`;
                } else {
                    clothingInstruction = 'Dress them in an outfit that fits the aesthetic.';
                }
            } else {
                // Multiple people - assign outfits to each
                const outfitDescriptions = talentArray.map((talent, i) => {
                    const outfit = getOutfitForTalent(talent);
                    if (outfit) {
                        return `Person ${i + 1}: ${outfit}`;
                    }
                    return null;
                }).filter(Boolean);

                if (outfitDescriptions.length > 0) {
                    clothingInstruction = `OUTFITS: ${outfitDescriptions.join('. ')}.`;
                } else if (styleInput) {
                    clothingInstruction = `Dress them in varied outfits: ${styleInput}.`;
                } else {
                    clothingInstruction = 'Dress each person in different outfits that fit the aesthetic.';
                }
            }

            // People text - critical for multi-person shots
            const peopleText = numPeople === 1
                ? 'this exact person from the reference image'
                : `these exact ${numPeople} people from the reference images together in the same shot`;

            // Style directive - always add to prompt if provided (e.g., "sunglasses on every shot")
            const styleDirective = styleInput ? `IMPORTANT STYLE DIRECTIVE: ${styleInput}.` : '';

            let prompt = '';

            // Get pose prompt - either from auto-selected pose pool or legacy POSE_PROMPTS
            let selectedPosePrompt;
            if (pose.poseDescription) {
                // New simplified system: use pose description from pose pools
                selectedPosePrompt = `${pose.poseDescription}, [PRODUCT_DESCRIPTION]. Sharp editorial lighting. Keep identical facial features.`;
            } else if (typeof POSE_PROMPTS !== 'undefined' && POSE_PROMPTS[pose.id]) {
                // Legacy: use POSE_PROMPTS
                const prompts = POSE_PROMPTS[pose.id];
                selectedPosePrompt = prompts[Math.floor(Math.random() * prompts.length)];
            } else {
                // Fallback
                selectedPosePrompt = 'standing naturally with relaxed posture, direct gaze, [PRODUCT_DESCRIPTION]. Sharp editorial lighting.';
            }

            // Energy-based pose and interaction instructions
            const energyText = state.energy === 'masculine'
                ? 'strong, bold, powerful energy with grounded confident stances'
                : state.energy === 'feminine'
                    ? 'soft, elegant, graceful energy with flowing natural movement'
                    : 'balanced, natural energy';

            // Multi-person interaction based on energy
            let poseVarietyInstruction = '';
            if (numPeople > 1) {
                if (state.energy === 'feminine') {
                    // Feminine: closer interactions, softer poses
                    const feminineInteractions = [
                        'gentle closeness between them, soft body language, relaxed shoulders touching',
                        'elegant proximity, one slightly leaning toward the other, graceful hand placement',
                        'intimate but editorial distance, soft gazes, flowing natural poses',
                        'standing close with gentle interaction, soft feminine energy between them'
                    ];
                    poseVarietyInstruction = feminineInteractions[Math.floor(Math.random() * feminineInteractions.length)] + '. ';
                } else if (state.energy === 'masculine') {
                    // Masculine: more space, stronger poses
                    const masculineInteractions = [
                        'confident stances with editorial spacing, powerful individual presence',
                        'strong independent poses, grounded body language, direct gazes',
                        'bold positioning with intentional space between them, commanding presence',
                        'powerful parallel stances, squared shoulders, strong masculine energy'
                    ];
                    poseVarietyInstruction = masculineInteractions[Math.floor(Math.random() * masculineInteractions.length)] + '. ';
                } else {
                    // Balanced: variety
                    poseVarietyInstruction = 'Give each person a DIFFERENT natural pose. Vary their stance, arm positions, and where they look. Create visual interest through contrasting poses. ';
                }
            }

            if (state.mode === 'ecommerce') {
                // E-commerce: Always white studio background
                const groupInstruction = numPeople > 1
                    ? `Place ${peopleText} standing together in the same frame. ${poseVarietyInstruction}`
                    : '';

                // Use the selected pose prompt, replacing [PRODUCT_DESCRIPTION] with outfit
                let poseInstruction = selectedPosePrompt.replace('[PRODUCT_DESCRIPTION]', clothingInstruction);

                // Add energy for group shots
                const energyInstruction = numPeople > 1 ? ` ${energyText}.` : '';

                // Build prompt using the actual selected pose
                prompt = `${noSplitting} ${styleDirective} ${groupInstruction}${poseInstruction}${energyInstruction} ${analysis}. Clean white studio background, professional e-commerce lighting.`;
            } else if (state.mode === 'campaign') {
                // Campaign: Alternate between indoor and outdoor locations
                // Use the selected pose but in environmental setting
                let poseInstruction = selectedPosePrompt
                    .replace('[PRODUCT_DESCRIPTION]', clothingInstruction)
                    .replace(/white studio/gi, 'editorial campaign setting')
                    .replace(/studio/gi, 'location');

                // Alternate between indoor and outdoor, cycling through variations
                let environmentDescription = '';

                // Check if we have pre-selected locations from the library
                const hasPreSelectedIndoor = state.selectedCampaignLocations.indoor.length > 0;
                const hasPreSelectedOutdoor = state.selectedCampaignLocations.outdoor.length > 0;
                const hasPreSelectedLocations = hasPreSelectedIndoor || hasPreSelectedOutdoor;

                // Use pre-selected locations if available, otherwise use mood-board derived ones
                if (hasPreSelectedLocations) {
                    if (state.useIndoorNext && hasPreSelectedIndoor) {
                        // Get next indoor from pre-selected
                        const idx = state.currentLocationIndoorIdx % state.selectedCampaignLocations.indoor.length;
                        const locationId = state.selectedCampaignLocations.indoor[idx];
                        const location = INDOOR_LOCATIONS.find(l => l.id === locationId);
                        if (location) {
                            environmentDescription = location.prompt;
                            state.currentLocationIndoorIdx++;
                            console.log(`[Campaign] Pre-selected indoor: ${location.name}`);
                        }
                    } else if (hasPreSelectedOutdoor) {
                        // Get next outdoor from pre-selected
                        const idx = state.currentLocationOutdoorIdx % state.selectedCampaignLocations.outdoor.length;
                        const locationId = state.selectedCampaignLocations.outdoor[idx];
                        const location = OUTDOOR_LOCATIONS.find(l => l.id === locationId);
                        if (location) {
                            environmentDescription = location.prompt;
                            state.currentLocationOutdoorIdx++;
                            console.log(`[Campaign] Pre-selected outdoor: ${location.name}`);
                        }
                    } else if (hasPreSelectedIndoor) {
                        // Fallback to indoor if no outdoor selected
                        const idx = state.currentLocationIndoorIdx % state.selectedCampaignLocations.indoor.length;
                        const locationId = state.selectedCampaignLocations.indoor[idx];
                        const location = INDOOR_LOCATIONS.find(l => l.id === locationId);
                        if (location) {
                            environmentDescription = location.prompt;
                            state.currentLocationIndoorIdx++;
                            console.log(`[Campaign] Pre-selected indoor (fallback): ${location.name}`);
                        }
                    }
                    // Alternate for next image
                    state.useIndoorNext = !state.useIndoorNext;
                } else {
                    // Fall back to mood-board derived environments
                    const hasIndoor = state.campaignEnvironments.indoor.length > 0;
                    const hasOutdoor = state.campaignEnvironments.outdoor.length > 0;

                    if (hasIndoor || hasOutdoor) {
                        if (state.useIndoorNext && hasIndoor) {
                            // Get next indoor variation
                            const idx = state.currentIndoorIndex % state.campaignEnvironments.indoor.length;
                            environmentDescription = state.campaignEnvironments.indoor[idx];
                            state.currentIndoorIndex++;
                            console.log(`[Campaign] Indoor variation ${idx + 1}: ${environmentDescription.substring(0, 50)}...`);
                        } else if (hasOutdoor) {
                            // Get next outdoor variation
                            const idx = state.currentOutdoorIndex % state.campaignEnvironments.outdoor.length;
                            environmentDescription = state.campaignEnvironments.outdoor[idx];
                            state.currentOutdoorIndex++;
                            console.log(`[Campaign] Outdoor variation ${idx + 1}: ${environmentDescription.substring(0, 50)}...`);
                        }
                        // Alternate for next image
                        state.useIndoorNext = !state.useIndoorNext;
                    }
                }

                const environmentClause = environmentDescription
                    ? `Shot in: ${environmentDescription}.`
                    : 'Use the environmental style, locations, and mood from the reference images.';

                // Add energy for group shots
                const energyInstruction = numPeople > 1 ? ` ${energyText}.` : '';

                prompt = `${noSplitting} ${styleDirective} Place ${peopleText} in an editorial campaign setting. ${poseVarietyInstruction}${poseInstruction}${energyInstruction} ${analysis}. ${environmentClause} Fashion editorial style, creative composition, dramatic lighting, high-end fashion campaign aesthetic.`;
            } else if (state.mode === 'casting') {
                // Casting: Editorial variety with moods from curated pool
                // Get gender of primary talent (hero) for mood selection
                const primaryGender = talentArray[0]?.gender || 'female';

                // Get mood - either from pre-selected pool (cycle through) or random
                let mood;
                if (state.selectedCastingMoods.length > 0) {
                    // Cycle through selected moods using output index
                    const moodIndex = outputIndex % state.selectedCastingMoods.length;
                    const selectedMoodId = state.selectedCastingMoods[moodIndex];
                    // Find the mood in the appropriate gender pool
                    const moodPool = primaryGender === 'female' ? EDITORIAL_MOODS_FEMALE : EDITORIAL_MOODS_MALE;
                    mood = moodPool.find(m => m.id === selectedMoodId);
                    // Fallback to female pool if not found in gender-specific pool
                    if (!mood) {
                        mood = EDITORIAL_MOODS_FEMALE.find(m => m.id === selectedMoodId) ||
                               EDITORIAL_MOODS_MALE.find(m => m.id === selectedMoodId);
                    }
                    console.log(`[Casting] Selected mood from pre-selection: ${mood?.name || 'fallback'} (index ${moodIndex})`);
                }
                // Fallback to random if no pre-selection or mood not found
                if (!mood) {
                    mood = getRandomEditorialMood(primaryGender);
                    console.log(`[Casting] Random mood: ${mood.name} for ${primaryGender}`);
                }

                // Simplified: Use default headshot framing for casting mode
                // Casting is about showcasing the model/talent, so headshot/portrait framing works best
                const framing = { id: 'headshot', name: 'Headshot', prompt: 'headshot portrait, head and shoulders, centered composition' };
                console.log(`[Casting] Framing: ${framing.name}`);

                // Simplified: Casting always uses studio style for clean, professional look
                const castingStyle = 'studio';
                console.log(`[Casting] Style: ${castingStyle}`);

                // Get pose instruction but strip out body framing words (framing selector takes precedence)
                let poseInstruction = selectedPosePrompt.replace('[PRODUCT_DESCRIPTION]', clothingInstruction);
                // Remove conflicting framing terms from pose - framing selector controls this
                poseInstruction = poseInstruction
                    .replace(/Full-body portrait/gi, 'Portrait')
                    .replace(/full-body/gi, '')
                    .replace(/full body/gi, '')
                    .replace(/half-body/gi, '')
                    .replace(/half body/gi, '')
                    .replace(/three-quarter/gi, '')
                    .replace(/head to toe/gi, '')
                    .replace(/from waist up/gi, '')
                    .replace(/from thighs up/gi, '')
                    .replace(/from chest up/gi, '')
                    .replace(/close-up/gi, '')
                    .replace(/closeup/gi, '')
                    .replace(/headshot/gi, '')
                    .trim();
                console.log(`[Casting] Pose: ${pose.name}`);

                // For multi-person shots, adjust framing if extreme close-up (doesn't work well with groups)
                let adjustedFraming = framing;
                if (numPeople > 1 && framing.id === 'extreme-closeup') {
                    // Upgrade to close-up for multiple people
                    adjustedFraming = { id: 'closeup', name: 'Close-Up', prompt: 'close-up portrait heads and shoulders tightly framed' };
                }

                // Build the editorial prompt
                const groupInstruction = numPeople > 1
                    ? `Place ${peopleText} together in the frame, all facing camera. ${poseVarietyInstruction}`
                    : `Feature ${peopleText}. `;

                // Add energy for group shots
                const energyInstruction = numPeople > 1 ? ` ${energyText}.` : '';

                // Different background based on casting style
                const backgroundInstruction = castingStyle === 'studio'
                    ? 'Clean white studio environment with professional lighting, seamless white backdrop.'
                    : 'Editorial campaign setting with sophisticated architectural or natural environment backdrop.';

                // Framing comes FIRST to set the shot composition, then pose for body position
                // Note: mood.prompt may contain B&W instructions - we strip those out for color photos
                let moodPrompt = mood.prompt
                    .replace(/black and white/gi, 'color')
                    .replace(/b&w/gi, 'color')
                    .replace(/monochrome/gi, 'color tones')
                    .replace(/with grain/gi, 'with subtle film quality');

                prompt = `${noSplitting} ${styleDirective} ${groupInstruction}FRAMING: ${adjustedFraming.prompt}. ${poseInstruction}${energyInstruction} ${backgroundInstruction} EDITORIAL STYLE: ${moodPrompt}. High-end fashion editorial photography in full color.`;
            }

            return prompt;
        }

        // Render results
        function renderResults() {
            if (state.results.length === 0) {
                elements.resultsSection.classList.remove('visible');
                return;
            }

            elements.resultsSection.classList.add('visible');
            elements.resultsGrid.innerHTML = state.results.map((result, index) => `
                <div class="result-card" onclick="openLightbox(${index})">
                    <img src="${result.url}" alt="Result ${index + 1}">
                </div>
            `).join('');
        }

        // Lightbox
        window.openLightbox = function(index) {
            state.lightboxIndex = index;
            updateLightboxContent();
            elements.lightbox.classList.add('visible');
        };

        function updateLightboxContent() {
            const result = state.results[state.lightboxIndex];
            elements.lightboxImage.src = result.url;
            elements.lightboxType.textContent = result.type;
            elements.lightboxPose.textContent = result.pose;
            elements.lightboxPrompt.textContent = result.prompt;
        }

        function closeLightbox() {
            elements.lightbox.classList.remove('visible');
        }

        // Initialize
        init();
    </script>
</body>
</html>
